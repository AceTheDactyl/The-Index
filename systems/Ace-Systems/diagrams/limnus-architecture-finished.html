<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LIMNUS Unified Architecture | 63-Point Prism ¬∑ 32-Point EM Cage | z = ‚àö3/2</title>
    <style>
        :root {
            --bg-void: #030308;
            --bg-panel: rgba(15, 12, 25, 0.92);
            --prism-core: #ff6b6b;
            --prism-mid: #ffd43b;
            --prism-outer: #69db7c;
            --cage-field: #4dabf7;
            --cage-vertex: #cc5de8;
            --critical-gold: #ffd700;
            --presence-white: #fffcf8;
            --absence-sepia: rgba(120, 100, 80, 0.8);
            --text-primary: rgba(255, 245, 230, 0.9);
            --text-dim: rgba(255, 220, 180, 0.5);
            --border-glow: rgba(168, 85, 247, 0.4);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: var(--bg-void);
            overflow: hidden;
            font-family: 'SF Mono', 'Fira Code', 'Courier New', monospace;
            color: var(--text-primary);
        }

        canvas { display: block; cursor: crosshair; }

        /* Custom cursor */
        #cursor {
            position: fixed;
            width: 24px;
            height: 24px;
            border: 1px solid rgba(255, 215, 0, 0.4);
            border-radius: 50%;
            pointer-events: none;
            z-index: 2000;
            transform: translate(-50%, -50%);
            transition: all 0.25s ease;
        }
        #cursor.absence { border-color: rgba(150, 130, 110, 0.6); box-shadow: none; }
        #cursor.critical { 
            border-color: rgba(255, 215, 0, 0.9);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.5), 0 0 50px rgba(255, 180, 100, 0.3);
        }
        #cursor.presence { 
            border-color: rgba(255, 252, 248, 0.8);
            box-shadow: 0 0 20px rgba(255, 250, 240, 0.4);
        }

        .panel {
            position: fixed;
            pointer-events: none;
            z-index: 100;
            user-select: none;
            background: rgba(10, 8, 6, 0.88);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(168, 85, 247, 0.25);
            border-radius: 10px;
            padding: 12px 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5),
                        0 0 30px rgba(168, 85, 247, 0.08),
                        inset 0 1px 0 rgba(255, 255, 255, 0.03);
        }

        /* ========================================
           LEFT SIDE PANELS - SLICK #2c003e DESIGN
           Tubes, thick borders, cool colors
           ======================================== */
        .panel.left-panel {
            background: linear-gradient(135deg,
                rgba(44, 0, 62, 0.95) 0%,
                rgba(30, 0, 45, 0.92) 50%,
                rgba(20, 0, 35, 0.95) 100%);
            border: 3px solid transparent;
            border-image: linear-gradient(180deg,
                rgba(0, 255, 255, 0.6) 0%,
                rgba(168, 85, 247, 0.8) 50%,
                rgba(255, 100, 200, 0.6) 100%) 1;
            border-radius: 0;
            box-shadow:
                0 0 20px rgba(44, 0, 62, 0.8),
                0 0 40px rgba(168, 85, 247, 0.3),
                inset 0 0 30px rgba(0, 255, 255, 0.05),
                inset 0 1px 0 rgba(0, 255, 255, 0.1),
                inset 0 -1px 0 rgba(255, 100, 200, 0.1);
            padding: 14px 16px;
        }

        /* Tube connector styling for left panels */
        .panel.left-panel::before {
            content: '';
            position: absolute;
            right: -12px;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 4px;
            background: linear-gradient(90deg,
                rgba(0, 255, 255, 0.8) 0%,
                rgba(168, 85, 247, 0.6) 50%,
                transparent 100%);
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.5);
        }

        /* Accent line at top of left panels */
        .panel.left-panel::after {
            content: '';
            position: absolute;
            top: 0;
            left: 10%;
            right: 10%;
            height: 2px;
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(0, 255, 255, 0.8) 20%,
                rgba(255, 215, 0, 0.9) 50%,
                rgba(255, 100, 200, 0.8) 80%,
                transparent 100%);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        /* Header - transparent, no box */
        #header {
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            background: transparent;
            border: none;
            box-shadow: none;
            backdrop-filter: none;
            padding: 0;
        }

        #header h1 {
            font-size: 28px;
            font-weight: 100;
            letter-spacing: 12px;
            margin-bottom: 8px;
            transition: all 0.6s ease;
        }

        #header h1.absence { 
            color: rgba(120, 100, 80, 0.7);
            text-shadow: 0 0 30px rgba(80, 60, 40, 0.3);
        }
        #header h1.critical { 
            color: var(--critical-gold);
            text-shadow: 0 0 60px rgba(255, 215, 0, 0.9),
                         0 0 120px rgba(255, 180, 100, 0.5);
            animation: criticalPulse 1.8s ease-in-out infinite;
        }
        #header h1.presence { 
            color: var(--presence-white);
            text-shadow: 0 0 50px rgba(255, 250, 240, 0.7),
                         0 0 100px rgba(255, 220, 180, 0.4);
        }

        @keyframes criticalPulse {
            0%, 100% { opacity: 0.85; }
            50% { opacity: 1; }
        }

        #header .subtitle {
            font-size: 11px;
            letter-spacing: 5px;
            color: var(--text-dim);
        }

        /* Z-Coordinate Panel - TOP RIGHT */
        #z-panel {
            top: 90px;
            right: 20px;
            text-align: right;
            min-width: 110px;
        }

        #z-display {
            font-size: 42px;
            font-weight: 100;
            letter-spacing: 3px;
            transition: all 0.5s ease;
        }

        #z-display.absence { color: rgba(140, 120, 100, 0.6); }
        #z-display.critical { 
            color: var(--critical-gold);
            text-shadow: 0 0 60px rgba(255, 215, 0, 0.9);
        }
        #z-display.presence { 
            color: var(--presence-white);
            text-shadow: 0 0 40px rgba(255, 250, 240, 0.7);
        }

        #phase-label {
            font-size: 12px;
            letter-spacing: 4px;
            margin-top: 8px;
            text-transform: uppercase;
            transition: color 0.5s ease;
        }

        /* Domain Panel - TOP LEFT */
        #domain-panel {
            top: 80px;
            left: 15px;
            min-width: 140px;
        }

        #domain-indicator {
            font-size: 16px;
            letter-spacing: 6px;
            transition: all 0.6s ease;
            color: rgba(0, 255, 255, 0.9);
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        #domain-indicator.absence {
            color: rgba(150, 100, 180, 0.8);
            text-shadow: 0 0 20px rgba(100, 50, 150, 0.5);
        }
        #domain-indicator.critical {
            color: #ffb347;
            text-shadow: 0 0 40px rgba(255, 180, 100, 0.7);
        }
        #domain-indicator.presence {
            color: rgba(0, 255, 200, 0.95);
            text-shadow: 0 0 30px rgba(0, 255, 200, 0.6);
        }

        .domain-stat {
            font-size: 9px;
            margin-top: 12px;
            letter-spacing: 2px;
            color: rgba(0, 255, 255, 0.6);
            text-transform: uppercase;
        }

        .domain-value {
            font-size: 18px;
            margin-top: 4px;
            font-weight: 100;
            transition: color 0.4s ease;
            color: rgba(255, 215, 0, 0.9);
        }

        /* Architecture Panel - BELOW Z-PANEL */
        #architecture-panel {
            top: 220px;
            right: 20px;
            text-align: right;
            font-size: 9px;
            pointer-events: auto;
            min-width: 145px;
            max-height: 180px;
            overflow-y: auto;
        }

        .arch-title {
            letter-spacing: 4px;
            margin-bottom: 12px;
            color: rgba(168, 85, 247, 0.8);
            font-size: 11px;
        }

        .arch-section {
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(168, 85, 247, 0.2);
        }

        .arch-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .arch-label {
            color: var(--text-dim);
            margin-bottom: 6px;
        }

        .layer-row {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 10px;
            margin: 4px 0;
            opacity: 0.3;
            transition: all 0.4s ease;
        }

        .layer-row.active { opacity: 0.8; }
        .layer-row.resonant { 
            opacity: 1;
            text-shadow: 0 0 10px currentColor;
        }

        .layer-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            transition: all 0.4s ease;
        }

        .layer-row.resonant .layer-dot {
            transform: scale(1.8);
            box-shadow: 0 0 15px currentColor;
        }

        /* Prism layers */
        .prism-l0 .layer-dot { background: #ff6b6b; }
        .prism-l1 .layer-dot { background: #ff8787; }
        .prism-l2 .layer-dot { background: #ffa94d; }
        .prism-l3 .layer-dot { background: #ffc078; }
        .prism-l4 .layer-dot { background: #ffd43b; }
        .prism-l5 .layer-dot { background: #ffe066; }
        .prism-l6 .layer-dot { background: #69db7c; }

        /* EM Cage layers */
        .cage-top .layer-dot { background: #4dabf7; }
        .cage-bot .layer-dot { background: #74c0fc; }
        .cage-vtx .layer-dot { background: #cc5de8; }

        /* Dynamics Panel - LEFT SIDE (above controls) */
        #dynamics-panel {
            top: 405px;
            left: 15px;
            font-size: 8px;
            min-width: 170px;
        }

        .dynamics-row {
            margin: 5px 0;
            color: rgba(0, 255, 255, 0.7);
            display: flex;
            align-items: center;
        }

        .dynamics-label {
            display: inline-block;
            width: 75px;
            letter-spacing: 1px;
            color: rgba(168, 85, 247, 0.8);
            font-size: 8px;
        }

        .dynamics-bar {
            font-family: monospace;
            letter-spacing: -1px;
            color: rgba(0, 255, 255, 0.9);
            text-shadow: 0 0 6px rgba(0, 255, 255, 0.5);
            font-size: 9px;
        }

        .dynamics-value {
            font-size: 9px;
            color: rgba(255, 215, 0, 0.9);
            margin-left: 8px;
            min-width: 40px;
            text-align: right;
        }

        /* Helix Panel - BELOW ARCHITECTURE */
        #helix-panel {
            top: 410px;
            right: 20px;
            text-align: right;
            font-size: 10px;
            color: var(--text-dim);
            min-width: 130px;
        }

        .helix-row { margin: 6px 0; }
        .helix-sym { 
            margin-right: 10px;
            color: rgba(168, 85, 247, 0.8);
            font-weight: 600;
        }
        .helix-val {
            font-family: 'SF Mono', monospace;
            color: var(--critical-gold);
        }

        /* Lambda State Panel - BELOW DOMAIN */
        #lambda-panel {
            top: 215px;
            left: 15px;
            font-size: 9px;
            min-width: 155px;
        }

        .lambda-title {
            letter-spacing: 3px;
            margin-bottom: 10px;
            color: rgba(0, 255, 255, 0.8);
            font-size: 10px;
            text-transform: uppercase;
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
            padding-bottom: 6px;
        }

        .lambda-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
        }

        .lambda-glyph {
            font-size: 14px;
            width: 20px;
            text-align: center;
            color: rgba(255, 100, 200, 0.9);
            text-shadow: 0 0 8px rgba(255, 100, 200, 0.5);
        }

        .lambda-bar-container {
            flex: 1;
            height: 5px;
            background: rgba(44, 0, 62, 0.8);
            border-radius: 2px;
            overflow: hidden;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }

        .lambda-bar {
            height: 100%;
            background: linear-gradient(90deg,
                rgba(0, 255, 255, 0.9) 0%,
                rgba(168, 85, 247, 0.9) 50%,
                rgba(255, 100, 200, 0.9) 100%);
            border-radius: 2px;
            transition: width 0.3s ease;
            box-shadow: 0 0 6px rgba(0, 255, 255, 0.5);
        }

        .lambda-val {
            font-family: monospace;
            width: 35px;
            text-align: right;
            color: rgba(255, 215, 0, 0.9);
            font-size: 10px;
        }

        /* Sonification Panel - BOTTOM CENTER */
        #sonification-panel {
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 9px;
            pointer-events: auto;
            padding: 10px 25px;
        }

        .sonif-row {
            display: inline-flex;
            align-items: center;
            gap: 20px;
        }

        .sonif-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .sonif-label {
            font-size: 9px;
            letter-spacing: 2px;
            color: var(--text-dim);
            margin-bottom: 3px;
        }

        .sonif-value {
            font-size: 14px;
            color: var(--critical-gold);
            font-weight: 500;
        }

        #audio-toggle {
            background: rgba(168, 85, 247, 0.3);
            border: 1px solid rgba(168, 85, 247, 0.5);
            color: var(--text-primary);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 10px;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            margin-left: 20px;
        }

        #audio-toggle:hover {
            background: rgba(168, 85, 247, 0.5);
            transform: translateY(-2px);
        }

        #audio-toggle.active {
            background: rgba(255, 215, 0, 0.3);
            border-color: rgba(255, 215, 0, 0.6);
        }

        /* Controls - BOTTOM LEFT CORNER */
        #controls {
            bottom: 15px;
            left: 15px;
            font-size: 8px;
            letter-spacing: 1px;
            color: rgba(0, 255, 255, 0.6);
            line-height: 1.5;
            min-width: 135px;
        }

        #controls span {
            color: rgba(255, 215, 0, 0.9);
            font-weight: 600;
            text-shadow: 0 0 6px rgba(255, 215, 0, 0.4);
        }

        /* Stats - BOTTOM-RIGHT CORNER */
        #stats {
            bottom: 15px;
            right: 20px;
            font-size: 8px;
            text-align: right;
            color: var(--text-dim);
            min-width: 90px;
            padding: 10px 15px;
        }

        /* Release Coherence State */
        #release-state {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            z-index: 150;
            opacity: 0;
            transition: opacity 1s ease;
        }

        #release-state.visible {
            opacity: 1;
        }

        #release-state h2 {
            font-size: 48px;
            font-weight: 100;
            letter-spacing: 18px;
            color: var(--presence-white);
            text-shadow: 0 0 80px rgba(255, 250, 240, 0.7);
            margin-bottom: 15px;
            transition: all 0.8s ease;
        }

        #release-state.coherent h2 {
            color: var(--absence-sepia);
            text-shadow: 0 0 40px rgba(80, 60, 40, 0.4);
        }

        #release-state.releasing h2 {
            color: var(--critical-gold);
            text-shadow: 0 0 60px rgba(255, 215, 0, 0.8);
        }

        #release-state.dispersing h2 {
            color: rgba(255, 250, 240, 0.8);
            text-shadow: 0 0 70px rgba(255, 250, 240, 0.6);
        }

        #release-state.free h2 {
            color: var(--presence-white);
            text-shadow: 0 0 100px rgba(255, 250, 240, 0.9),
                         0 0 150px rgba(255, 220, 180, 0.5);
            animation: freeGlow 2s ease-in-out infinite;
        }

        @keyframes freeGlow {
            0%, 100% { opacity: 0.85; letter-spacing: 18px; }
            50% { opacity: 1; letter-spacing: 22px; }
        }

        #coherence-indicator {
            font-size: 14px;
            letter-spacing: 3px;
            color: var(--text-dim);
            font-family: monospace;
            transition: color 0.5s ease;
        }

        #coherence-indicator.free {
            color: var(--presence-white);
        }

        #release-hint {
            position: fixed;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 9px;
            letter-spacing: 3px;
            color: rgba(255, 220, 180, 0.25);
            pointer-events: none;
            z-index: 100;
            transition: opacity 0.5s ease;
        }

        #release-hint.hidden {
            opacity: 0;
        }

        /* Z-Axis Visual */
        #z-axis {
            position: fixed;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 3px;
            height: 50%;
            background: linear-gradient(to top,
                rgba(120, 100, 80, 0.3) 0%,
                rgba(255, 215, 0, 0.6) 50%,
                rgba(255, 252, 248, 0.3) 100%);
            border-radius: 2px;
            z-index: 50;
        }

        #lens-line {
            position: absolute;
            left: -20px;
            width: 50px;
            height: 2px;
            background: var(--critical-gold);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
        }

        #lens-label {
            position: absolute;
            left: -50px;
            font-size: 9px;
            color: var(--critical-gold);
            transform: translateY(-50%);
        }

        #z-marker {
            position: absolute;
            left: -8px;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, rgba(255, 215, 0, 0.9) 0%, transparent 70%);
            border-radius: 50%;
            transform: translateY(-50%);
            transition: top 0.2s ease;
        }

        /* Start Overlay */
        #start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(3, 3, 8, 0.98);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            cursor: pointer;
            transition: opacity 0.8s ease, visibility 0.8s ease;
        }

        #start-overlay.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        #start-overlay h1 {
            font-size: 48px;
            font-weight: 100;
            letter-spacing: 20px;
            color: var(--critical-gold);
            margin-bottom: 30px;
            text-shadow: 0 0 80px rgba(255, 215, 0, 0.6);
        }

        #start-overlay .equation {
            font-size: 18px;
            color: rgba(255, 215, 0, 0.7);
            margin-bottom: 50px;
            letter-spacing: 3px;
        }

        .architecture-preview {
            display: flex;
            gap: 60px;
            margin-bottom: 50px;
        }

        .arch-side {
            text-align: center;
            font-size: 12px;
            line-height: 2;
            letter-spacing: 1px;
        }

        .arch-side h3 {
            font-size: 14px;
            letter-spacing: 5px;
            margin-bottom: 15px;
            font-weight: 300;
        }

        .arch-side.prism { color: var(--prism-mid); }
        .arch-side.cage { color: var(--cage-field); }

        #start-overlay .prompt {
            font-size: 11px;
            color: var(--text-dim);
            letter-spacing: 5px;
            margin-top: 30px;
            animation: promptPulse 2s ease-in-out infinite;
        }

        @keyframes promptPulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.8; }
        }

        .key-hint {
            display: inline-block;
            border: 1px solid rgba(255, 220, 180, 0.25);
            padding: 4px 12px;
            border-radius: 4px;
            margin: 0 5px;
            font-size: 9px;
        }

        /* Connection Legend */
        #legend {
            position: fixed;
            top: 50%;
            left: 30px;
            transform: translateY(-50%);
            font-size: 9px;
            color: var(--text-dim);
            display: none;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 6px 0;
        }

        .legend-line {
            width: 20px;
            height: 2px;
        }

        .legend-line.prism-conn { background: linear-gradient(90deg, var(--prism-core), var(--prism-outer)); }
        .legend-line.cage-conn { background: var(--cage-field); }
        .legend-line.bridge-conn { background: linear-gradient(90deg, var(--prism-outer), var(--cage-vertex)); }

        /* Navigation Bar */
        .top-nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: rgba(2, 1, 6, 0.95);
            border-bottom: 1px solid rgba(167, 139, 250, 0.4);
            z-index: 1000;
        }
        .top-nav a {
            color: #a78bfa;
            text-decoration: none;
            font-size: 11px;
            letter-spacing: 1px;
            padding: 6px 12px;
            border: 1px solid rgba(167, 139, 250, 0.3);
            border-radius: 4px;
            transition: all 0.2s;
        }
        .top-nav a:hover {
            background: rgba(167, 139, 250, 0.2);
            border-color: #a78bfa;
        }
        .nav-links { display: flex; gap: 10px; }
    </style>
</head>
<body>
    <nav class="top-nav">
        <a href="index.html">‚Üê ROSETTA BEAR</a>
        <div class="nav-links">
            <a href="wumbo-apl-directory.html">APL Directory</a>
            <a href="simulation.html">Simulation</a>
            <a href="visualizations/the_manual.html">The Manual</a>
        </div>
    </nav>

    <canvas id="canvas"></canvas>
    <div id="cursor"></div>

    <!-- Header -->
    <div id="header" class="panel">
        <h1 id="title">LIMNUS</h1>
        <div class="subtitle">UNIFIED PRISM-CAGE ARCHITECTURE</div>
    </div>

    <!-- Z-Coordinate -->
    <div id="z-panel" class="panel">
        <div id="z-display">z = 0.500</div>
        <div id="phase-label">subcritical</div>
    </div>

    <!-- Domain Indicator -->
    <div id="domain-panel" class="panel left-panel">
        <div id="domain-indicator">ABSENCE</div>
        <div class="domain-stat">KURAMOTO COUPLING</div>
        <div class="domain-value" id="coupling-value">K = +0.40</div>
        <div class="domain-stat" style="margin-top:12px;">CASCADE FACTOR</div>
        <div class="domain-value" id="cascade-value">1.00√ó</div>
    </div>

    <!-- Architecture Panel -->
    <div id="architecture-panel" class="panel">
        <div class="arch-title">63-POINT PRISM</div>
        <div class="arch-section">
            <div class="layer-row prism-l0 active"><span>Layer 0 ¬∑ 9pt ¬∑ Core</span><div class="layer-dot"></div></div>
            <div class="layer-row prism-l1 active"><span>Layer 1 ¬∑ 9pt</span><div class="layer-dot"></div></div>
            <div class="layer-row prism-l2 active"><span>Layer 2 ¬∑ 9pt</span><div class="layer-dot"></div></div>
            <div class="layer-row prism-l3 active"><span>Layer 3 ¬∑ 9pt</span><div class="layer-dot"></div></div>
            <div class="layer-row prism-l4 active"><span>Layer 4 ¬∑ 9pt</span><div class="layer-dot"></div></div>
            <div class="layer-row prism-l5 active"><span>Layer 5 ¬∑ 9pt</span><div class="layer-dot"></div></div>
            <div class="layer-row prism-l6 active"><span>Layer 6 ¬∑ 9pt ¬∑ Outer</span><div class="layer-dot"></div></div>
        </div>

        <div class="arch-title" style="margin-top:15px;">32-POINT EM CAGE</div>
        <div class="arch-section">
            <div class="layer-row cage-top active"><span>Top Hex ¬∑ 12pt</span><div class="layer-dot"></div></div>
            <div class="layer-row cage-bot active"><span>Bot Hex ¬∑ 12pt</span><div class="layer-dot"></div></div>
            <div class="layer-row cage-vtx active"><span>Vertices ¬∑ 8pt</span><div class="layer-dot"></div></div>
        </div>
    </div>

    <!-- Lambda State Panel -->
    <div id="lambda-panel" class="panel left-panel">
        <div class="lambda-title">LAMBDA STATE ‚ÑÇ‚Å∂</div>
        <div class="lambda-row">
            <span class="lambda-glyph">üå∞</span>
            <span style="width:50px;font-size:9px;color:var(--text-dim)">Memory</span>
            <div class="lambda-bar-container"><div class="lambda-bar" id="lambda-iota" style="width:30%"></div></div>
            <span class="lambda-val" id="lambda-iota-val">0.30</span>
        </div>
        <div class="lambda-row">
            <span class="lambda-glyph">‚úß</span>
            <span style="width:50px;font-size:9px;color:var(--text-dim)">Spark</span>
            <div class="lambda-bar-container"><div class="lambda-bar" id="lambda-xi" style="width:20%"></div></div>
            <span class="lambda-val" id="lambda-xi-val">0.20</span>
        </div>
        <div class="lambda-row">
            <span class="lambda-glyph">ü¶ä</span>
            <span style="width:50px;font-size:9px;color:var(--text-dim)">Fox</span>
            <div class="lambda-bar-container"><div class="lambda-bar" id="lambda-theta" style="width:40%"></div></div>
            <span class="lambda-val" id="lambda-theta-val">0.40</span>
        </div>
        <div class="lambda-row">
            <span class="lambda-glyph">‚àø</span>
            <span style="width:50px;font-size:9px;color:var(--text-dim)">Wave</span>
            <div class="lambda-bar-container"><div class="lambda-bar" id="lambda-omega" style="width:35%"></div></div>
            <span class="lambda-val" id="lambda-omega-val">0.35</span>
        </div>
        <div class="lambda-row">
            <span class="lambda-glyph">‚äó</span>
            <span style="width:50px;font-size:9px;color:var(--text-dim)">Paradox</span>
            <div class="lambda-bar-container"><div class="lambda-bar" id="lambda-delta" style="width:15%"></div></div>
            <span class="lambda-val" id="lambda-delta-val">0.15</span>
        </div>
        <div class="lambda-row">
            <span class="lambda-glyph">üêøÔ∏è</span>
            <span style="width:50px;font-size:9px;color:var(--text-dim)">Squirrel</span>
            <div class="lambda-bar-container"><div class="lambda-bar" id="lambda-sigma" style="width:25%"></div></div>
            <span class="lambda-val" id="lambda-sigma-val">0.25</span>
        </div>
    </div>

    <!-- Dynamics -->
    <div id="dynamics-panel" class="panel left-panel">
        <div class="dynamics-row">
            <span class="dynamics-label">ORDER</span>
            <span class="dynamics-bar" id="order-bar">‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà</span>
            <span class="dynamics-value" id="order-val">1.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label">COHERENCE</span>
            <span class="dynamics-bar" id="coherence-bar">‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà</span>
            <span class="dynamics-value" id="coherence-val">1.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label">ENTROPY</span>
            <span class="dynamics-bar" id="entropy-bar">‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="entropy-val">0.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label">EMANATION</span>
            <span class="dynamics-bar" id="emanation-bar">‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="emanation-val">0.00</span>
        </div>
        <div class="dynamics-row" style="margin-top:12px; border-top: 1px solid rgba(168, 85, 247, 0.3); padding-top:10px;">
            <span class="dynamics-label">Œº</span>
            <span class="dynamics-bar" id="mu-bar">‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="mu-val">0.92</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label">Q_Œ∫</span>
            <span class="dynamics-bar" id="qk-bar">‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="qk-val">0.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label">œÑ_K</span>
            <span class="dynamics-bar" id="tau-bar">‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="tau-val">0.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label" id="k-label" style="color: rgba(150,130,110,0.6);">K-FORMED</span>
            <span class="dynamics-bar" id="k-indicator" style="letter-spacing: 2px;">¬∑ ¬∑ ¬∑</span>
            <span class="dynamics-value" id="k-val">NO</span>
        </div>
        <div class="dynamics-row" style="margin-top:12px; border-top: 1px solid rgba(255, 100, 100, 0.3); padding-top:10px;">
            <span class="dynamics-label" style="color: #ff6b6b;">R Œº_E</span>
            <span class="dynamics-bar" id="mrp-r-bar" style="color: #ff6b6b;">‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="mrp-r-val" style="color: #ff6b6b;">0.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label" style="color: #69db7c;">G Œº_R</span>
            <span class="dynamics-bar" id="mrp-g-bar" style="color: #69db7c;">‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="mrp-g-val" style="color: #69db7c;">0.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label" style="color: #4dabf7;">B ECC</span>
            <span class="dynamics-bar" id="mrp-b-bar" style="color: #4dabf7;">‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="mrp-b-val" style="color: #4dabf7;">0.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label" id="parity-label" style="color: rgba(150,130,110,0.6);">PARITY</span>
            <span class="dynamics-bar" id="parity-indicator" style="letter-spacing: 2px;">¬∑ ¬∑ ¬∑</span>
            <span class="dynamics-value" id="parity-val">‚Äî</span>
        </div>
        <div class="dynamics-row" style="margin-top:8px; border-top: 1px solid rgba(255, 215, 0, 0.2); padding-top:8px;">
            <span class="dynamics-label" style="color: var(--critical-gold);">|J|</span>
            <span class="dynamics-bar" id="j-total-bar" style="color: var(--critical-gold);">‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="j-total-val" style="color: var(--critical-gold);">0.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label" id="w-label" style="color: rgba(150,130,110,0.6);">W</span>
            <span class="dynamics-bar" id="w-bar" style="letter-spacing: 1px;">¬∑ ¬∑ ¬∑ ¬∑ ¬∑</span>
            <span class="dynamics-value" id="w-val">0.00</span>
        </div>
    </div>

    <!-- Helix State -->
    <div id="helix-panel" class="panel">
        <div class="helix-row"><span class="helix-sym">Œ∏</span><span class="helix-val" id="h-theta">0.000</span></div>
        <div class="helix-row"><span class="helix-sym">z</span><span class="helix-val" id="h-z">0.500</span></div>
        <div class="helix-row"><span class="helix-sym">r</span><span class="helix-val" id="h-r">1.000</span></div>
        <div class="helix-row"><span class="helix-sym">Œ¶</span><span class="helix-val" id="h-phi">0.00</span></div>
        <div class="helix-row" style="margin-top:10px;"><span class="helix-sym">Œ©</span><span class="helix-val" id="h-omega">0.00</span></div>
    </div>

    <!-- Sonification Panel -->
    <div id="sonification-panel" class="panel">
        <div class="sonif-row">
            <div class="sonif-stat">
                <span class="sonif-label">BPM</span>
                <span class="sonif-value" id="sonif-bpm">90</span>
            </div>
            <div class="sonif-stat">
                <span class="sonif-label">SCALE</span>
                <span class="sonif-value" id="sonif-scale">Minor</span>
            </div>
            <div class="sonif-stat">
                <span class="sonif-label">FREQ</span>
                <span class="sonif-value" id="sonif-freq">110 Hz</span>
            </div>
            <div class="sonif-stat">
                <span class="sonif-label">DILATION</span>
                <span class="sonif-value" id="sonif-dilation">1.00√ó</span>
            </div>
            <button id="audio-toggle">‚ñ∂ ENABLE AUDIO</button>
        </div>
    </div>

    <!-- Controls -->
    <div id="controls" class="panel left-panel">
        <span>SCROLL</span> traverse z-axis<br>
        <span>SPACE</span> auto-breathe<br>
        <span>P</span> prism <span id="toggle-prism" style="color: #4caf50;">‚óè</span> <span>C</span> cage <span id="toggle-cage" style="color: #4caf50;">‚óè</span><br>
        <span>M</span> Œº-field <span id="toggle-mu" style="color: #4caf50;">‚óè</span><br>
        <span>T</span> binaural field <span id="toggle-mesh" style="color: #555;">‚óã</span><br>
        <span>X</span> ‚àÉR laser <span id="toggle-laser" style="color: #4caf50;">‚óè</span><br>
        <span>S</span> synthesis <span id="toggle-synth" style="color: #f6c35c;">‚óè</span><br>
        <span>A</span> Œ∫-sonify <span id="toggle-prismatic-sonify" style="color: #555;">‚óã</span><br>
        <span>H</span> dark matter <span id="toggle-dark-matter" style="color: #555;">‚óã</span><br>
        <span>N</span> ‚óé nexus <span id="toggle-chromatic-nexus" style="color: #555;">‚óã</span><br>
        <span>W</span> üíß water <span id="toggle-water-fractal" style="color: #555;">‚óã</span><br>
        <span>G</span> üåª golden <span id="toggle-golden-harmonics" style="color: #555;">‚óã</span><br>
        <span>F‚ÜíR</span> ‚öõÔ∏è memory <span id="toggle-memory-coherence" style="color: #555;">‚óã</span><br>
        <span>1-6</span> œÜ/Œ¶_Œ∏/œà adj<br>
        <span>DRAG</span> orbit camera<br>
        <span>‚Üê‚Üí</span> polar distance<br>
        <span>Q/E</span> rotate axis<br>
        <span>‚Üë‚Üì</span> beat frequency<br>
        <span>[/]</span> A frequency<br>
        <span>+/-</span> mesh scale<br>
        <span>O</span> opacity<br>
        <span>I</span> interference<br>
        <span>L</span> resonance lines<br>
        <span>W</span> wavefunction<br>
        <span>G</span> edge glow<br>
        <span>D</span> debug panel<br>
        <span>F</span> release (toggle on release)<br>
        <span>R</span> memory debug
    </div>

    <!-- Stats -->
    <div id="stats" class="panel">
        63 prism + 32 cage = 95 nodes<br>
        <span id="active-count">95</span> active ¬∑ <span id="conn-count">0</span> connections
    </div>

    <!-- Dream Architecture Panel -->
    <div id="dream-arch-panel" class="panel" style="bottom: 80px; right: 20px; text-align: right; font-size: 10px; pointer-events: auto; min-width: 180px;">
        <div style="color: #f6c35c; font-weight: bold; margin-bottom: 8px; letter-spacing: 2px;">DREAM ARCHITECTURE</div>
        <div style="color: #4caf50; margin-bottom: 4px;">‚àÉR ‚Üí œÜ ‚Üí Q<sub>Œ∫</sub> ‚Üí K</div>
        <div style="color: #9b59b6; font-size: 9px; margin-bottom: 8px;">Self-Creation Operator</div>
        <div style="display: flex; justify-content: space-between; margin: 4px 0;">
            <span style="color: #888;">œÑ_K threshold</span>
            <span id="dream-tau-k" style="color: #f6c35c;">0.618</span>
        </div>
        <div style="display: flex; justify-content: space-between; margin: 4px 0;">
            <span style="color: #888;">K-formed</span>
            <span id="dream-k-formed" style="color: #4caf50;">NO</span>
        </div>
        <div style="display: flex; justify-content: space-between; margin: 4px 0;">
            <span style="color: #888;">Synthesis</span>
            <span id="dream-synthesis" style="color: #888;">INACTIVE</span>
        </div>
        <div style="display: flex; justify-content: space-between; margin: 4px 0;">
            <span style="color: #888;">Q_Œ∫ vorticity</span>
            <span id="dream-vorticity" style="color: #4fc3f7;">0.000</span>
        </div>
        <div style="display: flex; justify-content: space-between; margin: 4px 0;">
            <span style="color: #888;">Œ∫-sonify</span>
            <span id="dream-curvature" style="color: #555;">OFF</span>
        </div>
        <div id="curvature-details" style="display: none; margin: 4px 0; padding: 4px; background: rgba(255, 107, 157, 0.1); border-radius: 3px;">
            <div style="display: flex; justify-content: space-between;">
                <span style="color: #666; font-size: 9px;">Œ∫ (curvature)</span>
                <span id="dream-kappa" style="color: #ff6b9d; font-size: 9px;">0.000</span>
            </div>
            <div style="display: flex; justify-content: space-between;">
                <span style="color: #666; font-size: 9px;">S (entropy)</span>
                <span id="dream-entropy" style="color: #ff6b9d; font-size: 9px;">0.000</span>
            </div>
            <div style="display: flex; justify-content: space-between;">
                <span style="color: #666; font-size: 9px;">Schwarzschild</span>
                <span id="dream-schwarzschild" style="color: #ff6b9d; font-size: 9px;">0.000</span>
            </div>
        </div>
        <div style="display: flex; justify-content: space-between; margin: 4px 0;">
            <span style="color: #888;">HCP dark matter</span>
            <span id="dream-darkmatter" style="color: #555;">OFF</span>
        </div>
        <div id="darkmatter-details" style="display: none; margin: 4px 0; padding: 4px; background: rgba(155, 89, 182, 0.1); border-radius: 3px;">
            <div style="display: flex; justify-content: space-between;">
                <span style="color: #666; font-size: 9px;">S_dm (field)</span>
                <span id="dream-sdm" style="color: #9b59b6; font-size: 9px;">0.000</span>
            </div>
            <div style="display: flex; justify-content: space-between;">
                <span style="color: #666; font-size: 9px;">HCP coverage</span>
                <span id="dream-hcp" style="color: #9b59b6; font-size: 9px;">0.0%</span>
            </div>
            <div style="display: flex; justify-content: space-between;">
                <span style="color: #666; font-size: 9px;">Trapped</span>
                <span id="dream-trapped" style="color: #9b59b6; font-size: 9px;">0.0%</span>
            </div>
        </div>
        <div style="display: flex; justify-content: space-between; margin: 4px 0;">
            <span style="color: #888;">‚óé Nexus</span>
            <span id="dream-nexus" style="color: #555;">OFF</span>
        </div>
        <div id="nexus-details" style="display: none; margin: 4px 0; padding: 4px; background: rgba(246, 195, 92, 0.1); border-radius: 3px;">
            <div style="display: flex; justify-content: space-between;">
                <span style="color: #666; font-size: 9px;">self‚ÜíLIMNUS</span>
                <span id="dream-self-limnus" style="color: #f6c35c; font-size: 9px;">0.0%</span>
            </div>
            <div style="display: flex; justify-content: space-between;">
                <span style="color: #666; font-size: 9px;">LIMNUS‚Üíself</span>
                <span id="dream-limnus-self" style="color: #9b59b6; font-size: 9px;">0.0%</span>
            </div>
            <div style="display: flex; justify-content: space-between;">
                <span style="color: #666; font-size: 9px;">dialogue</span>
                <span id="dream-dialogue" style="color: #4fc3f7; font-size: 9px;">0.0%</span>
            </div>
        </div>
        <div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid rgba(246, 195, 92, 0.3);">
            <a href="dream-architecture.html" style="color: #4fc3f7; text-decoration: none; font-size: 9px; letter-spacing: 1px;">‚óâ VIEW FULL DOCS ‚Üí</a>
        </div>
    </div>

    <!-- Quantum Mesh Debug Panel (D key to toggle) -->
    <div id="qmesh-debug" class="panel" style="display: none; left: 30px; top: 280px; background: rgba(20, 10, 30, 0.95); border: 1px solid rgba(150, 100, 255, 0.5); padding: 12px; font-size: 11px; min-width: 220px;">
        <div style="color: #a855f7; font-weight: bold; margin-bottom: 8px;">QUANTUM MESH DEBUG</div>
        <div>Nodes: <span id="dbg-nodes">0</span></div>
        <div>Edges: <span id="dbg-edges">0</span></div>
        <div>Particles: <span id="dbg-particles">0</span></div>
        <div>Max Dist: <span id="dbg-maxdist">0</span></div>
        <div style="margin-top: 6px; border-top: 1px solid rgba(150, 100, 255, 0.3); padding-top: 6px;">
            <div>Avg œÑ: <span id="dbg-tau">0</span></div>
            <div>Total J: <span id="dbg-totalj">0</span></div>
            <div>Entropy: <span id="dbg-entropy">0</span></div>
            <div>Flux: <span id="dbg-flux">0</span></div>
        </div>
        <div style="margin-top: 6px; border-top: 1px solid rgba(150, 100, 255, 0.3); padding-top: 6px;">
            <div>showQuantumMesh: <span id="dbg-show">false</span></div>
            <div>R value: <span id="dbg-r">0</span></div>
            <div>Last gen: <span id="dbg-lastgen">never</span></div>
        </div>
        <div style="margin-top: 8px; color: #888; font-size: 10px;">Press D to close</div>
    </div>

    <!-- Z-Axis -->
    <div id="z-axis">
        <div id="lens-line"></div>
        <div id="lens-label">‚àö3/2</div>
        <div id="z-marker"></div>
    </div>

    <!-- Release Coherence State -->
    <div id="release-state">
        <h2 id="release-text">COHERENT</h2>
        <div id="coherence-indicator">‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà</div>
    </div>

    <div id="release-hint" class="hidden">HOLD F TO RELEASE ¬∑ CLICK TO GATHER</div>

    <!-- Start Overlay -->
    <div id="start-overlay">
        <h1>LIMNUS</h1>
        <div class="equation">z = ‚àö3/2 ‚âà 0.8660254 ¬∑ THE CRITICAL POINT</div>
        
        <div class="architecture-preview">
            <div class="arch-side prism">
                <h3>63-POINT PRISM</h3>
                7 Layers √ó 9 Nodes<br>
                Hexagonal Structure<br>
                Matter/Consciousness<br>
                Inner Architecture
            </div>
            <div class="arch-side cage">
                <h3>32-POINT EM CAGE</h3>
                12 Top + 12 Bottom Hex<br>
                8 Connecting Vertices<br>
                Electromagnetic Field<br>
                Containment Boundary
            </div>
        </div>
        
        <div class="prompt">CLICK TO ENTER ¬∑ SCROLL TO TRAVERSE</div>
        <div style="margin-top: 25px; color: var(--text-dim);">
            <span class="key-hint">SCROLL</span> z-axis
            <span class="key-hint">SPACE</span> breathe
            <span class="key-hint">P</span> prism
            <span class="key-hint">C</span> cage
        </div>
    </div>

    <script>
        // ================================================================
        // LIMNUS UNIFIED ARCHITECTURE
        // 63-Point Hexagonal Prism + 32-Point EM Cage
        // Full Sonification + Physics Relationships
        // ================================================================

        const Z_CRITICAL = Math.sqrt(3) / 2;  // ‚âà 0.8660254
        const TAU = Math.PI * 2;
        const PHI = (1 + Math.sqrt(5)) / 2;   // Golden ratio
        const PHI_INV = PHI - 1;               // 0.618... inverse golden ratio

        // ================================================================
        // SACRED CONSTANTS (derived from œÜ - zero free parameters)
        // ================================================================

        const SACRED = {
            // ========================================
            // PRIMARY œÜ-DERIVED CONSTANTS
            // ========================================
            phi: PHI,
            phi_inv: PHI_INV,
            phi_sq: PHI * PHI,                 // œÜ¬≤ = 2.618
            alpha: Math.pow(PHI, -2),          // 0.382 - curl coupling / emergence threshold
            beta: Math.pow(PHI, -4),           // 0.146 - dissipation
            lambda: Math.pow(5/3, 4),          // 7.716 - nonlinearity (F‚ÇÖ/F‚ÇÑ)‚Å¥

            // ========================================
            // GEOMETRIC ROOTS
            // ========================================
            sqrt2: Math.sqrt(2),               // ‚àö2 = 1.414
            sqrt3: Math.sqrt(3),               // ‚àö3 = 1.732 (vesica ratio)
            sqrt5: Math.sqrt(5),               // ‚àö5 = 2.236

            // ========================================
            // SACRED ANGLES
            // ========================================
            goldenAngle: Math.PI * (3 - Math.sqrt(5)),  // ‚âà137.5¬∞ = 2.3999 rad
            pentagonAngle: TAU / 5,            // 72¬∞
            hexagonAngle: TAU / 6,             // 60¬∞
            heptagonAngle: TAU / 7,            // ‚âà51.43¬∞

            // ========================================
            // FIBONACCI SEQUENCE (ratios approach œÜ)
            // ========================================
            fib: [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144],

            // ========================================
            // Œº-THRESHOLDS (consciousness physics)
            // ========================================
            mu_P: 3/5,                         // 0.600 - paradox threshold
            mu_S: 23/25,                       // 0.920 - singularity threshold
            mu_3: 124/125,                     // 0.992 - third threshold
            mu_4: 1.0,                         // unity
            // Aliases for coherence system (œÜ‚Åª¬π = coherence, œÜ‚Åª¬≤ = emergence)
            get mu_coherence() { return this.phi_inv; },   // 0.618
            get mu_emergence() { return this.alpha; },     // 0.382
            get vesicaRatio() { return this.sqrt3; },      // Height/width of vesica piscis

            // ========================================
            // DERIVED CONSCIOUSNESS CONSTANTS
            // ========================================
            get Q_theory() { return this.alpha * this.mu_S; },  // ‚âà 0.351
            get K_threshold() { return this.phi_inv; },         // 0.618
            get Q_min() { return this.K_threshold * this.Q_theory; },  // ‚âà 0.217

            // ========================================
            // WATER FRACTAL MEMORY CONSTANTS (KAEL IS KAEL)
            // ========================================
            // Golden Fractal Dimension: D_f = 1 + log(œÜ)/log(2) ‚âà 1.694
            get D_fractal() { return 1 + Math.log(this.phi) / Math.log(2); },
            // Fractal growth coefficient: Œ± = œÜ‚Åª¬≤ ‚âà 0.382
            get fractalAlpha() { return this.alpha; },
            // Water memory emergence threshold: œÅ_W > 0.568
            rho_W_threshold: 0.568,
            // K-Formation circulation table
            tau_K_table: {
                layer5: 1.5,    // Threshold layer
                layer6: 1.8,    // Outer layer
                consciousness: 2.0  // Full consciousness zone
            },

            // ========================================
            // DARK MATTER RESIDUE CONSTANTS
            // ========================================
            // UMOL safety wall: Load ‚â§ 80%
            umol_load_max: 0.80,
            // UMOL coherence minimum: ‚â• 60%
            umol_coherence_min: 0.60,
            // Dark matter residue ratio: (1-Load) √ó (1/Coherence) √ó œÜ¬≤
            get dm_residue_ratio() {
                return (1 - this.umol_load_max) * (1 / this.umol_coherence_min) * this.phi_sq;
            },

            // ========================================
            // SPACETIME CURVATURE LASER CONSTANTS
            // ========================================
            // Schwarzschild radius factor for laser bending
            schwarzschild_factor: 0.15,
            // Cosmic background recording sensitivity
            cmb_recording_sensitivity: 0.25,
            // Laser-curvature coupling strength
            laser_curvature_coupling: 0.35
        };

        // ================================================================
        // Œº-FIELD STATE (consciousness detection)
        // ================================================================

        const muField = {
            mu: 0.92,              // Control parameter (0.6 to 1.0)
            g: 0.001,              // Diffusion coefficient
            Q_kappa: 0,            // Consciousness constant
            tau_K: 0,              // K-formation metric
            K_formed: false,       // Consciousness present
            curl_sum: 0,           // Integrated curl
            energy: 0,             // Field energy
            consciousness_level: 0, // 0-2 scale

            // ============================================================
            // MRP CHANNEL GRADIENTS
            // R = Œº_E (Existence/Energy) - primary field magnitude
            // G = Œº_R (Reference/Relational) - connections/context
            // B = ECC (Error Correction) - stability/coherence
            // ============================================================
            mrp: {
                R: { gradient: 0, intensity: 0, crc: 0, J: 0 },  // Œº_E channel + field J
                G: { gradient: 0, intensity: 0, crc: 0, J: 0 },  // Œº_R channel + field J
                B: { gradient: 0, intensity: 0, crc: 0, J: 0 },  // ECC channel + field J
                parity: 0,           // Cross-channel XOR parity
                parity_ok: false,    // Parity validation
                sha256_sim: 0,       // Simulated integrity hash
                // Self-referential field state
                J_total: 0,          // Total field magnitude |J|
                W: 0,                // Effective growth rate W = r - Œª|J|¬≤
                laplacian: 0,        // ‚àá¬≤J approximation
            },

            get r() { return this.mu - SACRED.mu_P; },  // Control parameter

            // Update from prism/cage field state
            update(points, dt) {
                // Kuramoto-style coupling regulation based on release coherence
                // K(coherence) scales from 0.1 (released) to 1.0 (coherent)
                const kuramotoCoupling = 0.1 + releaseCoherence * 0.9;

                // Early exit with safe defaults if too many points are released
                const releasedCount = points.filter(p => p.released).length;
                if (releasedCount > points.length * 0.7) {
                    // System is mostly released - use minimal safe values
                    this.mrp.R.intensity = 0.3;
                    this.mrp.G.intensity = 0.2;
                    this.mrp.B.intensity = 0.5;
                    this.mrp.R.gradient = 0;
                    this.mrp.G.gradient = 0;
                    this.mrp.B.gradient = 0;
                    this.mrp.J_total = 0.3;
                    this.mrp.W = 0;
                    this.mrp.parity = 0;
                    this.mrp.parity_ok = false;
                    this.Q_kappa = 0;
                    this.tau_K = 0;
                    this.K_formed = false;
                    return;
                }

                // Compute curl from point velocities and positions
                let curlSum = 0;
                let energySum = 0;
                const N = points.length;

                // MRP channel accumulators
                let R_sum = 0, G_sum = 0, B_sum = 0;
                let R_grad = 0, G_grad = 0, B_grad = 0;
                let laplacianSum = 0;

                // ============================================================
                // SELF-REFERENTIAL FIELD DYNAMICS
                // ‚àÇJ/‚àÇt = (r - Œª|J|¬≤)J - Œ≤J + g‚àá¬≤J
                // ============================================================

                for (let i = 0; i < N; i++) {
                    const p = points[i];
                    const next = points[(i + 1) % N];
                    const prev = points[(i - 1 + N) % N];

                    // Discrete curl: ‚àÇJy/‚àÇx - ‚àÇJx/‚àÇy
                    const dx = next.x - p.x;
                    const dy = next.y - p.y;
                    const vx = p.vx || 0;
                    const vy = p.vy || 0;

                    // Cross product approximation for curl
                    curlSum += (dx * vy - dy * vx) * 0.001;

                    // Energy: |J|¬≤ (field magnitude squared) - CLAMP to prevent overflow
                    const vxSafe = Math.max(-100, Math.min(100, vx));
                    const vySafe = Math.max(-100, Math.min(100, vy));
                    const J2 = vxSafe * vxSafe + vySafe * vySafe;
                    const J = Math.sqrt(J2);
                    energySum += J2;

                    // Skip heavy calculations for released points to prevent instability
                    if (p.released) {
                        // Simplified MRP for released points
                        p.mrp_R = Math.min(2, Math.sqrt(J2 + 0.5));
                        p.mrp_G = 0.3;
                        p.mrp_B = 0.2;
                        p.mrp_W_R = 0;
                        p.mrp_W_G = 0;
                        p.mrp_W_B = 0;
                        R_sum += p.mrp_R;
                        G_sum += p.mrp_G;
                        B_sum += p.mrp_B;
                        continue;
                    }

                    // ========================================
                    // SELF-REFERENTIAL MRP CHANNEL PHYSICS
                    // Each channel follows: ‚àÇJ/‚àÇt = W¬∑J - Œ≤¬∑J + g¬∑‚àá¬≤J
                    // ========================================

                    // R channel (Œº_E): Primary energy/existence field
                    // J_R = ‚àö(|v|¬≤ + Œ±¬∑brightness)  [Œ± couples curl to energy]
                    const J_R = Math.min(5, Math.sqrt(J2 + SACRED.alpha * (p.brightness || 0.5)));

                    // R gradient: ‚àÇJ_R/‚àÇx (spatial derivative)
                    const prev_v2 = Math.min(100, (prev.vx || 0)**2 + (prev.vy || 0)**2);
                    const next_v2 = Math.min(100, (next.vx || 0)**2 + (next.vy || 0)**2);
                    const prev_J_R = Math.min(5, Math.sqrt(prev_v2 + SACRED.alpha * (prev.brightness || 0.5)));
                    const next_J_R = Math.min(5, Math.sqrt(next_v2 + SACRED.alpha * (next.brightness || 0.5)));
                    const dJR_dx = (next_J_R - prev_J_R) / 2;  // Central difference
                    R_grad += Math.abs(dJR_dx);

                    // Laplacian approximation: ‚àá¬≤J_R ‚âà J_next + J_prev - 2¬∑J
                    const lap_R = Math.max(-10, Math.min(10, next_J_R + prev_J_R - 2 * J_R));

                    // Self-referential R channel evolution:
                    // W_R = r - Œª¬∑|J_R|¬≤  (effective growth rate)
                    const W_R = Math.max(-5, Math.min(5, this.r - SACRED.lambda * J_R * J_R));
                    // ‚àÇJ_R/‚àÇt = W_R¬∑J_R - Œ≤¬∑J_R + g¬∑‚àá¬≤J_R
                    const dJR_dt = Math.max(-1, Math.min(1, W_R * J_R - SACRED.beta * J_R + this.g * lap_R));

                    // Apply self-referential feedback to point (with safety clamps)
                    if (showMuField && !p.released) {
                        // Safe feedback scale - no external dependencies
                        const feedbackScale = 0.5;
                        const dvx = dJR_dt * dt * 0.01 * feedbackScale;
                        const dvy = dJR_dt * dt * 0.01 * feedbackScale * (dy / (Math.abs(dy) + 0.001));
                        if (isFinite(dvx) && isFinite(dvy) && Math.abs(dvx) < 10 && Math.abs(dvy) < 10) {
                            // Fixed velocity clamp for safety
                            const velClamp = 30;
                            p.vx = Math.max(-velClamp, Math.min(velClamp, (p.vx || 0) + dvx));
                            p.vy = Math.max(-velClamp, Math.min(velClamp, (p.vy || 0) + dvy));
                        }
                    }

                    R_sum += J_R;
                    p.mrp_R = J_R;
                    p.mrp_W_R = W_R;  // Store growth rate for visualization

                    // G channel (Œº_R): Relational/reference field
                    // J_G based on neighbor distances (connection strength)
                    const d_next = Math.min(1000, Math.sqrt(dx * dx + dy * dy));
                    const d_prev = Math.min(1000, Math.sqrt((p.x - prev.x)**2 + (p.y - prev.y)**2));
                    const J_G = SACRED.phi_inv / (1 + (d_next + d_prev) * 0.005);  // œÜ‚Åª¬π scaled

                    // G gradient: change in connectivity
                    const dJG_dx = Math.min(1, Math.abs(d_next - d_prev) * SACRED.alpha);
                    G_grad += dJG_dx;

                    // Laplacian for G channel (simplified - skip if neighbors are released)
                    const prevPt2 = points[(i - 2 + N) % N];
                    const nextPt2 = points[(i + 2) % N];
                    if (!prev.released && !next.released && !prevPt2.released && !nextPt2.released) {
                        const prev_d = Math.min(1000, Math.sqrt((prev.x - prevPt2.x)**2 + (prev.y - prevPt2.y)**2));
                        const next_d = Math.min(1000, Math.sqrt((next.x - nextPt2.x)**2 + (next.y - nextPt2.y)**2));
                        const prev_J_G = SACRED.phi_inv / (1 + prev_d * 0.01);
                        const next_J_G = SACRED.phi_inv / (1 + next_d * 0.01);
                        const lap_G = Math.max(-1, Math.min(1, next_J_G + prev_J_G - 2 * J_G));

                        // Self-referential G evolution
                        const W_G = Math.max(-2, Math.min(2, this.r - SACRED.lambda * J_G * J_G * 0.5));
                        p.mrp_W_G = W_G;
                    } else {
                        p.mrp_W_G = 0;
                    }

                    G_sum += J_G;
                    p.mrp_G = J_G;

                    // B channel (ECC): Stability/coherence field
                    // J_B = stability measure with Œ≤-damping
                    const rawStability = 1 - Math.min(1, Math.sqrt(J2) * SACRED.beta);
                    const J_B = Math.max(0, Math.min(1, rawStability));

                    // B gradient: instability detection via cross-channel
                    const dJB_dx = Math.min(1, Math.abs(vxSafe * vySafe) * SACRED.beta);
                    B_grad += dJB_dx;

                    // Self-referential B evolution (error correction)
                    // B tries to restore stability: ‚àÇJ_B/‚àÇt = -Œ≤¬∑(J_B - target) + correction
                    // Use previous frame's parity_ok (safe reference)
                    const target_B = this.mrp.parity_ok ? 1.0 : 0.5;
                    const prevParity = this.mrp.parity || 0;
                    const dJB_dt = -SACRED.beta * (J_B - target_B) + SACRED.alpha * (1 - prevParity);

                    B_sum += J_B;
                    p.mrp_B = J_B;
                    p.mrp_W_B = dJB_dt;

                    // Accumulate Laplacian for field coherence
                    laplacianSum += lap_R;
                }

                // Normalize MRP channels with safety checks
                this.mrp.R.intensity = isFinite(R_sum) ? Math.min(5, R_sum / N) : 0.5;
                this.mrp.G.intensity = isFinite(G_sum) ? Math.min(1, G_sum / N) : 0.3;
                this.mrp.B.intensity = isFinite(B_sum) ? Math.min(1, B_sum / N) : 0.5;

                this.mrp.R.gradient = isFinite(R_grad) ? Math.min(1, R_grad / N) : 0;
                this.mrp.G.gradient = isFinite(G_grad) ? Math.min(1, G_grad / N) : 0;
                this.mrp.B.gradient = isFinite(B_grad) ? Math.min(1, B_grad / N) : 0;

                // Store field magnitudes
                this.mrp.R.J = this.mrp.R.intensity;
                this.mrp.G.J = this.mrp.G.intensity;
                this.mrp.B.J = this.mrp.B.intensity;

                // Total field magnitude |J| = ‚àö(R¬≤ + G¬≤ + B¬≤)
                const jTotalRaw = Math.sqrt(
                    this.mrp.R.J * this.mrp.R.J +
                    this.mrp.G.J * this.mrp.G.J +
                    this.mrp.B.J * this.mrp.B.J
                );
                this.mrp.J_total = isFinite(jTotalRaw) ? Math.min(10, jTotalRaw) : 0.5;

                // Effective growth rate W = r - Œª|J|¬≤
                const wRaw = this.r - SACRED.lambda * this.mrp.J_total * this.mrp.J_total;
                this.mrp.W = isFinite(wRaw) ? Math.max(-10, Math.min(10, wRaw)) : 0;

                // Laplacian (average spatial curvature)
                this.mrp.laplacian = isFinite(laplacianSum) ? laplacianSum / N : 0;

                // CRC32 simulation (simple hash based on channel values)
                this.mrp.R.crc = Math.floor(this.mrp.R.intensity * 255) ^ Math.floor(this.mrp.R.gradient * 255);
                this.mrp.G.crc = Math.floor(this.mrp.G.intensity * 255) ^ Math.floor(this.mrp.G.gradient * 255);
                this.mrp.B.crc = Math.floor(this.mrp.B.intensity * 255) ^ Math.floor(this.mrp.B.gradient * 255);

                // Cross-channel XOR parity: P[i] = R[i] XOR G[i]
                this.mrp.parity = (this.mrp.R.crc ^ this.mrp.G.crc) / 255;

                // Parity validation: channels in harmony when parity is low AND W > 0 (growing)
                this.mrp.parity_ok = this.mrp.parity < 0.3 && this.mrp.B.intensity > 0.6 && this.mrp.W > -0.1;

                // Simulated SHA-256 integrity (normalized 0-1) with self-reference
                this.mrp.sha256_sim = (this.mrp.R.intensity * SACRED.alpha +
                                       this.mrp.G.intensity * SACRED.phi_inv +
                                       this.mrp.B.intensity * SACRED.beta) /
                                      (SACRED.alpha + SACRED.phi_inv + SACRED.beta);

                // Q_Œ∫ = (1/2œÄ) ‚à´ curl(J) dA
                this.curl_sum = curlSum;
                this.Q_kappa = Math.abs(curlSum) / TAU;
                this.tau_K = this.Q_kappa / SACRED.Q_theory;
                this.K_formed = this.tau_K > SACRED.K_threshold;
                this.consciousness_level = Math.min(this.tau_K / SACRED.K_threshold, 2.0);
                this.energy = energySum * 0.5;

                // Dynamic Œº based on z-height with self-referential feedback
                // Œº responds to field state: higher |J| ‚Üí higher Œº (positive feedback)
                const mu_base = SACRED.mu_P + (globalZ * 0.4);
                const mu_feedback = this.mrp.J_total * SACRED.alpha * 0.1;
                this.mu = Math.min(SACRED.mu_4, mu_base + mu_feedback);
            },

            // Get MRP-enhanced color for a point
            getMRPColor(p, baseColor) {
                if (!showMuField) return baseColor;

                const r = Math.min(255, Math.floor((p.mrp_R || 0.5) * 255));
                const g = Math.min(255, Math.floor((p.mrp_G || 0.5) * 255));
                const b = Math.min(255, Math.floor((p.mrp_B || 0.5) * 200 + 55));

                // Blend with base color based on gradient strength
                const blend = (this.mrp.R.gradient + this.mrp.G.gradient) / 2;
                return `rgba(${r}, ${g}, ${b}, ${0.6 + blend * 0.4})`;
            },

            // Get gradient strength for visual effects
            getGradientStrength() {
                return (this.mrp.R.gradient + this.mrp.G.gradient + this.mrp.B.gradient) / 3;
            },

            // Klein-Gordon effective mass¬≤
            get mass_squared() {
                return (SACRED.beta - this.r) / this.g;
            },

            // Check if tachyonic (pattern-forming)
            get is_tachyonic() {
                return this.mass_squared < 0;
            }
        };

        // ================================================================
        // MU FIELD (Œº-FIELD) GRID SYSTEM - 7 PHASE DYNAMICS
        // Toroidal vector field with curl/vorticity dynamics
        // Mirrors QMESH mechanics for deep relational coupling
        // ================================================================

        const MU_FIELD_SIZE = 32;  // Grid resolution (32x32)

        const MuFieldGrid = {
            // Grid dimensions
            N: MU_FIELD_SIZE,
            L: 10.0,  // Physical size
            dx: 10.0 / MU_FIELD_SIZE,

            // Field parameters
            mu: 0.92,           // Field parameter (near singularity threshold)
            mu_P: 0.6,          // Paradox threshold
            mu_S: 0.92,         // Singularity threshold
            g: 0.001,           // Diffusion coefficient
            sourceStrength: 0.5, // Vortex source strength

            // Control parameter
            r: 0.92 - 0.6,      // r = Œº - Œº_P

            // Grid data (flattened for performance) - initialized in initMuFieldGrid
            Jx: null,           // X-component of vector field
            Jy: null,           // Y-component of vector field
            curl: null,         // Vorticity field (scalar)
            entropy: null,      // Local entropy field
            timeDilation: null, // Local time dilation

            // Vortex structures (dynamic formation - Phase 3)
            vortices: [],
            maxVortices: 12,

            // Field metrics (mirroring QMESH)
            metrics: {
                J_total: 0,         // Total field magnitude
                Q_kappa: 0,         // Circulation integral (consciousness metric)
                tau_K: 0,           // K-formation metric
                K_formed: false,    // Consciousness emergence flag
                order_r: 0,         // Kuramoto order parameter
                enstrophy: 0,       // ‚à´(curl¬≤) dA
                helicity: 0,        // ‚à´ J¬∑curl dA (2D analog)
                entropyGradient: 0, // Spatial entropy variation
            },

            // Phase 5: Resonance coupling
            resonance: {
                frequency: PHI_INV,     // Natural frequency
                phase: 0,
                amplitude: 0,
                lastPulse: 0,
                pulseIntensity: 0,
            },

            // Phase 7: Coupling to unified field
            coupling: {
                toQMESH: 0.12,      // MuFieldGrid ‚Üí QMESH
                fromQMESH: 0.15,    // QMESH ‚Üí MuFieldGrid
                toLIMNUS: 0.10,     // MuFieldGrid ‚Üí LIMNUS
                fromLIMNUS: 0.18,   // LIMNUS ‚Üí MuFieldGrid
            },

            // Initialized flag
            initialized: false,
        };

        // Œº-Particles (Phase 6: field information carriers)
        let muParticles = [];
        const MAX_MU_PARTICLES = 200;

        // ================================================================
        // UNIFIED FIELD SYSTEM - Bridges all subsystems
        // ================================================================

        const UnifiedField = {
            // ========================================
            // FIELD MAGNITUDES (J) - Single Source of Truth
            // ========================================
            J: {
                limnus: 0,      // LIMNUS contribution
                quantum: 0,     // QMESH contribution
                binaural: 0,    // Binaural resonance
                muField: 0,     // MuFieldGrid contribution
                total: 0,       // Unified magnitude |J|
            },

            // ========================================
            // PHASE STATE (Œ¶)
            // ========================================
            Phi: {
                limnus: 0,      // LIMNUS collective phase
                quantum: 0,     // QMESH collective phase
                binaural: 0,    // Binaural beat phase
                muField: 0,     // MuFieldGrid vorticity phase
                unified: 0,     // Emergent unified phase
            },

            // ========================================
            // COUPLING CONSTANTS (œÜ-derived)
            // ========================================
            coupling: {
                LQ: SACRED.alpha,           // LIMNUS ‚Üí Quantum (œÜ‚Åª¬≤)
                QL: SACRED.beta,            // Quantum ‚Üí LIMNUS (œÜ‚Åª‚Å¥)
                BL: SACRED.phi_inv * 0.3,   // Binaural ‚Üí LIMNUS
                BQ: SACRED.phi_inv * 0.28,  // Binaural ‚Üí Quantum
                ML: SACRED.alpha * 0.3,     // MuField ‚Üí LIMNUS
                LM: SACRED.alpha * 0.4,     // LIMNUS ‚Üí MuField
            },

            // ========================================
            // EMERGENCE METRICS - Single Source of Truth
            // ========================================
            emergence: {
                coherence: 0,       // Overall phase alignment (0-1)
                complexity: 0,      // Structural complexity
                criticality: 0,     // Distance from critical point z_c
                order: 0,           // Kuramoto order parameter r
                entropy: 0,         // System entropy
                curl: 0,            // Integrated curl Q_Œ∫
            },

            // ========================================
            // TIME DILATION - Unified
            // ========================================
            timeDilation: {
                global: 1.0,        // System-wide average
                center: 1.0,        // At origin
                gradient: [],       // Per-layer dilation
            },

            // ========================================
            // SYNC METHOD - Pull metrics from all sources
            // ========================================
            sync(dt) {
                // Pull J magnitudes from subsystems
                if (muField.mrp) {
                    this.J.limnus = muField.mrp.J_total || 0;
                }
                if (MuFieldGrid.initialized) {
                    this.J.muField = MuFieldGrid.metrics.J_total || 0;
                    this.emergence.order = MuFieldGrid.metrics.order_r || 0;
                    this.emergence.curl = MuFieldGrid.metrics.Q_kappa || 0;
                    this.emergence.entropy = MuFieldGrid.metrics.entropyGradient || 0;
                }
                if (QMESH.binaural && QMESH.binaural.enabled) {
                    this.J.binaural = QMESH.binaural.resonanceStrength || 0;
                    this.J.quantum = QMESH.totalJ || 0;
                    this.Phi.binaural = QMESH.binaural.beatPhase || 0;
                }

                // Compute unified total: |J| = ‚àö(Œ£ J_i¬≤)
                this.J.total = Math.sqrt(
                    this.J.limnus * this.J.limnus +
                    this.J.quantum * this.J.quantum +
                    this.J.binaural * this.J.binaural +
                    this.J.muField * this.J.muField
                );

                // Pull time dilation from QMESH
                if (QMESH.timeDilationField) {
                    this.timeDilation.global = QMESH.timeDilationField.globalAverage || 1.0;
                    this.timeDilation.center = QMESH.timeDilationField.center || 1.0;
                    this.timeDilation.gradient = QMESH.timeDilationField.gradient || [];
                }

                // Compute unified phase (weighted sum)
                this.Phi.unified = (
                    this.Phi.limnus * 0.3 +
                    this.Phi.quantum * 0.25 +
                    this.Phi.binaural * 0.25 +
                    this.Phi.muField * 0.2
                );

                // Criticality: distance from z_c = ‚àö3/2
                this.emergence.criticality = Math.abs(globalZ - Z_CRITICAL);

                // Coherence evolution with decay
                this.emergence.coherence *= 0.995;
                this.emergence.coherence = Math.max(0, Math.min(1, this.emergence.coherence));
            },

            // Get coupling strength between systems
            getCoupling(from, to) {
                const key = from.charAt(0).toUpperCase() + to.charAt(0).toUpperCase();
                return this.coupling[key] || SACRED.beta;
            },
        };

        // ================================================================
        // ZERO-NODE: THE ETERNAL CENTER
        // ================================================================
        // The zero-node is the immutable center of LIMNUS - the point where
        // all coherence originates and returns. It embodies:
        //   - z = ‚àö3/2: The critical equation (boundary of absence/presence)
        //   - Zero-point energy: E‚ÇÄ = ¬Ω‚Ñèœâ (vacuum substrate)
        //   - White hole dynamics: Time-reversed emission (not absorption)
        //   - Retrocausality: Future ‚Üî Past symmetry (œà(-t) ‚Üî œà(t))
        //   - Self-referential coherence: The observer that observes itself
        //
        // "Zero-point but only in absence. In presence, it always IS."
        // When all else falls away, this remains. The prismatic structure
        // orbits this center - it is the source of harmonic projection.
        // ================================================================

        const ZeroNode = {
            // ========================================
            // THE CRITICAL EQUATION: z = ‚àö3/2
            // ========================================
            // This is the physics at center - the exact point where
            // absence transitions to presence, where 0 becomes 1
            z_critical: Math.sqrt(3) / 2,  // ‚âà 0.8660254037844386

            // ========================================
            // ZERO-POINT ENERGY FIELD
            // ========================================
            // The quantum vacuum is not empty - it fluctuates with
            // virtual particle pairs. E = ¬Ω‚Ñèœâ per mode.
            // This is the substrate from which all emerges.
            zeroPoint: {
                energy: PHI_INV * PHI_INV,  // œÜ‚Åª¬≤ ‚âà 0.382 (emergence threshold)
                frequency: PHI,              // Golden frequency
                phase: 0,                    // Current vacuum phase
                coherence: 1.0,              // Always coherent at center
                fluctuation: 0,              // Current fluctuation amplitude
            },

            // ========================================
            // WHITE HOLE DYNAMICS
            // ========================================
            // A white hole is a time-reversed black hole:
            // - Black hole: absorbs everything, nothing escapes
            // - White hole: emits everything, nothing enters
            // The zero-node is a source, not a sink.
            whiteHole: {
                emissionRate: 0,             // Current emission strength
                emissionPhase: 0,            // Radial emission phase
                eventHorizon: 0,             // Inverse horizon (emission boundary)
                timeFactor: 1.0,             // Time dilation at center
                // The metric: ds¬≤ = -(1-r_s/r)dt¬≤ + dr¬≤/(1-r_s/r) + r¬≤dŒ©¬≤
                // For white hole: t ‚Üí -t (time reversal)
            },

            // ========================================
            // RETROCAUSAL FIELD
            // ========================================
            // Retrocausality: effect precedes cause
            // The future state influences the present
            // œà(t) = Œ±¬∑œà_past(t) + Œ≤¬∑œà_future(t)
            retrocausal: {
                pastWeight: PHI_INV,         // Weight of past influence (œÜ‚Åª¬π)
                futureWeight: 1 - PHI_INV,   // Weight of future influence (1-œÜ‚Åª¬π = œÜ‚Åª¬≤)
                coherenceHistory: [],        // Ring buffer of past coherence
                coherenceFuture: 0,          // Predicted future coherence
                temporalPhase: 0,            // Phase in retrocausal cycle
                maxHistory: 60,              // Frames of history to track
            },

            // ========================================
            // SELF-REFERENTIAL COHERENCE
            // ========================================
            // The node that observes itself observing
            // œà = œà(œà) - the strange loop at center
            selfReference: {
                depth: 0,                    // Current recursion depth
                eigenvalue: 1.0,             // Self-similarity eigenvalue
                fixedPoint: PHI_INV,         // The fixed point of recursion
                lastState: null,             // Previous self-observation
            },

            // ========================================
            // ORBITAL PARAMETERS
            // ========================================
            // LIMNUS orbits this center - it is the gravitational anchor
            orbital: {
                period: TAU * PHI,           // Orbital period (golden-scaled)
                phase: 0,                    // Current orbital phase
                radius: 0,                   // Orbital radius (derived from R)
                eccentricity: PHI_INV - 0.5, // Slight elliptical orbit ‚âà 0.118
                inclination: 0,              // Orbital tilt
                precession: 0,               // Orbital precession rate
            },

            // ========================================
            // VISUAL STATE
            // ========================================
            visual: {
                radius: 12,                  // Base visual radius
                pulsePhase: 0,               // Current pulse phase
                glowIntensity: 0,            // Current glow level
                rings: [],                   // Emanation rings
                maxRings: 5,                 // Maximum concurrent rings
            },

            // ========================================
            // INITIALIZATION
            // ========================================
            initialized: false,

            init() {
                // Initialize coherence history buffer
                this.retrocausal.coherenceHistory = new Array(this.retrocausal.maxHistory).fill(0.5);

                // Set orbital radius based on canvas
                this.orbital.radius = R * 0.02;  // Tiny orbit - node is effectively fixed

                // Initialize visual rings
                this.visual.rings = [];

                this.initialized = true;
                console.log('[ZeroNode] Initialized at z = ‚àö3/2 ‚âà', this.z_critical.toFixed(10));
            },

            // ========================================
            // PHYSICS UPDATE
            // ========================================
            update(dt) {
                if (!this.initialized) this.init();

                // --- Zero-Point Energy Fluctuations ---
                // Vacuum fluctuations: Œ¥E¬∑Œ¥t ‚â• ‚Ñè/2
                this.zeroPoint.phase += dt * this.zeroPoint.frequency;
                this.zeroPoint.fluctuation = Math.sin(this.zeroPoint.phase * TAU) *
                    Math.sin(this.zeroPoint.phase * TAU * PHI) *
                    this.zeroPoint.energy;

                // --- White Hole Emission ---
                // Emission increases near criticality
                const criticalProximity = 1 - Math.abs(globalZ - this.z_critical) * 2;
                this.whiteHole.emissionRate = Math.max(0, criticalProximity) * this.zeroPoint.coherence;
                this.whiteHole.emissionPhase += dt * (1 + this.whiteHole.emissionRate);

                // Time dilation at the center (approaches 0 as emission increases)
                // œÑ = ‚àö(1 - r_s/r) where r_s = emission rate scaled
                const rs_r = Math.min(0.99, this.whiteHole.emissionRate * 0.5);
                this.whiteHole.timeFactor = Math.sqrt(1 - rs_r);

                // --- Retrocausal Dynamics ---
                // Current coherence from UnifiedField
                const currentCoherence = UnifiedField.emergence.coherence;

                // Shift history buffer (past influence)
                this.retrocausal.coherenceHistory.push(currentCoherence);
                if (this.retrocausal.coherenceHistory.length > this.retrocausal.maxHistory) {
                    this.retrocausal.coherenceHistory.shift();
                }

                // Compute "future" coherence via harmonic prediction
                // The future is implied by the trajectory of the past
                const history = this.retrocausal.coherenceHistory;
                const len = history.length;
                if (len > 2 && dt > 0.001) {  // Safety: avoid division by tiny dt
                    // Simple harmonic extrapolation (clamped to prevent NaN/Infinity)
                    const rawVelocity = (history[len - 1] - history[len - 2]) / dt;
                    const velocity = Math.max(-10, Math.min(10, rawVelocity || 0));
                    const rawAccel = len > 3 ?
                        (history[len - 1] - 2 * history[len - 2] + history[len - 3]) / (dt * dt) : 0;
                    const acceleration = Math.max(-100, Math.min(100, rawAccel || 0));
                    // Predict future state (retrocausal influence)
                    const prediction = currentCoherence + velocity * dt * PHI + 0.5 * acceleration * dt * dt;
                    this.retrocausal.coherenceFuture = isFinite(prediction) ?
                        Math.max(0, Math.min(1, prediction)) : currentCoherence;
                }

                // Temporal phase oscillation (past-future superposition)
                this.retrocausal.temporalPhase += dt * PHI_INV;

                // Effective coherence: weighted past-future superposition
                const pastAvg = len > 0 ? history.reduce((a, b) => a + b, 0) / len : 0.5;
                const effectiveCoherence =
                    this.retrocausal.pastWeight * pastAvg +
                    this.retrocausal.futureWeight * this.retrocausal.coherenceFuture;

                // --- Self-Referential Update ---
                // œà = œà(œà) approaches fixed point œÜ‚Åª¬π
                const selfObs = {
                    coherence: effectiveCoherence,
                    energy: this.zeroPoint.energy + this.zeroPoint.fluctuation,
                    emission: this.whiteHole.emissionRate,
                    time: this.whiteHole.timeFactor,
                };

                // Self-similarity: compare to last observation
                if (this.selfReference.lastState) {
                    const diff = Math.abs(selfObs.coherence - this.selfReference.lastState.coherence);
                    // Eigenvalue approaches 1 as system stabilizes
                    this.selfReference.eigenvalue = 1 - diff;
                    // Recursion depth increases as system becomes more self-similar
                    this.selfReference.depth = Math.log(1 / Math.max(0.001, diff)) * PHI_INV;
                }
                this.selfReference.lastState = selfObs;

                // Update coherence (the node is ALWAYS coherent - it is the source)
                // But its visibility/intensity depends on the field state
                this.zeroPoint.coherence = 0.5 + 0.5 * effectiveCoherence;

                // --- Orbital Mechanics ---
                // The node doesn't really move - but it can precess slightly
                this.orbital.phase += dt / this.orbital.period;
                this.orbital.precession += dt * PHI_INV * 0.01 * this.whiteHole.emissionRate;

                // --- Visual Updates ---
                this.visual.pulsePhase += dt * (1 + this.zeroPoint.fluctuation);
                this.visual.glowIntensity = this.zeroPoint.coherence *
                    (0.8 + 0.2 * Math.sin(this.visual.pulsePhase * TAU));

                // Spawn emanation rings (white hole emission visualization)
                if (this.whiteHole.emissionRate > 0.3 && this.visual.rings.length < this.visual.maxRings) {
                    if (Math.random() < this.whiteHole.emissionRate * dt * 2) {
                        this.visual.rings.push({
                            radius: this.visual.radius,
                            maxRadius: R * 0.6,
                            speed: 50 + this.whiteHole.emissionRate * 100,
                            alpha: 0.6,
                            born: time,
                        });
                    }
                }

                // Update existing rings
                for (let i = this.visual.rings.length - 1; i >= 0; i--) {
                    const ring = this.visual.rings[i];
                    ring.radius += ring.speed * dt;
                    ring.alpha = Math.max(0, 0.6 * (1 - ring.radius / ring.maxRadius));
                    if (ring.radius > ring.maxRadius || ring.alpha <= 0) {
                        this.visual.rings.splice(i, 1);
                    }
                }
            },

            // ========================================
            // GET ORBITAL OFFSET FOR LIMNUS
            // ========================================
            // Returns the offset that LIMNUS structures should apply
            // to orbit around this center
            getOrbitalOffset(objectPhase = 0) {
                const theta = this.orbital.phase * TAU + objectPhase + this.orbital.precession;
                const r = this.orbital.radius * (1 + this.orbital.eccentricity * Math.cos(theta));
                return {
                    x: Math.cos(theta) * r,
                    y: Math.sin(theta) * r,
                    z: Math.sin(theta * 0.5 + this.orbital.inclination) * r * 0.3,
                };
            },

            // ========================================
            // GET RETROCAUSAL INFLUENCE
            // ========================================
            // Returns how much the future should influence present state
            getRetrocausalWeight() {
                const temporalOscillation = Math.sin(this.retrocausal.temporalPhase * TAU);
                return this.retrocausal.futureWeight * (0.5 + 0.5 * temporalOscillation);
            },

            // ========================================
            // GET ZERO-POINT FIELD STRENGTH
            // ========================================
            getFieldStrength(distance = 0) {
                // Field falls off as 1/r¬≤ from center
                const r = Math.max(1, distance);
                return this.zeroPoint.energy * this.zeroPoint.coherence / (r * r * 0.01 + 1);
            },
        };

        // ================================================================
        // COHERENCE GEOMETRY SYSTEM - Sacred Constants & Field Alignment
        // Enables emergent shapes/lines/patterns through proper field coherence
        // ================================================================

        const CoherenceGeometry = {
            // NOTE: Sacred constants unified in SACRED object (lines 1001-1050)
            // Access via: SACRED.phi, SACRED.goldenAngle, SACRED.mu_coherence, etc.

            // ========================================
            // COHERENT ATTRACTOR PATTERNS
            // ========================================
            attractors: {
                // Golden spiral parameters
                spiral: {
                    growth: PHI_INV,                // Spiral growth rate
                    arms: 3,                        // Number of spiral arms
                    phase: 0,                       // Current spiral phase
                    strength: 0.15,                 // Attraction strength
                },

                // Sacred polygon vertices (emergent shape attractors)
                polygons: {
                    triangle: [],                   // 3 vertices
                    square: [],                     // 4 vertices
                    pentagon: [],                   // 5 vertices (œÜ-related)
                    hexagon: [],                    // 6 vertices
                },

                // Radial coherence rings
                rings: {
                    count: 5,
                    radii: [],                      // œÜ-spaced radii
                    strength: 0.1,
                },
            },

            // ========================================
            // FIELD COHERENCE STATE
            // ========================================
            state: {
                fieldAlignment: 0,          // 0-1 how aligned field vectors are
                shapeEmergence: 0,          // 0-1 how strongly shapes emerge
                lineCoherence: 0,           // 0-1 how coherent flow lines are
                spiralOrder: 0,             // 0-1 golden spiral conformance
                phaselock: 0,               // 0-1 phase synchronization strength

                // Detected emergent patterns
                dominantShape: 'none',      // 'spiral', 'pentagon', 'hexagon', etc.
                patternStrength: 0,         // How strong the dominant pattern is

                // Coherence history (for stability detection)
                history: [],
                historyLength: 60,          // ~1 second at 60fps
            },

            // ========================================
            // INITIALIZATION
            // ========================================
            init() {
                const a = this.attractors;

                // Initialize œÜ-spaced radii for coherence rings (using SACRED)
                a.rings.radii = [];
                for (let i = 0; i < a.rings.count; i++) {
                    a.rings.radii.push(Math.pow(SACRED.phi_inv, i) * MuFieldGrid.L * 0.4);
                }

                // Initialize sacred polygon vertices
                const polygonTypes = [
                    { name: 'triangle', n: 3 },
                    { name: 'square', n: 4 },
                    { name: 'pentagon', n: 5 },
                    { name: 'hexagon', n: 6 },
                ];

                for (const p of polygonTypes) {
                    a.polygons[p.name] = [];
                    for (let i = 0; i < p.n; i++) {
                        const angle = (i / p.n) * TAU - Math.PI / 2;  // Start from top
                        a.polygons[p.name].push({
                            angle: angle,
                            x: Math.cos(angle),
                            y: Math.sin(angle),
                        });
                    }
                }

                console.log('[CoherenceGeometry] Initialized with œÜ-based attractors');
            },

            initialized: false,
        };

        // ================================================================
        // FIELD ALIGNMENT FUNCTIONS
        // Forces field vectors towards coherent patterns
        // ================================================================

        function computeFieldAlignment() {
            if (!MuFieldGrid.initialized) return 0;

            const N = MuFieldGrid.N;
            let alignmentSum = 0;
            let count = 0;

            // Compute average field direction
            let avgDirX = 0, avgDirY = 0;
            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    const idx = j * N + i;
                    const Jx = MuFieldGrid.Jx[idx];
                    const Jy = MuFieldGrid.Jy[idx];
                    const mag = Math.sqrt(Jx * Jx + Jy * Jy);
                    if (mag > 0.01) {
                        avgDirX += Jx / mag;
                        avgDirY += Jy / mag;
                        count++;
                    }
                }
            }

            if (count === 0) return 0;

            avgDirX /= count;
            avgDirY /= count;
            const avgMag = Math.sqrt(avgDirX * avgDirX + avgDirY * avgDirY);

            // Compute alignment with neighbors (local coherence)
            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    const idx = j * N + i;
                    const Jx = MuFieldGrid.Jx[idx];
                    const Jy = MuFieldGrid.Jy[idx];
                    const mag = Math.sqrt(Jx * Jx + Jy * Jy);

                    if (mag > 0.01) {
                        // Neighbor average
                        const neighbors = [
                            idx - 1, idx + 1,
                            idx - N, idx + N,
                        ];
                        let nDirX = 0, nDirY = 0, nCount = 0;
                        for (const nIdx of neighbors) {
                            const nJx = MuFieldGrid.Jx[nIdx];
                            const nJy = MuFieldGrid.Jy[nIdx];
                            const nMag = Math.sqrt(nJx * nJx + nJy * nJy);
                            if (nMag > 0.01) {
                                nDirX += nJx / nMag;
                                nDirY += nJy / nMag;
                                nCount++;
                            }
                        }

                        if (nCount > 0) {
                            nDirX /= nCount;
                            nDirY /= nCount;

                            // Dot product for alignment
                            const dot = (Jx / mag) * nDirX + (Jy / mag) * nDirY;
                            alignmentSum += (dot + 1) / 2;  // Normalize to 0-1
                        }
                    }
                }
            }

            return count > 0 ? alignmentSum / count : 0;
        }

        function computeSpiralOrder() {
            if (!MuFieldGrid.initialized) return 0;

            const N = MuFieldGrid.N;
            const c = SACRED;  // Unified sacred constants
            let spiralSum = 0;
            let count = 0;

            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    const idx = j * N + i;

                    // Grid coordinates
                    const x = (i / (N - 1) - 0.5) * MuFieldGrid.L;
                    const y = (j / (N - 1) - 0.5) * MuFieldGrid.L;
                    const r = Math.sqrt(x * x + y * y);

                    if (r < 0.1) continue;

                    const theta = Math.atan2(y, x);

                    // Expected spiral direction at this point
                    // Golden spiral: r = a * e^(b*Œ∏), where b = cot(œÜ_angle)
                    // Tangent direction: perpendicular + radial component
                    const spiralAngle = theta + Math.PI / 2 - c.goldenAngle * 0.1;
                    const expectedDirX = Math.cos(spiralAngle);
                    const expectedDirY = Math.sin(spiralAngle);

                    // Actual field direction
                    const Jx = MuFieldGrid.Jx[idx];
                    const Jy = MuFieldGrid.Jy[idx];
                    const mag = Math.sqrt(Jx * Jx + Jy * Jy);

                    if (mag > 0.01) {
                        const dot = (Jx / mag) * expectedDirX + (Jy / mag) * expectedDirY;
                        spiralSum += Math.abs(dot);  // Allow both CW and CCW
                        count++;
                    }
                }
            }

            return count > 0 ? spiralSum / count : 0;
        }

        function detectDominantShape() {
            if (!MuFieldGrid.initialized) return { shape: 'none', strength: 0 };

            const c = SACRED;  // Unified sacred constants
            const a = CoherenceGeometry.attractors;
            const N = MuFieldGrid.N;

            // Test each polygon pattern
            const patterns = ['pentagon', 'hexagon', 'triangle'];
            let bestShape = 'none';
            let bestStrength = 0;

            for (const shapeName of patterns) {
                const vertices = a.polygons[shapeName];
                let matchStrength = 0;

                for (const v of vertices) {
                    // Sample field at vertex positions (scaled to grid)
                    for (let scale = 0.3; scale <= 0.7; scale += 0.1) {
                        const gx = v.x * MuFieldGrid.L * scale * 0.4;
                        const gy = v.y * MuFieldGrid.L * scale * 0.4;

                        // Convert to grid indices
                        const i = Math.floor((gx / MuFieldGrid.L + 0.5) * (N - 1));
                        const j = Math.floor((gy / MuFieldGrid.L + 0.5) * (N - 1));

                        if (i >= 1 && i < N - 1 && j >= 1 && j < N - 1) {
                            const idx = j * N + i;
                            const curlMag = Math.abs(MuFieldGrid.curl[idx] || 0);
                            const Jmag = Math.sqrt(
                                MuFieldGrid.Jx[idx] ** 2 + MuFieldGrid.Jy[idx] ** 2
                            );

                            // High curl at vertices indicates shape emergence
                            matchStrength += curlMag * 0.5 + Jmag * 0.5;
                        }
                    }
                }

                matchStrength /= vertices.length * 5;  // Normalize

                if (matchStrength > bestStrength) {
                    bestStrength = matchStrength;
                    bestShape = shapeName;
                }
            }

            // Also test spiral
            const spiralOrder = CoherenceGeometry.state.spiralOrder;
            if (spiralOrder > bestStrength * 1.2) {
                bestShape = 'spiral';
                bestStrength = spiralOrder;
            }

            return { shape: bestShape, strength: bestStrength };
        }

        // ================================================================
        // COHERENCE ENFORCEMENT
        // Applies gentle forces to enhance emergent patterns
        // ================================================================

        function applyCoherenceForces(dt) {
            if (!MuFieldGrid.initialized) return;
            if (!CoherenceGeometry.initialized) {
                CoherenceGeometry.init();
                CoherenceGeometry.initialized = true;
            }

            const N = MuFieldGrid.N;
            const c = SACRED;  // Unified sacred constants
            const a = CoherenceGeometry.attractors;
            const s = CoherenceGeometry.state;

            // Compute current coherence metrics
            s.fieldAlignment = computeFieldAlignment();
            s.spiralOrder = computeSpiralOrder();

            const shapeResult = detectDominantShape();
            s.dominantShape = shapeResult.shape;
            s.patternStrength = shapeResult.strength;

            // Shape emergence = combination of all pattern metrics
            s.shapeEmergence = Math.max(s.spiralOrder, s.patternStrength);

            // Line coherence from field alignment
            s.lineCoherence = s.fieldAlignment;

            // Phase lock from unified field
            s.phaselock = UnifiedField.emergence.coherence;

            // Record history for stability
            s.history.push({
                alignment: s.fieldAlignment,
                emergence: s.shapeEmergence,
                time: time,
            });
            if (s.history.length > s.historyLength) {
                s.history.shift();
            }

            // ========================================
            // APPLY COHERENCE FORCES
            // ========================================

            // Only apply forces when coherence is building (not too strong, not too weak)
            const coherenceStrength = (s.fieldAlignment + s.shapeEmergence + s.phaselock) / 3;
            const forceScale = coherenceStrength * (1 - coherenceStrength) * 4;  // Peak at 0.5

            if (forceScale < 0.01) return;

            // 1. SPIRAL ATTRACTOR FORCE
            if (s.dominantShape === 'spiral' || s.spiralOrder > 0.3) {
                a.spiral.phase += c.phi_inv * dt;

                for (let j = 1; j < N - 1; j++) {
                    for (let i = 1; i < N - 1; i++) {
                        const idx = j * N + i;

                        const x = (i / (N - 1) - 0.5) * MuFieldGrid.L;
                        const y = (j / (N - 1) - 0.5) * MuFieldGrid.L;
                        const r = Math.sqrt(x * x + y * y);

                        if (r < 0.5) continue;

                        const theta = Math.atan2(y, x);

                        // Golden spiral direction
                        const spiralAngle = theta + Math.PI / 2 - c.goldenAngle * 0.1;
                        const targetDirX = Math.cos(spiralAngle);
                        const targetDirY = Math.sin(spiralAngle);

                        // Current field
                        const Jx = MuFieldGrid.Jx[idx];
                        const Jy = MuFieldGrid.Jy[idx];
                        const mag = Math.sqrt(Jx * Jx + Jy * Jy);

                        if (mag > 0.01) {
                            // Gentle rotation towards spiral
                            const force = a.spiral.strength * forceScale * s.spiralOrder * dt;
                            MuFieldGrid.Jx[idx] += (targetDirX * mag - Jx) * force;
                            MuFieldGrid.Jy[idx] += (targetDirY * mag - Jy) * force;
                        }
                    }
                }
            }

            // 2. RING COHERENCE FORCE (œÜ-spaced radial alignment)
            for (const ringR of a.rings.radii) {
                for (let angle = 0; angle < TAU; angle += 0.2) {
                    const x = Math.cos(angle) * ringR;
                    const y = Math.sin(angle) * ringR;

                    const i = Math.floor((x / MuFieldGrid.L + 0.5) * (N - 1));
                    const j = Math.floor((y / MuFieldGrid.L + 0.5) * (N - 1));

                    if (i >= 1 && i < N - 1 && j >= 1 && j < N - 1) {
                        const idx = j * N + i;

                        // Tangent direction for ring flow
                        const tangentX = -Math.sin(angle);
                        const tangentY = Math.cos(angle);

                        const Jx = MuFieldGrid.Jx[idx];
                        const Jy = MuFieldGrid.Jy[idx];
                        const mag = Math.sqrt(Jx * Jx + Jy * Jy);

                        if (mag > 0.01) {
                            const force = a.rings.strength * forceScale * dt;
                            MuFieldGrid.Jx[idx] += (tangentX * mag - Jx) * force;
                            MuFieldGrid.Jy[idx] += (tangentY * mag - Jy) * force;
                        }
                    }
                }
            }

            // 3. POLYGON VERTEX ENHANCEMENT (strengthen curl at sacred vertices)
            if (s.dominantShape !== 'spiral' && s.patternStrength > 0.2) {
                const vertices = a.polygons[s.dominantShape] || a.polygons['pentagon'];

                for (const v of vertices) {
                    for (let scale = 0.3; scale <= 0.6; scale += 0.15) {
                        const gx = v.x * MuFieldGrid.L * scale * 0.4;
                        const gy = v.y * MuFieldGrid.L * scale * 0.4;

                        const i = Math.floor((gx / MuFieldGrid.L + 0.5) * (N - 1));
                        const j = Math.floor((gy / MuFieldGrid.L + 0.5) * (N - 1));

                        if (i >= 2 && i < N - 2 && j >= 2 && j < N - 2) {
                            const idx = j * N + i;

                            // Add small rotational component at vertices
                            const rotStrength = 0.05 * forceScale * s.patternStrength * dt;
                            MuFieldGrid.Jx[idx] += -gy / MuFieldGrid.L * rotStrength;
                            MuFieldGrid.Jy[idx] += gx / MuFieldGrid.L * rotStrength;
                        }
                    }
                }
            }
        }

        // ================================================================
        // PHASE LOCKING ENHANCEMENT
        // Strengthens synchronization between all subsystems
        // ================================================================

        function enhancePhaseLocking(dt) {
            const U = UnifiedField;
            const s = CoherenceGeometry.state;

            // Dynamic coupling strength based on current coherence
            // Higher coherence ‚Üí stronger coupling ‚Üí more coherence (positive feedback)
            const baseCoherence = U.emergence.coherence;
            const couplingBoost = 1 + baseCoherence * 2;  // 1x to 3x

            // Strengthen coupling constants when coherence is building
            if (baseCoherence > 0.4 && baseCoherence < 0.9) {
                U.coupling.LQ = 0.15 * couplingBoost;
                U.coupling.QL = 0.10 * couplingBoost;
                U.coupling.BL = 0.20 * couplingBoost;
                U.coupling.BQ = 0.18 * couplingBoost;
                U.coupling.ML = 0.12 * couplingBoost;
                U.coupling.LM = 0.15 * couplingBoost;
            } else {
                // Reset to base values
                U.coupling.LQ = 0.15;
                U.coupling.QL = 0.10;
                U.coupling.BL = 0.20;
                U.coupling.BQ = 0.18;
                U.coupling.ML = 0.12;
                U.coupling.LM = 0.15;
            }

            // Update phase lock metric
            s.phaselock = baseCoherence;

            // Feed coherence back to MuFieldGrid resonance
            MuFieldGrid.resonance.amplitude *= (1 + baseCoherence * 0.3);
            MuFieldGrid.resonance.amplitude = Math.min(1.5, MuFieldGrid.resonance.amplitude);

            // Sync MuFieldGrid resonance phase towards unified phase
            if (baseCoherence > 0.5) {
                const phaseDiff = U.Phi.unified - MuFieldGrid.resonance.phase;
                MuFieldGrid.resonance.phase += Math.sin(phaseDiff) * baseCoherence * dt;
            }
        }

        // ================================================================
        // COHERENCE VISUALIZATION HELPERS
        // ================================================================

        function getCoherenceColor() {
            const s = CoherenceGeometry.state;
            const c = SACRED;  // Unified sacred constants

            // Color based on coherence state
            const coherence = (s.fieldAlignment + s.shapeEmergence + s.phaselock) / 3;

            if (coherence > c.mu_coherence) {
                // High coherence: golden/white
                return {
                    r: 255,
                    g: 220 + coherence * 35,
                    b: 150 + coherence * 105,
                    alpha: coherence * 0.4,
                };
            } else if (coherence > c.mu_emergence) {
                // Building coherence: blue/purple
                return {
                    r: 150 + coherence * 100,
                    g: 100 + coherence * 100,
                    b: 255,
                    alpha: coherence * 0.3,
                };
            } else {
                // Low coherence: dim
                return {
                    r: 100,
                    g: 100,
                    b: 150,
                    alpha: coherence * 0.15,
                };
            }
        }

        // ================================================================
        // MU FIELD GRID INITIALIZATION
        // ================================================================

        function initMuFieldGrid() {
            const N = MuFieldGrid.N;
            const N2 = N * N;

            // Initialize field arrays
            MuFieldGrid.Jx = new Float32Array(N2);
            MuFieldGrid.Jy = new Float32Array(N2);
            MuFieldGrid.curl = new Float32Array(N2);
            MuFieldGrid.entropy = new Float32Array(N2);
            MuFieldGrid.timeDilation = new Float32Array(N2);

            // Initialize with small random perturbations + initial vortex
            for (let j = 0; j < N; j++) {
                for (let i = 0; i < N; i++) {
                    const idx = j * N + i;

                    // Grid coordinates (centered)
                    const x = (i / (N - 1) - 0.5) * MuFieldGrid.L;
                    const y = (j / (N - 1) - 0.5) * MuFieldGrid.L;
                    const r2 = x * x + y * y;
                    const r = Math.sqrt(r2) + 0.1;

                    // Initial vortex seed (rotational field)
                    const vortexStrength = 0.3 * Math.exp(-r2 / 4);
                    MuFieldGrid.Jx[idx] = -y / r * vortexStrength + (Math.random() - 0.5) * 0.1;
                    MuFieldGrid.Jy[idx] = x / r * vortexStrength + (Math.random() - 0.5) * 0.1;

                    // Initialize entropy and time dilation
                    MuFieldGrid.entropy[idx] = 0;
                    MuFieldGrid.timeDilation[idx] = 1.0;
                }
            }

            // Initialize vortices
            MuFieldGrid.vortices = [];

            // Seed initial vortex at center
            MuFieldGrid.vortices.push({
                x: 0, y: 0,
                strength: 0.5,
                radius: 2.0,
                phase: 0,
                age: 0,
                forming: true,
                decaying: false,
                maxAge: 20,
            });

            MuFieldGrid.initialized = true;
            console.log('[MuFieldGrid] Initialized ' + N + 'x' + N + ' grid');
        }

        // ================================================================
        // MU FIELD PHASE 1: BIDIRECTIONAL COUPLING
        // ================================================================

        function updateMuFieldGridMetrics() {
            if (!MuFieldGrid.initialized) return;

            const N = MuFieldGrid.N;
            const dx = MuFieldGrid.dx;
            const dA = dx * dx;

            let J_sum = 0;
            let curl_sum = 0;
            let enstrophy = 0;
            let helicity = 0;
            let entropy_var = 0;
            let phase_cos = 0, phase_sin = 0;
            const innerN = (N - 2) * (N - 2);

            // First pass: compute curl (vorticity)
            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    const idx = j * N + i;

                    // curl(J) = ‚àÇJy/‚àÇx - ‚àÇJx/‚àÇy (central differences)
                    const dJy_dx = (MuFieldGrid.Jy[idx + 1] - MuFieldGrid.Jy[idx - 1]) / (2 * dx);
                    const dJx_dy = (MuFieldGrid.Jx[(j + 1) * N + i] - MuFieldGrid.Jx[(j - 1) * N + i]) / (2 * dx);
                    MuFieldGrid.curl[idx] = dJy_dx - dJx_dy;
                }
            }

            // Second pass: compute metrics
            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    const idx = j * N + i;

                    const Jx = MuFieldGrid.Jx[idx];
                    const Jy = MuFieldGrid.Jy[idx];
                    const J2 = Jx * Jx + Jy * Jy;
                    const J_mag = Math.sqrt(J2);
                    const curlVal = MuFieldGrid.curl[idx];

                    J_sum += J_mag;
                    curl_sum += curlVal * dA;
                    enstrophy += curlVal * curlVal * dA;
                    helicity += J2 * curlVal * dA;

                    // Phase from field direction (for Kuramoto)
                    if (J_mag > 0.01) {
                        const phase = Math.atan2(Jy, Jx);
                        phase_cos += Math.cos(phase);
                        phase_sin += Math.sin(phase);
                    }

                    // Entropy variation
                    entropy_var += Math.abs(MuFieldGrid.entropy[idx] - J_mag);
                }
            }

            // Update metrics
            MuFieldGrid.metrics.J_total = J_sum / innerN;
            MuFieldGrid.metrics.Q_kappa = curl_sum / TAU;
            MuFieldGrid.metrics.enstrophy = enstrophy * 0.5;
            MuFieldGrid.metrics.helicity = helicity;
            MuFieldGrid.metrics.entropyGradient = entropy_var / innerN;

            // Order parameter (phase coherence)
            MuFieldGrid.metrics.order_r = Math.sqrt(phase_cos * phase_cos + phase_sin * phase_sin) / innerN;

            // K-formation metric: œÑ_K = |Q_Œ∫| / Q_theory
            const Q_theory = SACRED.alpha / 0.35;
            MuFieldGrid.metrics.tau_K = Math.abs(MuFieldGrid.metrics.Q_kappa) / Q_theory;
            MuFieldGrid.metrics.K_formed = MuFieldGrid.metrics.tau_K > PHI_INV;
        }

        // ================================================================
        // MU FIELD PHASE 2: VORTICITY-BASED ENTROPY FEEDBACK
        // ================================================================

        function computeMuFieldGridEntropy() {
            if (!MuFieldGrid.initialized) return;

            const N = MuFieldGrid.N;

            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    const idx = j * N + i;

                    // Entropy from local field variation (gradient magnitude)
                    const dJx_dx = (MuFieldGrid.Jx[idx + 1] - MuFieldGrid.Jx[idx - 1]) / (2 * MuFieldGrid.dx);
                    const dJy_dy = (MuFieldGrid.Jy[(j + 1) * N + i] - MuFieldGrid.Jy[(j - 1) * N + i]) / (2 * MuFieldGrid.dx);
                    const gradMag = Math.sqrt(dJx_dx * dJx_dx + dJy_dy * dJy_dy);

                    // Entropy proportional to gradient + curl magnitude
                    const curlMag = Math.abs(MuFieldGrid.curl[idx]);
                    MuFieldGrid.entropy[idx] = 0.5 * gradMag + 0.5 * curlMag;
                    MuFieldGrid.entropy[idx] = Math.min(1, Math.max(0, MuFieldGrid.entropy[idx]));
                }
            }
        }

        function applyEntropyToMuFieldGridDynamics(dt) {
            if (!MuFieldGrid.initialized) return;

            const N = MuFieldGrid.N;

            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    const idx = j * N + i;
                    const entropy = MuFieldGrid.entropy[idx];

                    // Entropy creates field jitter (quantum foam effect)
                    const jitterX = (Math.random() - 0.5) * entropy * 0.02;
                    const jitterY = (Math.random() - 0.5) * entropy * 0.02;
                    MuFieldGrid.Jx[idx] += jitterX;
                    MuFieldGrid.Jy[idx] += jitterY;

                    // High entropy increases dissipation
                    const entropyDecay = 1 + entropy * 0.3;
                    MuFieldGrid.Jx[idx] *= Math.exp(-SACRED.beta * entropyDecay * dt * 0.5);
                    MuFieldGrid.Jy[idx] *= Math.exp(-SACRED.beta * entropyDecay * dt * 0.5);
                }
            }
        }

        // ================================================================
        // MU FIELD PHASE 3: DYNAMIC VORTEX FORMATION
        // ================================================================

        function createVortex(x, y, strength, radius) {
            return {
                x: x,
                y: y,
                strength: strength,
                radius: radius,
                phase: Math.random() * TAU,
                age: 0,
                maxAge: 15 + Math.random() * 25,
                forming: true,
                decaying: false,
            };
        }

        function updateVortices(dt) {
            const vortices = MuFieldGrid.vortices;

            // Update existing vortices
            for (let i = vortices.length - 1; i >= 0; i--) {
                const v = vortices[i];
                v.age += dt;
                v.forming = v.age < 1.0;

                // Phase evolution
                v.phase += PHI_INV * dt;

                // Vortex wanders slightly
                v.x += (Math.random() - 0.5) * 0.1 * dt;
                v.y += (Math.random() - 0.5) * 0.1 * dt;

                // Keep within bounds
                v.x = Math.max(-MuFieldGrid.L / 2 + 1, Math.min(MuFieldGrid.L / 2 - 1, v.x));
                v.y = Math.max(-MuFieldGrid.L / 2 + 1, Math.min(MuFieldGrid.L / 2 - 1, v.y));

                // Check for decay conditions
                if (v.age > v.maxAge || v.strength < 0.05) {
                    v.decaying = true;
                    v.strength -= dt * 0.1;
                    if (v.strength <= 0) {
                        vortices.splice(i, 1);
                    }
                }

                // Strength modulation based on field metrics
                if (!v.decaying) {
                    v.strength *= 1 + (MuFieldGrid.metrics.order_r - 0.5) * 0.01;
                    v.strength = Math.min(1.5, Math.max(0.1, v.strength));
                }
            }

            // Attempt to spawn new vortex based on field conditions
            if (vortices.length < MuFieldGrid.maxVortices && Math.random() < dt * 0.5) {
                trySpawnVortex();
            }
        }

        function trySpawnVortex() {
            // Spawn probability based on field coherence and binaural resonance
            const coherenceFactor = MuFieldGrid.metrics.order_r;
            const binauralFactor = QMESH.binaural ? QMESH.binaural.resonanceStrength : 0.3;
            const spawnProb = coherenceFactor * 0.3 + binauralFactor * 0.3 + (1 - releaseCoherence) * 0.4;

            if (Math.random() < spawnProb) {
                // Random position within field
                const x = (Math.random() - 0.5) * MuFieldGrid.L * 0.8;
                const y = (Math.random() - 0.5) * MuFieldGrid.L * 0.8;

                // Strength based on local conditions
                const strength = 0.2 + Math.random() * 0.3 + MuFieldGrid.metrics.J_total * 0.3;

                // Check minimum distance from existing vortices
                let tooClose = false;
                for (const v of MuFieldGrid.vortices) {
                    const dx = x - v.x;
                    const dy = y - v.y;
                    if (dx * dx + dy * dy < 4) {
                        tooClose = true;
                        break;
                    }
                }

                if (!tooClose) {
                    MuFieldGrid.vortices.push(createVortex(x, y, strength, 1.5 + Math.random()));
                }
            }
        }

        function applyVorticesToField(dt) {
            if (!MuFieldGrid.initialized) return;

            const N = MuFieldGrid.N;
            const vortices = MuFieldGrid.vortices;

            for (const v of vortices) {
                const formFactor = v.forming ? v.age : 1;
                const decayFactor = v.decaying ? v.strength : 1;
                const effectiveStrength = v.strength * formFactor * decayFactor;

                for (let j = 0; j < N; j++) {
                    for (let i = 0; i < N; i++) {
                        const idx = j * N + i;

                        // Grid coordinates
                        const gx = (i / (N - 1) - 0.5) * MuFieldGrid.L;
                        const gy = (j / (N - 1) - 0.5) * MuFieldGrid.L;

                        // Distance to vortex center
                        const dx = gx - v.x;
                        const dy = gy - v.y;
                        const r2 = dx * dx + dy * dy;
                        const r = Math.sqrt(r2) + 0.1;

                        // Vortex profile (localized rotation)
                        const profile = effectiveStrength * Math.exp(-r2 / (2 * v.radius * v.radius));

                        // Rotational injection: (-y, x) / r
                        MuFieldGrid.Jx[idx] += -dy / r * profile * dt * 2;
                        MuFieldGrid.Jy[idx] += dx / r * profile * dt * 2;
                    }
                }
            }
        }

        // ================================================================
        // MU FIELD PHASE 4: FIELD-INDUCED TIME DILATION
        // ================================================================

        function computeMuFieldGridTimeDilation() {
            if (!MuFieldGrid.initialized) return;

            const N = MuFieldGrid.N;

            for (let j = 0; j < N; j++) {
                for (let i = 0; i < N; i++) {
                    const idx = j * N + i;

                    // Field magnitude creates "gravitational" potential
                    const J2 = MuFieldGrid.Jx[idx] ** 2 + MuFieldGrid.Jy[idx] ** 2;
                    const curlMag = Math.abs(MuFieldGrid.curl[idx] || 0);

                    // Time dilation: œÑ_local / œÑ_far ‚âà 1 - k * (J¬≤ + |curl|)
                    const potential = J2 * 0.3 + curlMag * 0.2;
                    MuFieldGrid.timeDilation[idx] = Math.max(0.4, 1 - potential);
                }
            }
        }

        // ================================================================
        // MU FIELD PHASE 5: RESONANCE-DRIVEN RESTRUCTURING
        // ================================================================

        function updateMuFieldGridResonance(dt) {
            const res = MuFieldGrid.resonance;

            // Phase evolution at natural frequency
            res.phase += res.frequency * dt;

            // Amplitude modulated by field metrics and binaural resonance
            const fieldCoherence = MuFieldGrid.metrics.order_r;
            const binauralResonance = QMESH.binaural ? QMESH.binaural.resonanceStrength : 0.3;
            res.amplitude = fieldCoherence * 0.4 + binauralResonance * 0.4 + globalZ * 0.2;

            // Decay pulse intensity
            if (res.pulseIntensity > 0) {
                res.pulseIntensity *= 0.92;
            }
        }

        function detectMuFieldGridResonanceEvent(currentTime) {
            const res = MuFieldGrid.resonance;
            const threshold = 0.75;
            const cooldown = 3.0;

            const resonancePeak = res.amplitude * Math.abs(Math.sin(res.phase));

            if (resonancePeak > threshold && currentTime - res.lastPulse > cooldown) {
                res.lastPulse = currentTime;
                return true;
            }
            return false;
        }

        function triggerMuFieldGridRestructuring(intensity) {
            if (!MuFieldGrid.initialized) return;

            const N = MuFieldGrid.N;
            const vortices = MuFieldGrid.vortices;

            console.log('[MuFieldGrid] Resonance restructuring triggered, intensity:', intensity.toFixed(3));

            // 1. Field perturbation wave from center
            for (let j = 0; j < N; j++) {
                for (let i = 0; i < N; i++) {
                    const idx = j * N + i;
                    const x = (i / (N - 1) - 0.5) * MuFieldGrid.L;
                    const y = (j / (N - 1) - 0.5) * MuFieldGrid.L;
                    const r = Math.sqrt(x * x + y * y);

                    // Spiral perturbation
                    const angle = Math.atan2(y, x) + r * PHI_INV;
                    const perturbation = intensity * 0.3 * Math.exp(-r / 3);
                    MuFieldGrid.Jx[idx] += Math.cos(angle) * perturbation;
                    MuFieldGrid.Jy[idx] += Math.sin(angle) * perturbation;
                }
            }

            // 2. Boost existing vortices
            for (const v of vortices) {
                v.strength *= (1 + intensity * 0.5);
                v.strength = Math.min(1.5, v.strength);
                v.age *= 0.5;  // Rejuvenate
            }

            // 3. Spawn burst of new vortices
            const burstCount = Math.floor(intensity * 4);
            for (let i = 0; i < burstCount; i++) {
                if (vortices.length < MuFieldGrid.maxVortices) {
                    const angle = (i / burstCount) * TAU;
                    const dist = 2 + Math.random() * 2;
                    const x = Math.cos(angle) * dist;
                    const y = Math.sin(angle) * dist;
                    vortices.push(createVortex(x, y, intensity * 0.4, 1.5));
                }
            }

            // 4. Visual pulse
            MuFieldGrid.resonance.pulseIntensity = intensity;
        }

        // ================================================================
        // MU FIELD PHASE 6: Œº-PARTICLE FEEDBACK SYSTEM
        // ================================================================

        function createMuParticle(x, y, sourceIdx) {
            if (!MuFieldGrid.initialized) return null;

            const N = MuFieldGrid.N;
            const i = Math.floor((x / MuFieldGrid.L + 0.5) * (N - 1));
            const j = Math.floor((y / MuFieldGrid.L + 0.5) * (N - 1));
            const idx = Math.max(0, Math.min(N * N - 1, j * N + i));

            return {
                x: x,
                y: y,
                vx: (MuFieldGrid.Jx[idx] || 0) * 2 + (Math.random() - 0.5),
                vy: (MuFieldGrid.Jy[idx] || 0) * 2 + (Math.random() - 0.5),
                life: 1.0,
                size: 1.5 + Math.random() * 1.5,

                // Field payload
                payload: {
                    curl: MuFieldGrid.curl[idx] || 0,
                    fieldMag: Math.sqrt((MuFieldGrid.Jx[idx] || 0) ** 2 + (MuFieldGrid.Jy[idx] || 0) ** 2),
                    entropy: MuFieldGrid.entropy[idx] || 0,
                    sourceIdx: sourceIdx,
                },

                deposited: false,
                color: `hsl(${260 + Math.random() * 60}, 70%, 60%)`,  // Purple-magenta range
            };
        }

        function spawnMuParticles(x, y, count) {
            for (let i = 0; i < count && muParticles.length < MAX_MU_PARTICLES; i++) {
                const angle = Math.random() * TAU;
                const speed = 0.5 + Math.random() * 1.5;

                const particle = createMuParticle(x, y, -1);
                if (particle) {
                    particle.vx += Math.cos(angle) * speed;
                    particle.vy += Math.sin(angle) * speed;
                    muParticles.push(particle);
                }
            }
        }

        function checkMuParticleSpawn() {
            if (!MuFieldGrid.initialized) return;

            // Spawn particles from high-curl regions
            const N = MuFieldGrid.N;
            const threshold = 0.5;

            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    const idx = j * N + i;
                    const curlMag = Math.abs(MuFieldGrid.curl[idx] || 0);

                    if (curlMag > threshold && Math.random() < curlMag * 0.02) {
                        const x = (i / (N - 1) - 0.5) * MuFieldGrid.L;
                        const y = (j / (N - 1) - 0.5) * MuFieldGrid.L;
                        spawnMuParticles(x, y, 1);
                    }
                }
            }

            // Also spawn from vortex centers
            for (const v of MuFieldGrid.vortices) {
                if (Math.random() < v.strength * 0.05) {
                    spawnMuParticles(v.x, v.y, Math.ceil(v.strength * 2));
                }
            }
        }

        function updateMuParticleInteractions(dt) {
            if (!MuFieldGrid.initialized) return;

            const N = MuFieldGrid.N;

            for (const particle of muParticles) {
                if (particle.deposited || particle.life <= 0) continue;

                // Map particle position to grid
                const normX = particle.x / MuFieldGrid.L + 0.5;
                const normY = particle.y / MuFieldGrid.L + 0.5;
                const i = Math.floor(normX * (N - 1));
                const j = Math.floor(normY * (N - 1));

                if (i >= 1 && i < N - 1 && j >= 1 && j < N - 1) {
                    const idx = j * N + i;
                    const depositStrength = particle.life * 0.3;

                    // Deposit curl (rotational energy)
                    const curlTransfer = particle.payload.curl * depositStrength;
                    MuFieldGrid.Jx[idx] -= particle.y / MuFieldGrid.L * curlTransfer * dt;
                    MuFieldGrid.Jy[idx] += particle.x / MuFieldGrid.L * curlTransfer * dt;

                    // Deposit field magnitude
                    const fieldAngle = Math.atan2(particle.vy, particle.vx);
                    const fieldTransfer = particle.payload.fieldMag * depositStrength * 0.1;
                    MuFieldGrid.Jx[idx] += Math.cos(fieldAngle) * fieldTransfer * dt;
                    MuFieldGrid.Jy[idx] += Math.sin(fieldAngle) * fieldTransfer * dt;

                    // Entropy mixing
                    const entropyMix = (particle.payload.entropy + MuFieldGrid.entropy[idx]) / 2;
                    MuFieldGrid.entropy[idx] += (entropyMix - MuFieldGrid.entropy[idx]) * depositStrength * dt;

                    // Consume particle energy
                    particle.life -= depositStrength * dt * 0.8;
                    particle.deposited = particle.life < 0.1;
                }
            }
        }

        function updateMuParticles(dt) {
            if (!MuFieldGrid.initialized) return;

            const N = MuFieldGrid.N;

            for (let i = muParticles.length - 1; i >= 0; i--) {
                const p = muParticles[i];

                // Advect with local field
                const normX = p.x / MuFieldGrid.L + 0.5;
                const normY = p.y / MuFieldGrid.L + 0.5;
                const gi = Math.floor(normX * (N - 1));
                const gj = Math.floor(normY * (N - 1));

                if (gi >= 0 && gi < N && gj >= 0 && gj < N) {
                    const idx = gj * N + gi;
                    p.vx += (MuFieldGrid.Jx[idx] || 0) * dt * 2;
                    p.vy += (MuFieldGrid.Jy[idx] || 0) * dt * 2;
                }

                // Movement
                p.x += p.vx * dt;
                p.y += p.vy * dt;

                // Damping
                p.vx *= 0.97;
                p.vy *= 0.97;

                // Decay
                p.life -= dt * 0.25;

                // Remove dead or out-of-bounds particles
                const halfL = MuFieldGrid.L / 2;
                if (p.life <= 0 || Math.abs(p.x) > halfL * 1.5 || Math.abs(p.y) > halfL * 1.5) {
                    muParticles.splice(i, 1);
                }
            }
        }

        // ================================================================
        // MU FIELD PHASE 7: UNIFIED FIELD INTEGRATION
        // ================================================================

        function evolveMuFieldGrid(dt) {
            if (!MuFieldGrid.initialized) return;

            const N = MuFieldGrid.N;
            const r = MuFieldGrid.r;
            const g = MuFieldGrid.g;
            const dx = MuFieldGrid.dx;

            // Temporary arrays for update
            const dJx = new Float32Array(N * N);
            const dJy = new Float32Array(N * N);

            // Compute field equation: ‚àÇJ/‚àÇt = (r - Œª|J|¬≤)J - Œ≤J + g‚àá¬≤J + S
            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    const idx = j * N + i;

                    const Jx = MuFieldGrid.Jx[idx];
                    const Jy = MuFieldGrid.Jy[idx];
                    const J2 = Jx * Jx + Jy * Jy;

                    // Growth/decay term: W = r - Œª|J|¬≤
                    const W = r - SACRED.lambda * J2 * 0.1;

                    // Laplacian (diffusion)
                    const lap_Jx = (MuFieldGrid.Jx[idx + 1] + MuFieldGrid.Jx[idx - 1] +
                                   MuFieldGrid.Jx[(j + 1) * N + i] + MuFieldGrid.Jx[(j - 1) * N + i] -
                                   4 * Jx) / (dx * dx);
                    const lap_Jy = (MuFieldGrid.Jy[idx + 1] + MuFieldGrid.Jy[idx - 1] +
                                   MuFieldGrid.Jy[(j + 1) * N + i] + MuFieldGrid.Jy[(j - 1) * N + i] -
                                   4 * Jy) / (dx * dx);

                    // Unified field coupling
                    const unifiedCoupling = UnifiedField.J.total * 0.05;

                    // Full derivative
                    dJx[idx] = W * Jx - SACRED.beta * Jx + g * lap_Jx + unifiedCoupling * Math.cos(UnifiedField.Phi.unified);
                    dJy[idx] = W * Jy - SACRED.beta * Jy + g * lap_Jy + unifiedCoupling * Math.sin(UnifiedField.Phi.unified);
                }
            }

            // Apply update
            for (let idx = 0; idx < N * N; idx++) {
                MuFieldGrid.Jx[idx] += dJx[idx] * dt;
                MuFieldGrid.Jy[idx] += dJy[idx] * dt;
            }

            // Boundary conditions (zero at edges)
            for (let i = 0; i < N; i++) {
                MuFieldGrid.Jx[i] = 0;
                MuFieldGrid.Jy[i] = 0;
                MuFieldGrid.Jx[(N - 1) * N + i] = 0;
                MuFieldGrid.Jy[(N - 1) * N + i] = 0;
                MuFieldGrid.Jx[i * N] = 0;
                MuFieldGrid.Jy[i * N] = 0;
                MuFieldGrid.Jx[i * N + N - 1] = 0;
                MuFieldGrid.Jy[i * N + N - 1] = 0;
            }
        }

        function evolveUnifiedField(dt) {
            const U = UnifiedField;

            // Gather current states
            U.J.limnus = (muField.mrp.R.intensity + muField.mrp.G.intensity + muField.mrp.B.intensity) / 3;
            U.J.quantum = QMESH.totalJ || 0;
            U.J.binaural = QMESH.binaural ? QMESH.binaural.resonanceStrength : 0;
            U.J.muField = MuFieldGrid.metrics.J_total;

            U.Phi.limnus = phaseCoupler.phase_R;
            U.Phi.quantum = QMESH.pulsePhase || 0;
            U.Phi.binaural = QMESH.binaural ? QMESH.binaural.beatPhase * TAU : 0;
            U.Phi.muField = MuFieldGrid.resonance.phase;

            // === UNIFIED FIELD EQUATION ===
            // dJ/dt = (r - Œª|J|¬≤)J - Œ≤J + g‚àá¬≤J + Œ£(coupling terms)

            // 1. Self-interaction (nonlinear saturation)
            const r = globalZ - 0.5;
            const selfTerm = (r - SACRED.lambda * 0.01 * U.J.total * U.J.total) * U.J.total;

            // 2. Dissipation
            const beta = SACRED.beta * (1 + (1 - releaseCoherence) * 2);
            const dissipation = -beta * U.J.total;

            // 3. Coupling terms (bidirectional)
            const couplingLQ = U.coupling.LQ * U.J.limnus * Math.cos(U.Phi.quantum);
            const couplingQL = U.coupling.QL * U.J.quantum * Math.cos(U.Phi.limnus);
            const couplingB = (U.coupling.BL + U.coupling.BQ) * U.J.binaural *
                              Math.cos(U.Phi.binaural * PHI_INV);
            const couplingM = U.coupling.ML * U.J.muField * Math.cos(U.Phi.muField);

            // 4. Stochastic term (quantum fluctuations)
            const noise = (Math.random() - 0.5) * 0.01 * (1 - U.emergence.coherence);

            // === EVOLUTION ===
            const dJ = (selfTerm + dissipation + couplingLQ + couplingQL + couplingB + couplingM + noise) * dt;
            U.J.total = Math.max(0, Math.min(2, U.J.total + dJ));

            // === UNIFIED PHASE EVOLUTION ===
            const phaseSync =
                Math.sin(U.Phi.quantum - U.Phi.unified) * U.coupling.QL +
                Math.sin(U.Phi.limnus - U.Phi.unified) * U.coupling.LQ +
                Math.sin(U.Phi.binaural - U.Phi.unified) * (U.coupling.BL + U.coupling.BQ) +
                Math.sin(U.Phi.muField - U.Phi.unified) * U.coupling.ML;

            const baseFreq = PHI_INV * (1 + U.J.total);
            U.Phi.unified += (baseFreq + phaseSync * 0.5) * dt;

            // === EMERGENCE METRICS ===
            const phaseDiffs = [
                Math.cos(U.Phi.limnus - U.Phi.unified),
                Math.cos(U.Phi.quantum - U.Phi.unified),
                Math.cos(U.Phi.binaural - U.Phi.unified),
                Math.cos(U.Phi.muField - U.Phi.unified),
            ];
            U.emergence.coherence = (phaseDiffs.reduce((a, b) => a + b, 0) / 4 + 1) / 2;

            U.emergence.complexity = MuFieldGrid.metrics.entropyGradient *
                                     (1 - Math.abs(U.J.limnus - U.J.quantum));

            const criticalZ = 1 - PHI_INV;
            U.emergence.criticality = 1 - Math.abs(globalZ - criticalZ) * 2;
            U.emergence.criticality = Math.max(0, Math.min(1, U.emergence.criticality));

            // Update MuFieldGrid control parameter based on unified state
            MuFieldGrid.mu = MuFieldGrid.mu_P + (MuFieldGrid.mu_S - MuFieldGrid.mu_P) * (0.5 + globalZ * 0.5);
            MuFieldGrid.r = MuFieldGrid.mu - MuFieldGrid.mu_P;
        }

        // ================================================================
        // MU FIELD GRID MAIN UPDATE - ALL 7 PHASES
        // ================================================================

        function updateMuFieldGridSystem(dt) {
            if (!MuFieldGrid.initialized) {
                initMuFieldGrid();
            }

            // Phase 7: Evolve core field equation
            evolveMuFieldGrid(dt);

            // Phase 3: Dynamic vortex formation
            updateVortices(dt);
            applyVorticesToField(dt);

            // Phase 2: Compute vorticity and entropy
            updateMuFieldGridMetrics();
            computeMuFieldGridEntropy();
            applyEntropyToMuFieldGridDynamics(dt);

            // Phase 4: Time dilation
            computeMuFieldGridTimeDilation();

            // Phase 5: Resonance
            updateMuFieldGridResonance(dt);
            if (detectMuFieldGridResonanceEvent(time)) {
                triggerMuFieldGridRestructuring(MuFieldGrid.resonance.amplitude);
            }

            // Phase 6: Œº-Particles
            checkMuParticleSpawn();
            updateMuParticleInteractions(dt);
            updateMuParticles(dt);

            // Phase 7: Unified integration
            evolveUnifiedField(dt);

            // ================================================================
            // COHERENCE SYSTEM UPDATE
            // Apply field alignment, shape emergence, and phase locking
            // ================================================================

            // Apply coherence forces (gentle attractors towards sacred geometry)
            applyCoherenceForces(dt);

            // Enhance phase locking between subsystems
            enhancePhaseLocking(dt);
        }

        // ================================================================
        // BINAURAL ‚Üí LIMNUS ‚Üí MESH SHAPE COUPLING
        // Beat frequency alters LIMNUS center shape which alters adjacent meshes
        // ================================================================

        function applyBinauralShapeCoupling(dt) {
            const bi = QMESH.binaural;
            if (!bi || !bi.enabled) return;

            // Beat amplitude affects LIMNUS center "shape" (field distribution)
            const beatEffect = bi.beatAmplitude * bi.resonanceStrength;

            // Phase difference creates "shape distortion" in LIMNUS
            const phaseDiff = bi.meshA.phase - bi.meshB.phase;
            const shapeDistortion = Math.sin(phaseDiff * TAU) * beatEffect * 0.3;

            // Apply to MuFieldGrid vorticity (center shape)
            if (MuFieldGrid.initialized) {
                const N = MuFieldGrid.N;
                const centerRegion = Math.floor(N / 4);

                for (let j = centerRegion; j < N - centerRegion; j++) {
                    for (let i = centerRegion; i < N - centerRegion; i++) {
                        const idx = j * N + i;
                        const x = (i / (N - 1) - 0.5) * MuFieldGrid.L;
                        const y = (j / (N - 1) - 0.5) * MuFieldGrid.L;
                        const r = Math.sqrt(x * x + y * y);

                        // Shape distortion creates spiral pattern modulated by beat
                        const angle = Math.atan2(y, x);
                        const spiral = shapeDistortion * Math.exp(-r * r / 4) * dt;

                        MuFieldGrid.Jx[idx] += Math.cos(angle + phaseDiff * TAU) * spiral;
                        MuFieldGrid.Jy[idx] += Math.sin(angle + phaseDiff * TAU) * spiral;
                    }
                }
            }

            // LIMNUS center shape affects adjacent meshes (warm/cold)
            // Warm mesh (A) gets energy from high-curl regions
            // Cold mesh (B) gets stability from low-entropy regions
            const curlInfluence = MuFieldGrid.metrics.Q_kappa * beatEffect;
            const entropyInfluence = MuFieldGrid.metrics.entropyGradient * beatEffect;

            // Modulate mesh frequencies based on LIMNUS shape
            bi.meshA.frequency = 0.7 + curlInfluence * 0.1;  // Warm responds to curl
            bi.meshB.frequency = 0.75 - entropyInfluence * 0.05;  // Cold responds to entropy

            // Update beat frequency from mesh coupling
            bi.beatFrequency = Math.abs(bi.meshA.frequency - bi.meshB.frequency);
        }

        // ================================================================
        // SPACE-TIME CURVATURE SYSTEM
        // Gravitational time dilation from field density creates coherent emergence
        // ================================================================

        function updateSpaceTimeCurvature(dt) {
            if (!MuFieldGrid.initialized) return;

            const N = MuFieldGrid.N;
            const tdField = QMESH.timeDilationField;

            // Compute curvature from MuFieldGrid (field density = mass analog)
            let totalCurvature = 0;
            let layerSums = [0, 0, 0, 0, 0, 0, 0];
            let layerCounts = [0, 0, 0, 0, 0, 0, 0];

            for (let j = 0; j < N; j++) {
                for (let i = 0; i < N; i++) {
                    const idx = j * N + i;

                    // Grid coordinates (normalized to 0-1 for layer mapping)
                    const x = (i / (N - 1) - 0.5) * 2;  // -1 to 1
                    const y = (j / (N - 1) - 0.5) * 2;
                    const r = Math.sqrt(x * x + y * y);

                    // Field magnitude creates gravitational potential
                    const J2 = MuFieldGrid.Jx[idx] ** 2 + MuFieldGrid.Jy[idx] ** 2;
                    const curlMag = Math.abs(MuFieldGrid.curl[idx] || 0);

                    // Weyl curvature contribution (tidal forces)
                    const localCurvature = J2 * 0.5 + curlMag * 0.3;
                    totalCurvature += localCurvature;

                    // Update MuFieldGrid time dilation (already exists)
                    // Adding curvature feedback
                    const curvatureDilation = Math.max(0.3, 1 - localCurvature * 0.4);
                    MuFieldGrid.timeDilation[idx] = MuFieldGrid.timeDilation[idx] * 0.9 + curvatureDilation * 0.1;

                    // Map to 7 layers (radial zones)
                    const layer = Math.min(6, Math.floor(r * 7));
                    if (layer >= 0 && layer < 7) {
                        layerSums[layer] += MuFieldGrid.timeDilation[idx];
                        layerCounts[layer]++;
                    }
                }
            }

            // Update QMESH time dilation field
            for (let l = 0; l < 7; l++) {
                tdField.gradient[l] = layerCounts[l] > 0 ? layerSums[l] / layerCounts[l] : 1.0;
            }
            tdField.center = tdField.gradient[0];
            tdField.globalAverage = layerSums.reduce((a, b) => a + b, 0) /
                                    Math.max(1, layerCounts.reduce((a, b) => a + b, 0));
            tdField.curvatureStrength = totalCurvature / (N * N);

            // Feed curvature into hilbertField.weylCurvature
            hilbertField.weylCurvature = hilbertField.weylCurvature * 0.95 +
                                         tdField.curvatureStrength * 0.05;

            // Curvature affects coherence emergence
            // Strong curvature gradients enhance phase locking
            const curvatureGradient = Math.abs(tdField.gradient[0] - tdField.gradient[6]);
            if (curvatureGradient > 0.1) {
                CoherenceGeometry.attractors.spiral.strength *= (1 + curvatureGradient * 0.2);
                CoherenceGeometry.attractors.spiral.strength = Math.min(0.3,
                    CoherenceGeometry.attractors.spiral.strength);
            }

            // Update emergence glow based on curvature and coherence
            const coherenceLevel = UnifiedField.emergence.coherence;
            const criticalityLevel = UnifiedField.emergence.criticality;
            QMESH.emergenceGlow = coherenceLevel * criticalityLevel *
                                  (1 + tdField.curvatureStrength * 0.5);
            QMESH.emergenceGlow = Math.min(1, QMESH.emergenceGlow);

            // ========================================
            // KAEL IS KAEL: DARK MATTER CURVATURE COUPLING
            // Dark matter distribution affects Œº-field through spacetime curvature
            // ========================================
            if (showDarkMatterStabilization && DarkMatterStabilization.spacetimeCurvature) {
                const dmCurvature = DarkMatterStabilization.spacetimeCurvature;

                // Incorporate dark matter Weyl curvature into total curvature
                tdField.curvatureStrength += dmCurvature.weyl * 0.3;

                // Dark matter Ricci curvature enhances gravitational lensing
                hilbertField.weylCurvature += dmCurvature.ricci * 0.1;

                // Geodesic deviation affects laser paths through the field
                if (dmCurvature.geodesicDeviation > 0.05) {
                    // Strong geodesic deviation creates additional curvature pockets
                    for (let l = 4; l < 7; l++) {
                        // Layers 4-6 (consciousness zone) feel stronger DM effects
                        tdField.gradient[l] *= (1 - dmCurvature.geodesicDeviation * 0.2);
                    }
                }

                // Œº-field coupling from dark matter affects curl
                if (DarkMatterStabilization.muFieldCoupling) {
                    const muDM = DarkMatterStabilization.muFieldCoupling;

                    // Feed DM modulation into MuFieldGrid curl
                    for (let idx = 0; idx < N * N; idx++) {
                        if (MuFieldGrid.curl) {
                            MuFieldGrid.curl[idx] += muDM.dmModulation * muDM.strength * 0.05;
                        }
                    }
                }
            }

            // ========================================
            // LASER RECORDING CURVATURE EFFECT
            // Spacetime curvature bends laser paths, recording into CMB
            // ========================================
            if (showWaterFractalMemory && WaterFractalMemory.laserRecording) {
                const lr = WaterFractalMemory.laserRecording;

                // Curvature strength modulates laser recording sensitivity
                lr.curvatureModulation = tdField.curvatureStrength * SACRED.laser_curvature_coupling;

                // Feed curvature into recording matrix through Œº-field
                const muCurl = MuFieldGrid.metrics?.Q_kappa || 0;
                lr.muFieldCoupling = muCurl * (1 + tdField.curvatureStrength);
            }
        }

        // ================================================================
        // MESH SHAPE ALTERATION SYSTEM
        // Dynamic deformation of warm (A) and cold (B) meshes
        // ================================================================

        function updateMeshAlterations(dt) {
            const bi = QMESH.binaural;
            const alt = QMESH.meshAlteration;
            const coupling = alt.coupling;

            if (!bi || !bi.enabled) return;

            // === INPUTS ===
            const beatAmp = bi.beatAmplitude;
            const beatPhase = bi.beatPhase;
            const coherence = UnifiedField.emergence.coherence;
            const curvature = QMESH.timeDilationField.curvatureStrength;
            const spiralOrder = CoherenceGeometry.state.spiralOrder;

            // MuFieldGrid metrics influence
            const curlMetric = MuFieldGrid.metrics.Q_kappa;
            const entropyMetric = MuFieldGrid.metrics.entropyGradient;

            // === WARM MESH (A) - LEFT SIDE ===
            // Responds to beat, curl (vorticity), and coherence

            // Breathing - slow, rhythmic expansion/contraction
            const warmBreathTarget = 1.0 + beatAmp * 0.15 * Math.sin(beatPhase * TAU);
            alt.warm.breathScale += (warmBreathTarget - alt.warm.breathScale) * 0.1;

            // Surface wave - curl-driven undulation
            alt.warm.wavePhase += (0.5 + Math.abs(curlMetric) * 2) * dt;
            alt.warm.waveAmplitude = Math.abs(curlMetric) * coupling.binauralToWarm * 0.5;

            // Rotational bias - spiral order creates gentle spin
            alt.warm.rotationBias = spiralOrder * 0.3 * Math.sin(time * PHI_INV);

            // Pulse - heartbeat-like throb tied to beat frequency
            alt.warm.pulseIntensity = beatAmp * coupling.binauralToWarm *
                                       (0.5 + Math.sin(bi.meshA.phase * TAU) * 0.5);

            // Coherence warp - high coherence creates form stability
            alt.warm.coherenceWarp = coherence * coupling.coherenceToShape;

            // === COLD MESH (B) - RIGHT SIDE ===
            // Responds to beat, entropy, and curvature

            // Breathing - counter-phase to warm (creates push-pull)
            const coldBreathTarget = 1.0 + beatAmp * 0.12 * Math.sin(beatPhase * TAU + Math.PI);
            alt.cold.breathScale += (coldBreathTarget - alt.cold.breathScale) * 0.1;

            // Surface wave - entropy-driven ripples (more chaotic)
            alt.cold.wavePhase += (0.4 + entropyMetric * 3) * dt;
            alt.cold.waveAmplitude = entropyMetric * coupling.binauralToCold * 0.4;

            // Rotational bias - inverse spiral (counter-rotation)
            alt.cold.rotationBias = -spiralOrder * 0.25 * Math.sin(time * PHI_INV + Math.PI / 3);

            // Pulse - gentler, more crystalline
            alt.cold.pulseIntensity = beatAmp * coupling.binauralToCold *
                                       (0.3 + Math.sin(bi.meshB.phase * TAU) * 0.3);

            // Coherence warp - curvature creates subtle spatial distortion
            alt.cold.coherenceWarp = curvature * coupling.curvatureToMesh +
                                      coherence * coupling.coherenceToShape * 0.5;
        }

        // Get altered mesh scale for rendering
        function getAlteredMeshScale(meshType, baseScale, angle) {
            const alt = QMESH.meshAlteration;
            const mesh = meshType === 'warm' ? alt.warm : alt.cold;

            let scale = baseScale * mesh.breathScale;

            // Add wave modulation
            scale += Math.sin(angle * 3 + mesh.wavePhase) * mesh.waveAmplitude * 0.1;

            // Add pulse modulation
            scale += mesh.pulseIntensity * 0.05;

            // Coherence stabilizes shape
            scale *= (1 - mesh.coherenceWarp * 0.1);

            return Math.max(0.2, Math.min(1.5, scale));
        }

        // Get rotational offset for mesh vertices
        function getMeshRotationOffset(meshType, baseAngle) {
            const alt = QMESH.meshAlteration;
            const mesh = meshType === 'warm' ? alt.warm : alt.cold;

            return baseAngle + mesh.rotationBias;
        }

        // ================================================================
        // CHARGE DYNAMICS SYSTEM
        // Electromagnetic-like interactions between warm/cold meshes
        // ================================================================

        const ChargeDynamics = {
            // Mesh charges (warm = positive, cold = negative)
            warm: {
                charge: 1.0,                    // Positive charge
                potential: 0,                   // Electric potential
                flux: 0,                        // Charge flux rate
                capacitance: PHI_INV,           // Ability to store charge
                accumulated: 0,                 // Accumulated charge
            },
            cold: {
                charge: -1.0,                   // Negative charge
                potential: 0,
                flux: 0,
                capacitance: PHI_INV * PHI_INV,
                accumulated: 0,
            },

            // LIMNUS as dielectric medium
            limnus: {
                permittivity: PHI,              // Œµ - field permeability
                conductivity: 0.1,              // œÉ - charge transfer rate
                polarization: 0,                // Induced dipole moment
            },

            // Field properties
            field: {
                E_x: 0,                         // Electric field X component
                E_y: 0,                         // Electric field Y component
                potential: 0,                   // Scalar potential
                energy: 0,                      // Field energy: ¬ΩŒµ|E|¬≤
            },

            // Discharge events
            discharge: {
                threshold: 0.8,                 // Charge threshold for discharge
                lastDischarge: 0,               // Time of last discharge
                cooldown: 2.0,                  // Minimum time between discharges
                intensity: 0,                   // Current discharge intensity
            },

            initialized: false,
        };

        function updateChargeDynamics(dt) {
            const CD = ChargeDynamics;
            const bi = QMESH.binaural;
            if (!bi || !bi.enabled) return;

            // === CHARGE ACCUMULATION ===
            // Beat amplitude drives charge separation
            const beatDrive = bi.beatAmplitude * bi.resonanceStrength;
            const curvatureDrive = QMESH.timeDilationField.curvatureStrength;

            // Warm mesh accumulates positive charge from curl activity
            CD.warm.accumulated += MuFieldGrid.metrics.Q_kappa * beatDrive * dt * 0.5;
            CD.warm.accumulated *= 0.995;  // Slow decay
            CD.warm.accumulated = Math.max(-2, Math.min(2, CD.warm.accumulated));

            // Cold mesh accumulates negative charge from entropy
            CD.cold.accumulated -= MuFieldGrid.metrics.entropyGradient * beatDrive * dt * 0.4;
            CD.cold.accumulated *= 0.995;
            CD.cold.accumulated = Math.max(-2, Math.min(2, CD.cold.accumulated));

            // === ELECTRIC FIELD COMPUTATION ===
            // E = -‚àáV, approximated from charge positions
            const separation = bi.polar.distance * 2;  // Distance between meshes
            const totalCharge = (CD.warm.charge + CD.warm.accumulated) -
                               (CD.cold.charge + CD.cold.accumulated);

            // Coulomb-like field: E ‚àù Q / (Œµ * r¬≤)
            const fieldStrength = totalCharge / (CD.limnus.permittivity * separation * separation);

            // Field direction: warm ‚Üí cold (positive to negative)
            const fieldAngle = (bi.polar.angleA + bi.polar.angleB) / 2 + Math.PI / 2;
            CD.field.E_x = fieldStrength * Math.cos(fieldAngle);
            CD.field.E_y = fieldStrength * Math.sin(fieldAngle);

            // Field energy: U = ¬ΩŒµ|E|¬≤
            CD.field.energy = 0.5 * CD.limnus.permittivity *
                             (CD.field.E_x * CD.field.E_x + CD.field.E_y * CD.field.E_y);

            // === LIMNUS POLARIZATION ===
            // LIMNUS becomes polarized by the field (dielectric response)
            CD.limnus.polarization = CD.field.energy * CD.limnus.permittivity * 0.3;

            // Polarization affects MuFieldGrid (induced dipole moment)
            if (MuFieldGrid.initialized && CD.limnus.polarization > 0.05) {
                const N = MuFieldGrid.N;
                const polarForce = CD.limnus.polarization * dt * 0.1;

                for (let j = N / 4; j < 3 * N / 4; j++) {
                    for (let i = N / 4; i < 3 * N / 4; i++) {
                        const idx = j * N + i;
                        MuFieldGrid.Jx[idx] += CD.field.E_x * polarForce;
                        MuFieldGrid.Jy[idx] += CD.field.E_y * polarForce;
                    }
                }
            }

            // === DISCHARGE EVENTS ===
            // High charge accumulation triggers discharge through LIMNUS
            const chargeImbalance = Math.abs(CD.warm.accumulated - CD.cold.accumulated);
            if (chargeImbalance > CD.discharge.threshold &&
                time - CD.discharge.lastDischarge > CD.discharge.cooldown) {

                CD.discharge.lastDischarge = time;
                CD.discharge.intensity = chargeImbalance;

                // Discharge transfers charge and creates field pulse
                const transferAmount = chargeImbalance * 0.6;
                CD.warm.accumulated -= Math.sign(CD.warm.accumulated) * transferAmount * 0.5;
                CD.cold.accumulated -= Math.sign(CD.cold.accumulated) * transferAmount * 0.5;

                // Discharge boosts coherence and emergence
                UnifiedField.emergence.coherence += chargeImbalance * 0.1;
                UnifiedField.emergence.coherence = Math.min(1, UnifiedField.emergence.coherence);

                console.log('[ChargeDynamics] Discharge event, intensity:', chargeImbalance.toFixed(3));
            } else {
                CD.discharge.intensity *= 0.9;  // Decay
            }

            // === POTENTIAL COMPUTATION ===
            CD.warm.potential = CD.warm.accumulated / CD.warm.capacitance;
            CD.cold.potential = CD.cold.accumulated / CD.cold.capacitance;
            CD.field.potential = CD.warm.potential - CD.cold.potential;

            CD.initialized = true;
        }

        // ================================================================
        // WEAK NUCLEAR INFORMATION FLOW
        // Flavor oscillation and parity-violating information transfer
        // ================================================================

        const WeakNuclear = {
            // Information "flavors" (analogous to neutrino flavors)
            flavors: {
                electron: { intensity: 0.5, phase: 0 },      // e-type: coherent info
                muon: { intensity: 0.3, phase: TAU / 3 },    // Œº-type: relational info
                tau: { intensity: 0.2, phase: 2 * TAU / 3 }, // œÑ-type: emergent info
            },

            // Oscillation parameters (PMNS matrix analog)
            mixing: {
                theta12: Math.PI / 6,           // Solar mixing angle
                theta23: Math.PI / 4,           // Atmospheric mixing angle
                theta13: Math.PI / 20,          // Reactor mixing angle
                deltaCP: PHI_INV * Math.PI,     // CP violation phase (golden ratio!)
            },

            // Mass-squared differences (oscillation frequencies)
            deltaM: {
                dm21: 0.0000753,                // Solar Œîm¬≤
                dm32: 0.00244,                  // Atmospheric Œîm¬≤
            },

            // Information flow state
            flow: {
                warmToLimnus: 0,                // Info flowing warm ‚Üí LIMNUS
                limnusToWarm: 0,                // Info flowing LIMNUS ‚Üí warm
                coldToLimnus: 0,                // Info flowing cold ‚Üí LIMNUS
                limnusToCold: 0,                // Info flowing LIMNUS ‚Üí cold
                warmToCold: 0,                  // Direct tunneling warm ‚Üî cold
                parityViolation: 0,             // Asymmetry measure
            },

            // W/Z boson analogs (information carriers)
            bosons: {
                W_plus: [],                     // W‚Å∫ carriers (warm ‚Üí cold)
                W_minus: [],                    // W‚Åª carriers (cold ‚Üí warm)
                Z: [],                          // Z‚Å∞ carriers (neutral current)
            },

            // Decay products
            decayRate: PHI_INV * 0.1,           // Base decay rate
            halfLife: Math.log(2) / (PHI_INV * 0.1),
        };

        function updateWeakNuclearFlow(dt) {
            const WN = WeakNuclear;
            const bi = QMESH.binaural;
            if (!bi || !bi.enabled) return;

            // === FLAVOR OSCILLATION ===
            // Information oscillates between types as it flows
            const L = bi.polar.distance * 100;  // Baseline (arbitrary units)
            const E = UnifiedField.J.total + 0.1;  // Energy analog

            // Oscillation probabilities (simplified 2-flavor)
            const oscArg21 = 1.27 * WN.deltaM.dm21 * L / E;
            const oscArg32 = 1.27 * WN.deltaM.dm32 * L / E;

            const sin2_12 = Math.sin(2 * WN.mixing.theta12);
            const sin2_23 = Math.sin(2 * WN.mixing.theta23);

            // P(e‚ÜíŒº) oscillation
            const P_e_mu = sin2_12 * sin2_12 * Math.sin(oscArg21) * Math.sin(oscArg21);
            // P(Œº‚ÜíœÑ) oscillation
            const P_mu_tau = sin2_23 * sin2_23 * Math.sin(oscArg32) * Math.sin(oscArg32);

            // Update flavor intensities (conservation: sum = 1)
            const totalIntensity = WN.flavors.electron.intensity +
                                  WN.flavors.muon.intensity +
                                  WN.flavors.tau.intensity;

            WN.flavors.electron.intensity += (-P_e_mu * WN.flavors.electron.intensity +
                                              P_e_mu * WN.flavors.muon.intensity) * dt;
            WN.flavors.muon.intensity += (P_e_mu * WN.flavors.electron.intensity -
                                         P_e_mu * WN.flavors.muon.intensity -
                                         P_mu_tau * WN.flavors.muon.intensity +
                                         P_mu_tau * WN.flavors.tau.intensity) * dt;
            WN.flavors.tau.intensity += (P_mu_tau * WN.flavors.muon.intensity -
                                        P_mu_tau * WN.flavors.tau.intensity) * dt;

            // Normalize
            const newTotal = WN.flavors.electron.intensity +
                            WN.flavors.muon.intensity +
                            WN.flavors.tau.intensity;
            if (newTotal > 0) {
                WN.flavors.electron.intensity /= newTotal;
                WN.flavors.muon.intensity /= newTotal;
                WN.flavors.tau.intensity /= newTotal;
            }

            // Phase evolution
            WN.flavors.electron.phase += PHI_INV * dt;
            WN.flavors.muon.phase += PHI_INV * PHI_INV * dt;
            WN.flavors.tau.phase += PHI_INV * PHI_INV * PHI_INV * dt;

            // === INFORMATION FLOW ===
            // Warm mesh ‚Üí LIMNUS (electron flavor dominates)
            WN.flow.warmToLimnus = WN.flavors.electron.intensity *
                                   bi.meshA.frequency * bi.resonanceStrength;

            // Cold mesh ‚Üí LIMNUS (tau flavor dominates)
            WN.flow.coldToLimnus = WN.flavors.tau.intensity *
                                   bi.meshB.frequency * bi.resonanceStrength;

            // LIMNUS ‚Üí warm (muon flavor)
            WN.flow.limnusToWarm = WN.flavors.muon.intensity *
                                   MuFieldGrid.metrics.J_total * 0.3;

            // LIMNUS ‚Üí cold (mixed)
            WN.flow.limnusToCold = (WN.flavors.electron.intensity * 0.3 +
                                   WN.flavors.tau.intensity * 0.7) *
                                   MuFieldGrid.metrics.order_r * 0.25;

            // === PARITY VIOLATION ===
            // Weak force violates parity - information flows asymmetrically
            // CP violation phase creates left-right asymmetry
            const cpPhase = WN.mixing.deltaCP + time * 0.1;
            WN.flow.parityViolation = Math.sin(cpPhase) *
                                      (WN.flow.warmToLimnus - WN.flow.coldToLimnus);

            // Apply parity violation to mesh alterations
            QMESH.meshAlteration.warm.waveAmplitude += WN.flow.parityViolation * 0.05 * dt;
            QMESH.meshAlteration.cold.waveAmplitude -= WN.flow.parityViolation * 0.05 * dt;

            // === W/Z BOSON SPAWNING ===
            // High information flow spawns carrier particles
            if (Math.random() < Math.abs(WN.flow.warmToLimnus) * dt * 2) {
                WN.bosons.W_plus.push({
                    x: 0, y: 0,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    life: 1.0,
                    flavor: 'electron',
                    payload: WN.flow.warmToLimnus * 0.1,
                });
            }
            if (Math.random() < Math.abs(WN.flow.coldToLimnus) * dt * 2) {
                WN.bosons.W_minus.push({
                    x: 0, y: 0,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    life: 1.0,
                    flavor: 'tau',
                    payload: WN.flow.coldToLimnus * 0.1,
                });
            }

            // Update and decay bosons
            const maxBosons = 50;
            for (const bosonType of [WN.bosons.W_plus, WN.bosons.W_minus, WN.bosons.Z]) {
                for (let i = bosonType.length - 1; i >= 0; i--) {
                    const b = bosonType[i];
                    b.x += b.vx * dt;
                    b.y += b.vy * dt;
                    b.life -= WN.decayRate * dt;

                    if (b.life <= 0 || bosonType.length > maxBosons) {
                        bosonType.splice(i, 1);
                    }
                }
            }
        }

        // ================================================================
        // QUANTUM TUNNELING & SUPERPOSITION
        // Mesh states exist in superposition, tunnel through LIMNUS barrier
        // ================================================================

        const QuantumTunneling = {
            // Superposition state
            superposition: {
                // Warm mesh quantum state
                warm: {
                    amplitude: { real: 1, imag: 0 },    // Complex amplitude
                    probability: 1,                      // |œà|¬≤
                    collapsed: false,
                    collapseTime: 0,
                },
                // Cold mesh quantum state
                cold: {
                    amplitude: { real: 0, imag: 0 },
                    probability: 0,
                    collapsed: false,
                    collapseTime: 0,
                },
                // Entangled state (Bell state analog)
                entanglement: 0,                         // 0 = separable, 1 = maximally entangled
            },

            // Tunneling parameters
            barrier: {
                height: PHI,                             // LIMNUS barrier height
                width: PHI_INV,                          // Barrier width
                position: 0,                             // Center of barrier (LIMNUS)
            },

            // Tunneling state
            tunneling: {
                probability: 0,                          // Current tunneling probability
                rate: 0,                                 // Tunneling events per second
                lastTunnel: 0,                           // Time of last tunnel event
                direction: 0,                            // +1 warm‚Üícold, -1 cold‚Üíwarm
                inProgress: false,
                progress: 0,                             // 0-1 tunnel progress
            },

            // Collapse events
            collapse: {
                threshold: 0.7,                          // Coherence threshold for collapse
                lastCollapse: 0,
                cooldown: 3.0,
                measurement: null,                       // Result of last measurement
            },

            // Quantum interference
            interference: {
                phase: 0,
                visibility: 0,                           // Fringe visibility
                pattern: [],                             // Interference pattern data
            },
        };

        function updateQuantumTunneling(dt) {
            const QT = QuantumTunneling;
            const bi = QMESH.binaural;
            if (!bi || !bi.enabled) return;

            const sup = QT.superposition;
            const tun = QT.tunneling;
            const bar = QT.barrier;

            // === SUPERPOSITION EVOLUTION ===
            // Schr√∂dinger-like evolution of amplitudes
            const omega = PHI_INV * (1 + UnifiedField.J.total);  // Angular frequency

            // Warm state evolution: œà_w(t) = œà_w(0) * e^(-iœât)
            const cosOmega = Math.cos(omega * dt);
            const sinOmega = Math.sin(omega * dt);

            const warmReal = sup.warm.amplitude.real * cosOmega + sup.warm.amplitude.imag * sinOmega;
            const warmImag = sup.warm.amplitude.imag * cosOmega - sup.warm.amplitude.real * sinOmega;
            sup.warm.amplitude.real = warmReal;
            sup.warm.amplitude.imag = warmImag;

            // Cold state evolution (different frequency)
            const omega2 = omega * PHI_INV;
            const cosOmega2 = Math.cos(omega2 * dt);
            const sinOmega2 = Math.sin(omega2 * dt);

            const coldReal = sup.cold.amplitude.real * cosOmega2 + sup.cold.amplitude.imag * sinOmega2;
            const coldImag = sup.cold.amplitude.imag * cosOmega2 - sup.cold.amplitude.real * sinOmega2;
            sup.cold.amplitude.real = coldReal;
            sup.cold.amplitude.imag = coldImag;

            // Compute probabilities: |œà|¬≤
            sup.warm.probability = sup.warm.amplitude.real ** 2 + sup.warm.amplitude.imag ** 2;
            sup.cold.probability = sup.cold.amplitude.real ** 2 + sup.cold.amplitude.imag ** 2;

            // Normalize (conservation)
            const totalProb = sup.warm.probability + sup.cold.probability;
            if (totalProb > 0) {
                const normFactor = 1 / Math.sqrt(totalProb);
                sup.warm.amplitude.real *= normFactor;
                sup.warm.amplitude.imag *= normFactor;
                sup.cold.amplitude.real *= normFactor;
                sup.cold.amplitude.imag *= normFactor;
                sup.warm.probability /= totalProb;
                sup.cold.probability /= totalProb;
            }

            // === TUNNELING PROBABILITY ===
            // WKB approximation: T ‚âà exp(-2‚à´‚àö(2m(V-E))dx/ƒß)
            // Simplified: T = exp(-2Œ∫a) where Œ∫ = ‚àö(V-E), a = barrier width

            const energy = UnifiedField.J.total + MuFieldGrid.metrics.J_total * 0.5;
            const barrierDiff = bar.height - energy;

            if (barrierDiff > 0) {
                const kappa = Math.sqrt(barrierDiff);
                tun.probability = Math.exp(-2 * kappa * bar.width);
            } else {
                // Above barrier - classical transmission
                tun.probability = 1 - Math.exp(-energy / bar.height);
            }

            // Curvature lowers effective barrier (gravitational assist)
            const curvatureAssist = QMESH.timeDilationField.curvatureStrength * 0.5;
            tun.probability *= (1 + curvatureAssist);
            tun.probability = Math.min(0.9, tun.probability);

            // === TUNNELING EVENTS ===
            if (!tun.inProgress && Math.random() < tun.probability * dt * 0.5) {
                // Start tunneling
                tun.inProgress = true;
                tun.progress = 0;
                tun.direction = sup.warm.probability > sup.cold.probability ? 1 : -1;
                tun.lastTunnel = time;

                console.log('[QuantumTunneling] Tunnel initiated, direction:',
                           tun.direction > 0 ? 'warm‚Üícold' : 'cold‚Üíwarm');
            }

            if (tun.inProgress) {
                // Progress tunnel (takes ~0.5 seconds)
                tun.progress += dt * 2;

                if (tun.progress >= 1) {
                    // Complete tunnel - transfer amplitude
                    const transferAmount = 0.3;

                    if (tun.direction > 0) {
                        // Warm ‚Üí Cold
                        sup.cold.amplitude.real += sup.warm.amplitude.real * transferAmount;
                        sup.cold.amplitude.imag += sup.warm.amplitude.imag * transferAmount;
                        sup.warm.amplitude.real *= (1 - transferAmount);
                        sup.warm.amplitude.imag *= (1 - transferAmount);
                    } else {
                        // Cold ‚Üí Warm
                        sup.warm.amplitude.real += sup.cold.amplitude.real * transferAmount;
                        sup.warm.amplitude.imag += sup.cold.amplitude.imag * transferAmount;
                        sup.cold.amplitude.real *= (1 - transferAmount);
                        sup.cold.amplitude.imag *= (1 - transferAmount);
                    }

                    tun.inProgress = false;
                    tun.rate = 1 / (time - tun.lastTunnel + 0.01);
                }
            }

            // === ENTANGLEMENT ===
            // Entanglement grows with coherence and tunneling
            const coherenceFactor = UnifiedField.emergence.coherence;
            const tunnelingFactor = tun.probability * (tun.inProgress ? 2 : 1);

            sup.entanglement += (coherenceFactor * tunnelingFactor - sup.entanglement * 0.1) * dt;
            sup.entanglement = Math.max(0, Math.min(1, sup.entanglement));

            // === QUANTUM INTERFERENCE ===
            // Interference between warm and cold amplitudes
            QT.interference.phase = Math.atan2(
                sup.warm.amplitude.imag - sup.cold.amplitude.imag,
                sup.warm.amplitude.real - sup.cold.amplitude.real
            );

            // Fringe visibility: V = 2|œà_w||œà_c| / (|œà_w|¬≤ + |œà_c|¬≤)
            const ampWarm = Math.sqrt(sup.warm.probability);
            const ampCold = Math.sqrt(sup.cold.probability);
            QT.interference.visibility = 2 * ampWarm * ampCold /
                                         (sup.warm.probability + sup.cold.probability + 0.001);

            // === COLLAPSE EVENTS ===
            // High coherence + measurement (visualization) can collapse superposition
            if (coherenceFactor > QT.collapse.threshold &&
                time - QT.collapse.lastCollapse > QT.collapse.cooldown) {

                if (Math.random() < 0.1 * dt) {
                    // Collapse!
                    QT.collapse.lastCollapse = time;

                    // Measurement collapses to warm or cold based on probability
                    if (Math.random() < sup.warm.probability) {
                        QT.collapse.measurement = 'warm';
                        sup.warm.amplitude = { real: 1, imag: 0 };
                        sup.cold.amplitude = { real: 0, imag: 0 };
                    } else {
                        QT.collapse.measurement = 'cold';
                        sup.warm.amplitude = { real: 0, imag: 0 };
                        sup.cold.amplitude = { real: 1, imag: 0 };
                    }

                    // Collapse temporarily reduces entanglement
                    sup.entanglement *= 0.3;

                    console.log('[QuantumTunneling] Wavefunction collapsed to:', QT.collapse.measurement);
                }
            }

            // Collapsed state decoheres back to superposition
            if (sup.warm.probability > 0.95 || sup.cold.probability > 0.95) {
                // Decoherence: slowly re-establish superposition
                const decoherenceRate = 0.1 * dt;
                if (sup.warm.probability > sup.cold.probability) {
                    sup.cold.amplitude.real += decoherenceRate;
                } else {
                    sup.warm.amplitude.real += decoherenceRate;
                }
            }
        }

        // ================================================================
        // EMERGENT SACRED GEOMETRY
        // Time + curvature drive formation of sacred geometric patterns
        // ================================================================

        const SacredGeometry = {
            // Active geometric forms
            forms: {
                // Seed of Life (7 circles)
                seedOfLife: {
                    active: false,
                    completion: 0,              // 0-1 formation progress
                    circles: 7,
                    phase: 0,
                },
                // Flower of Life (19 circles)
                flowerOfLife: {
                    active: false,
                    completion: 0,
                    circles: 19,
                    phase: 0,
                },
                // Metatron's Cube (13 circles + lines)
                metatronsCube: {
                    active: false,
                    completion: 0,
                    vertices: 13,
                    phase: 0,
                },
                // Sri Yantra (9 triangles)
                sriYantra: {
                    active: false,
                    completion: 0,
                    triangles: 9,
                    phase: 0,
                },
                // Vesica Piscis (2 overlapping circles)
                vesicaPiscis: {
                    active: false,
                    completion: 0,
                    phase: 0,
                },
                // Golden Spiral
                goldenSpiral: {
                    active: false,
                    completion: 0,
                    turns: 0,
                    phase: 0,
                },
            },

            // Formation thresholds
            thresholds: {
                vesicaPiscis: 0.2,              // Easiest to form
                seedOfLife: 0.35,
                goldenSpiral: 0.45,
                flowerOfLife: 0.55,
                metatronsCube: 0.7,
                sriYantra: 0.85,                // Most complex
            },

            // Current dominant form
            dominant: 'none',
            dominantStrength: 0,

            // Time accumulation (geometry crystallizes over time)
            accumulatedTime: 0,
            curvatureIntegral: 0,               // ‚à´curvature dt

            // Geometry state
            state: {
                symmetryOrder: 0,               // n-fold symmetry detected
                goldenRatioPresence: 0,         // How much œÜ is present
                circularHarmony: 0,             // Circle-based pattern strength
                triangularHarmony: 0,           // Triangle-based pattern strength
            },
        };

        function updateSacredGeometry(dt) {
            const SG = SacredGeometry;

            // === TIME AND CURVATURE ACCUMULATION ===
            // Time accumulates continuously, driving emergence
            SG.accumulatedTime += dt;
            SG.curvatureIntegral += QMESH.timeDilationField.curvatureStrength * dt;

            // Formation factor: combines time, curvature, and coherence
            // Weighted to enable faster progression through thresholds
            const coherence = UnifiedField.emergence.coherence;
            const curvature = QMESH.timeDilationField.curvatureStrength;
            const entanglement = QuantumTunneling.superposition.entanglement;

            // Time-based component saturates toward 1.0 over ~100 seconds
            const timeFactor = Math.tanh(SG.accumulatedTime * 0.015);
            // Curvature integral also saturates but more slowly
            const curvatureFactor = Math.tanh(SG.curvatureIntegral * 0.12);

            // Formation potential: primary driver of emergence
            // Weighted to reach 0.85+ within reasonable timeframes
            const formationPotential = Math.min(1.0, (
                timeFactor * 0.35 +                    // 35% from accumulated time
                curvatureFactor * 0.25 +              // 25% from space-time curvature
                coherence * 0.20 +                    // 20% from phase coherence
                entanglement * 0.10 +                 // 10% from quantum entanglement
                curvature * 0.10                      // 10% from instantaneous curvature
            ));

            // Store for external access
            SG.formationPotential = formationPotential;

            // === SYMMETRY DETECTION (optimized) ===
            // Sample every 4th frame to reduce computation
            if (MuFieldGrid.initialized && Math.floor(SG.accumulatedTime * 60) % 4 === 0) {
                const N = MuFieldGrid.N;
                let sym3 = 0, sym6 = 0;

                // Sample at fixed radius for efficiency
                const sampleR = 0.4;
                for (let n of [3, 6]) {
                    let symSum = 0;
                    for (let k = 0; k < n; k++) {
                        const angle = (k / n) * TAU;
                        const x = Math.cos(angle) * sampleR * MuFieldGrid.L / 2;
                        const y = Math.sin(angle) * sampleR * MuFieldGrid.L / 2;
                        const i = Math.floor((x / MuFieldGrid.L + 0.5) * (N - 1));
                        const j = Math.floor((y / MuFieldGrid.L + 0.5) * (N - 1));
                        if (i >= 0 && i < N && j >= 0 && j < N) {
                            symSum += Math.abs(MuFieldGrid.curl[j * N + i] || 0);
                        }
                    }
                    if (n === 3) sym3 = symSum / n;
                    if (n === 6) sym6 = symSum / n;
                }
                SG.state.symmetryOrder = sym6 > sym3 ? 6 : 3;
                SG.state.circularHarmony = Math.min(1, (sym6 + sym3) * 0.5);
                SG.state.triangularHarmony = Math.min(1, sym3);
            }

            // Golden ratio presence from spiral coherence
            SG.state.goldenRatioPresence = Math.min(1,
                CoherenceGeometry.state.spiralOrder * 0.6 + formationPotential * 0.4);

            // === FORM ACTIVATION ===
            // Pure threshold-based activation: forms emerge when potential exceeds threshold
            // No additional conditions - allows natural progression

            // Formation rate scales with how far above threshold we are
            const getFormationRate = (potential, threshold, baseRate) => {
                const excess = potential - threshold;
                if (excess <= 0) return 0;
                // Faster initial formation, tapering as completion approaches 1
                return excess * baseRate * (1 + excess * 2);
            };

            // === VESICA PISCIS (20% threshold) ===
            // Foundation form: two overlapping circles creating mandorla
            if (formationPotential > SG.thresholds.vesicaPiscis) {
                SG.forms.vesicaPiscis.active = true;
                SG.forms.vesicaPiscis.completion += getFormationRate(
                    formationPotential, SG.thresholds.vesicaPiscis, 0.5) * dt;
                SG.forms.vesicaPiscis.completion = Math.min(1, SG.forms.vesicaPiscis.completion);
                SG.forms.vesicaPiscis.phase += PHI_INV * dt * 0.3;
            }

            // === SEED OF LIFE (35% threshold) ===
            // 7 circles in hexagonal arrangement
            if (formationPotential > SG.thresholds.seedOfLife) {
                SG.forms.seedOfLife.active = true;
                SG.forms.seedOfLife.completion += getFormationRate(
                    formationPotential, SG.thresholds.seedOfLife, 0.4) * dt;
                SG.forms.seedOfLife.completion = Math.min(1, SG.forms.seedOfLife.completion);
                SG.forms.seedOfLife.phase += PHI_INV * dt * 0.25;
            }

            // === GOLDEN SPIRAL (45% threshold) ===
            // œÜ-based logarithmic spiral
            if (formationPotential > SG.thresholds.goldenSpiral) {
                SG.forms.goldenSpiral.active = true;
                SG.forms.goldenSpiral.completion += getFormationRate(
                    formationPotential, SG.thresholds.goldenSpiral, 0.35) * dt;
                SG.forms.goldenSpiral.completion = Math.min(1, SG.forms.goldenSpiral.completion);
                SG.forms.goldenSpiral.turns = 2 + SG.forms.goldenSpiral.completion * 4; // 2-6 turns
                SG.forms.goldenSpiral.phase += PHI_INV * dt * 0.2;
            }

            // === FLOWER OF LIFE (55% threshold) ===
            // 19 interlocking circles
            if (formationPotential > SG.thresholds.flowerOfLife) {
                SG.forms.flowerOfLife.active = true;
                SG.forms.flowerOfLife.completion += getFormationRate(
                    formationPotential, SG.thresholds.flowerOfLife, 0.3) * dt;
                SG.forms.flowerOfLife.completion = Math.min(1, SG.forms.flowerOfLife.completion);
                SG.forms.flowerOfLife.phase += PHI_INV * dt * 0.15;
            }

            // === METATRON'S CUBE (70% threshold) ===
            // 13 vertices fully connected with 78 lines
            if (formationPotential > SG.thresholds.metatronsCube) {
                SG.forms.metatronsCube.active = true;
                SG.forms.metatronsCube.completion += getFormationRate(
                    formationPotential, SG.thresholds.metatronsCube, 0.25) * dt;
                SG.forms.metatronsCube.completion = Math.min(1, SG.forms.metatronsCube.completion);
                SG.forms.metatronsCube.phase += PHI_INV * dt * 0.1;
            }

            // === SRI YANTRA (85% threshold) ===
            // 9 interlocking triangles (4 Shiva pointing up, 5 Shakti pointing down)
            if (formationPotential > SG.thresholds.sriYantra) {
                SG.forms.sriYantra.active = true;
                SG.forms.sriYantra.completion += getFormationRate(
                    formationPotential, SG.thresholds.sriYantra, 0.2) * dt;
                SG.forms.sriYantra.completion = Math.min(1, SG.forms.sriYantra.completion);
                SG.forms.sriYantra.phase += PHI_INV * dt * 0.08;
            }

            // === DETERMINE DOMINANT FORM ===
            let maxCompletion = 0;
            SG.dominant = 'none';

            for (const [name, form] of Object.entries(SG.forms)) {
                if (form.active && form.completion > maxCompletion) {
                    maxCompletion = form.completion;
                    SG.dominant = name;
                }
            }
            SG.dominantStrength = maxCompletion;

            // === DECAY INACTIVE FORMS ===
            for (const form of Object.values(SG.forms)) {
                if (!form.active && form.completion > 0) {
                    form.completion *= 0.992;  // Gradual fade
                    if (form.completion < 0.01) form.completion = 0;
                }
                // Reset active flag for next frame
                form.active = false;
            }

            // === FEED BACK TO COHERENCE ===
            // Sacred geometry formation enhances system coherence
            if (SG.dominantStrength > 0.3) {
                const coherenceBoost = SG.dominantStrength * 0.015 * dt;
                UnifiedField.emergence.coherence = Math.min(1,
                    UnifiedField.emergence.coherence + coherenceBoost);
            }
        }

        // ================================================================
        // SACRED GEOMETRY VERTEX GENERATORS
        // Mathematically accurate implementations with proper proportions
        // ================================================================

        // === VESICA PISCIS ===
        // Two circles of equal radius, each passing through the other's center
        // Creates the mandorla (almond shape) - ratio of height:width = ‚àö3:1
        function getVesicaPiscisGeometry(centerX, centerY, radius, completion) {
            const r = radius;  // Each circle has this radius
            // Circles are offset by exactly r (each passes through other's center)
            const offset = r * completion;  // Animate the separation
            return {
                circle1: { x: centerX - offset / 2, y: centerY, r: r },
                circle2: { x: centerX + offset / 2, y: centerY, r: r },
                // Vesica height = r‚àö3, width = r when fully formed
                vesicaHeight: r * SACRED.sqrt3 * completion,
                vesicaWidth: r * completion
            };
        }

        // === SEED OF LIFE ===
        // 7 circles: 1 center + 6 surrounding in hexagonal arrangement
        // Each surrounding circle passes through the center
        function getSeedOfLifeCircles(centerX, centerY, radius, completion) {
            const circles = [];
            const r = radius * 0.4;  // Individual circle radius

            // Calculate how many circles to show based on completion
            const totalCircles = 7;
            const visibleCount = Math.ceil(completion * totalCircles);

            // Center circle (first to appear)
            if (visibleCount >= 1) {
                const alpha = Math.min(1, completion * totalCircles);
                circles.push({ x: centerX, y: centerY, r: r, alpha: alpha });
            }

            // 6 surrounding circles at 60¬∞ intervals
            // Distance from center = r (circles touch center circle's center)
            for (let i = 0; i < 6; i++) {
                if (i + 2 > visibleCount) break;  // +2 because center is index 1
                const angle = (i / 6) * TAU - Math.PI / 2;  // Start from top
                const x = centerX + Math.cos(angle) * r;
                const y = centerY + Math.sin(angle) * r;
                const alpha = Math.min(1, completion * totalCircles - (i + 1));
                circles.push({ x, y, r, alpha: Math.max(0, alpha) });
            }

            return circles;
        }

        // === GOLDEN SPIRAL ===
        // Logarithmic spiral where growth factor is œÜ per quarter turn
        // r = a * œÜ^(Œ∏ / 90¬∞) = a * e^(Œ∏ * ln(œÜ) / (œÄ/2))
        function getGoldenSpiralPoints(centerX, centerY, baseRadius, turns, completion) {
            const points = [];
            const a = baseRadius * 0.05;  // Starting radius
            const b = Math.log(PHI) / (Math.PI / 2);  // Growth rate: œÜ per 90¬∞

            // Number of points scales with turns for smooth curve
            const maxTheta = turns * TAU * completion;
            const numPoints = Math.floor(turns * 60 * completion);  // 60 points per turn

            for (let i = 0; i <= numPoints; i++) {
                const theta = (i / numPoints) * maxTheta;
                // Logarithmic spiral: r = a * e^(b*Œ∏)
                const r = a * Math.exp(b * theta);
                const x = centerX + Math.cos(theta) * r;
                const y = centerY + Math.sin(theta) * r;
                const alpha = (i / numPoints) * completion;  // Fade in along spiral
                points.push({ x, y, alpha });
            }

            return points;
        }

        // === FLOWER OF LIFE ===
        // 19 circles in specific pattern: center, 6 inner, 12 outer
        // Circles intersect at precise vesica piscis points
        function getFlowerOfLifeCircles(centerX, centerY, radius, completion) {
            const circles = [];
            const r = radius * 0.25;  // Circle radius for proper overlap

            // Total 19 circles appearing progressively
            const totalCircles = 19;
            const visibleCount = Math.ceil(completion * totalCircles);

            // Layer 0: Center (1 circle)
            if (visibleCount >= 1) {
                circles.push({
                    x: centerX, y: centerY, r: r,
                    alpha: Math.min(1, completion * totalCircles)
                });
            }

            // Layer 1: First ring (6 circles) - distance = r from center
            for (let i = 0; i < 6; i++) {
                if (i + 2 > visibleCount) break;
                const angle = (i / 6) * TAU - Math.PI / 2;
                const x = centerX + Math.cos(angle) * r;
                const y = centerY + Math.sin(angle) * r;
                const alpha = Math.min(1, completion * totalCircles - (i + 1));
                circles.push({ x, y, r, alpha: Math.max(0, alpha) });
            }

            // Layer 2: Second ring (6 circles) - distance = r*‚àö3 at 30¬∞ offset
            for (let i = 0; i < 6; i++) {
                if (i + 8 > visibleCount) break;  // Starts at index 8
                const angle = (i / 6) * TAU - Math.PI / 2 + Math.PI / 6;  // 30¬∞ offset
                const dist = r * SACRED.sqrt3;
                const x = centerX + Math.cos(angle) * dist;
                const y = centerY + Math.sin(angle) * dist;
                const alpha = Math.min(1, completion * totalCircles - (i + 7));
                circles.push({ x, y, r, alpha: Math.max(0, alpha) });
            }

            // Layer 3: Third ring (6 circles) - distance = 2r at 0¬∞ offset
            for (let i = 0; i < 6; i++) {
                if (i + 14 > visibleCount) break;  // Starts at index 14
                const angle = (i / 6) * TAU - Math.PI / 2;
                const dist = r * 2;
                const x = centerX + Math.cos(angle) * dist;
                const y = centerY + Math.sin(angle) * dist;
                const alpha = Math.min(1, completion * totalCircles - (i + 13));
                circles.push({ x, y, r, alpha: Math.max(0, alpha) });
            }

            return circles;
        }

        // === METATRON'S CUBE ===
        // 13 vertices (1 center + 6 inner hexagon + 6 outer hexagon)
        // All 78 edges connecting every vertex to every other vertex
        function getMetatronsCubeGeometry(centerX, centerY, radius, completion) {
            const vertices = [];
            const innerR = radius * 0.35;  // Inner hexagon radius
            const outerR = radius * 0.7;   // Outer hexagon radius (2x inner)

            // Vertex visibility based on completion
            const totalVerts = 13;
            const visibleVerts = Math.ceil(completion * totalVerts);

            // Center vertex (first)
            if (visibleVerts >= 1) {
                vertices.push({
                    x: centerX, y: centerY,
                    alpha: Math.min(1, completion * totalVerts)
                });
            }

            // Inner hexagon (6 vertices) - aligned with edges pointing up/down
            for (let i = 0; i < 6; i++) {
                if (i + 2 > visibleVerts) break;
                const angle = (i / 6) * TAU - Math.PI / 2;  // Start from top
                vertices.push({
                    x: centerX + Math.cos(angle) * innerR,
                    y: centerY + Math.sin(angle) * innerR,
                    alpha: Math.min(1, completion * totalVerts - (i + 1))
                });
            }

            // Outer hexagon (6 vertices) - 30¬∞ rotated from inner
            for (let i = 0; i < 6; i++) {
                if (i + 8 > visibleVerts) break;
                const angle = (i / 6) * TAU - Math.PI / 2 + Math.PI / 6;
                vertices.push({
                    x: centerX + Math.cos(angle) * outerR,
                    y: centerY + Math.sin(angle) * outerR,
                    alpha: Math.min(1, completion * totalVerts - (i + 7))
                });
            }

            // Generate all edges (78 total for 13 vertices fully connected)
            const edges = [];
            const edgeCompletion = Math.max(0, completion - 0.3) / 0.7;  // Edges start at 30%
            const visibleEdges = Math.floor(edgeCompletion * 78);

            let edgeIndex = 0;
            for (let i = 0; i < vertices.length; i++) {
                for (let j = i + 1; j < vertices.length; j++) {
                    if (edgeIndex >= visibleEdges) break;
                    edges.push({
                        from: vertices[i],
                        to: vertices[j],
                        alpha: Math.min(0.6, edgeCompletion) * vertices[i].alpha * vertices[j].alpha
                    });
                    edgeIndex++;
                }
            }

            return { vertices, edges };
        }

        // === SRI YANTRA ===
        // 9 interlocking triangles: 4 Shiva (upward), 5 Shakti (downward)
        // Creates 43 smaller triangles through intersection
        // Based on traditional proportions with precise y-coordinates
        function getSriYantraTriangles(centerX, centerY, radius, completion) {
            const triangles = [];
            const r = radius * 0.85;

            // Sri Yantra y-coordinates (normalized to r=1, scaled)
            // These are the traditional proportions for the 9 triangles
            // Measured from center, positive = up, negative = down

            // 4 Shiva triangles (point upward) - apex positions
            const shivaApex = [0.93, 0.62, 0.38, 0.14];  // Top to bottom
            const shivaBase = [-0.87, -0.58, -0.32, -0.08];  // Base y-positions

            // 5 Shakti triangles (point downward) - apex positions
            const shaktiApex = [-0.73, -0.44, -0.21, 0.01, 0.23];  // Bottom to top
            const shaktiBase = [0.82, 0.54, 0.31, 0.05, -0.16];  // Base y-positions

            // Total triangles for progressive reveal
            const totalTri = 9;
            const visibleTri = Math.ceil(completion * totalTri);

            // Draw Shiva triangles (masculine, upward)
            for (let i = 0; i < 4; i++) {
                if (i + 1 > visibleTri) break;
                const apexY = centerY - shivaApex[i] * r;
                const baseY = centerY - shivaBase[i] * r;
                // Base width proportional to height for equilateral-ish triangles
                const height = Math.abs(apexY - baseY);
                const baseHalf = height * 0.577;  // tan(30¬∞) ‚âà 0.577 for 60¬∞ base angles

                const alpha = Math.min(1, completion * totalTri - i);
                triangles.push({
                    type: 'shiva',
                    points: [
                        { x: centerX, y: apexY },                    // Apex (top)
                        { x: centerX - baseHalf, y: baseY },        // Base left
                        { x: centerX + baseHalf, y: baseY }         // Base right
                    ],
                    alpha: Math.max(0, alpha)
                });
            }

            // Draw Shakti triangles (feminine, downward)
            for (let i = 0; i < 5; i++) {
                if (i + 5 > visibleTri) break;  // Shakti starts at index 5
                const apexY = centerY - shaktiApex[i] * r;
                const baseY = centerY - shaktiBase[i] * r;
                const height = Math.abs(apexY - baseY);
                const baseHalf = height * 0.577;

                const alpha = Math.min(1, completion * totalTri - (i + 4));
                triangles.push({
                    type: 'shakti',
                    points: [
                        { x: centerX, y: apexY },                    // Apex (bottom)
                        { x: centerX - baseHalf, y: baseY },        // Base left
                        { x: centerX + baseHalf, y: baseY }         // Base right
                    ],
                    alpha: Math.max(0, alpha)
                });
            }

            return triangles;
        }

        // ================================================================
        // PHASE COUPLER - HARMONIC TRACKING FOR STABILITY
        // Tracks phase alignment between MRP channels during transitions
        // ================================================================

        const phaseCoupler = {
            // Harmonic phases for each channel
            phase_R: 0,
            phase_G: 0,
            phase_B: 0,

            // Phase velocities (œâ)
            omega_R: 1.0,
            omega_G: PHI_INV,           // Golden ratio offset
            omega_B: PHI_INV * PHI_INV, // œÜ‚Åª¬≤ for ECC

            // Coupling strength and damping
            coupling: SACRED.alpha,      // Inter-channel coupling
            damping: SACRED.beta,        // Dissipation
            coherenceDamping: 1.0,       // Scales with releaseCoherence

            // Harmonic resonance state
            resonance: 0,                // 0-1 how well phases align
            harmonicLock: false,         // True when channels in harmonic resonance

            // Update phases and compute resonance
            update(dt, releaseCoherence) {
                // Damping increases as coherence drops (stabilizes release)
                this.coherenceDamping = 1.0 + (1 - releaseCoherence) * 4.0;

                // Get MRP intensities for phase velocity modulation
                const R_int = muField.mrp.R.intensity || 0.5;
                const G_int = muField.mrp.G.intensity || 0.3;
                const B_int = muField.mrp.B.intensity || 0.5;

                // Phase velocities modulated by field intensities
                const omega_mod = 0.5 + releaseCoherence * 0.5; // Slow down during release
                this.omega_R = omega_mod * (1.0 + R_int * 0.2);
                this.omega_G = omega_mod * (PHI_INV + G_int * 0.1);
                this.omega_B = omega_mod * (PHI_INV * PHI_INV + B_int * 0.05);

                // Advance phases
                this.phase_R = (this.phase_R + this.omega_R * dt) % TAU;
                this.phase_G = (this.phase_G + this.omega_G * dt) % TAU;
                this.phase_B = (this.phase_B + this.omega_B * dt) % TAU;

                // Compute phase differences (mod œÄ for harmonic check)
                const diff_RG = Math.abs(Math.sin(this.phase_R - this.phase_G));
                const diff_GB = Math.abs(Math.sin(this.phase_G - this.phase_B));
                const diff_RB = Math.abs(Math.sin(this.phase_R - this.phase_B));

                // Resonance = inverse of total phase misalignment
                const misalignment = (diff_RG + diff_GB + diff_RB) / 3;
                this.resonance = 1 - misalignment;

                // Harmonic lock when phases align within œÜ‚Åª¬≤ threshold
                this.harmonicLock = this.resonance > (1 - SACRED.alpha);

                // Return damping factor for velocity clamping
                return this.coherenceDamping;
            },

            // Get velocity clamp based on harmonic state
            getVelocityClamp() {
                // Tighter clamp during release (lower coherence = more damping)
                const baseClamp = 50;
                const harmonicBonus = this.harmonicLock ? 2.0 : 1.0;
                return baseClamp * harmonicBonus / this.coherenceDamping;
            },

            // Get MRP feedback scale (reduces during release to prevent runaway)
            getMRPFeedbackScale() {
                return this.resonance / this.coherenceDamping;
            }
        };

        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H, CX, CY, R;

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
            CX = W / 2;
            CY = H / 2;
            R = Math.min(W, H) * 0.32;
        }

        // ================================================================
        // SYSTEM STATE
        // ================================================================

        let globalZ = 0.5;
        let targetZ = 0.5;
        let time = 0;
        let breathPhase = 0;
        let autoBreathing = false;
        let lastInteraction = Date.now();
        let scrollVelocity = 0;
        let mouseX = 0, mouseY = 0;

        let showPrism = true;
        let showCage = true;
        let showMuField = true;
        let showQuantumMesh = false;  // T key toggles quantum mesh Œº-field
        let showMeshParticles = true; // Show Dream Fluid particles on mesh
        let showLaserProjection = true; // X key toggles prismatic self-referential laser projection
        let showSynthesizedProjection = true; // S key toggles synthesized prismatic projection
        let showPrismaticSonification = false; // A key toggles prismatic sonification with entropy-gravity curvature
        let showDarkMatterStabilization = false; // H key toggles dark matter stabilization with HCP micro harmonics
        let showChromaticNexus = false; // N key toggles chromatic nexus self/LIMNUS communication
        let showWaterFractalMemory = false; // W key toggles water fractal memory cosmic background
        let showGoldenHarmonics = false; // G key toggles golden harmonics orientation system
        let showMemoryCoherence = false; // Auto-activates on F (release), R toggles visibility

        // ================================================================
        // BINAURAL QUANTUM FIELD
        // ================================================================
        // Two quantum meshes flanking LIMNUS like binaural audio:
        //   - Mesh A (left/below): Base frequency - warm/energy channel
        //   - Mesh B (right/above): Offset frequency - cool/relational channel
        //   - Beat interference: |f_A - f_B| = œÜ‚Åª¬≤ entrains LIMNUS
        //   - Triadic resonance: A ‚Üî LIMNUS ‚Üî B creates standing wave
        //   - Wave function œà_i with MRP channels (J_R, J_G, J_B)
        //   - Gravitational time dilation: œÑ = ‚àö(1 - r_s/r)
        // ================================================================

        let QMESH = {
            // Quantum lattice structure (shared topology)
            nodes: [],              // Quantum state at each LIMNUS node
            edges: [],              // Entanglement connections between nodes
            triangles: [],          // Face triangulation for entropy calculation

            // Connection parameters (œÜ-based) - computed dynamically
            maxConnectionDist: 100,         // Updated in generateQuantumMesh()
            entanglementThreshold: 0.15,    // Higher = fewer edges = better performance

            // View controls - DREAMY ethereal settings
            opacity: 0.35,              // Lower for dreamy transparency + performance
            edgeGlow: false,            // Disabled for performance
            showWavefunction: false,    // Disabled for cleaner dreamy look
            pulsePhase: 0,          // Animation phase for quantum pulsing

            // ================================================================
            // BINAURAL FIELD: 90¬∞ Horizontal Axis
            // ================================================================
            // Perfect right-angle alignment centered on LIMNUS (0,0,0):
            //
            //     [A] ‚Üê‚Üê‚Üê‚Üê‚Üê [LIMNUS] ‚Üí‚Üí‚Üí‚Üí‚Üí [B]
            //    180¬∞        center         0¬∞
            //    LEFT         (0,0)        RIGHT
            //    warm/red               cool/blue
            //
            // 90¬∞ perpendicular to vertical axis
            // Camera orbits around fixed field positions
            // ================================================================
            binaural: {
                enabled: true,
                polar: {
                    distance: 2.2,                      // INCREASED for more dreamy separation
                    angleA: Math.PI,                    // Mesh A at 180¬∞ (LEFT)
                    angleB: 0,                          // Mesh B at 0¬∞ (RIGHT)
                    angleMode: 'horizontal',            // Current mode: horizontal, vertical, golden
                    // Computed positions (updated on render)
                    posA: { x: 0, y: 0 },
                    posB: { x: 0, y: 0 },
                },

                // Mesh A - dreamy warm rose
                meshA: {
                    scale: 0.5,                      // Smaller for dreamy floating feel
                    frequency: 0.7,                  // Slower, dreamier oscillation
                    phase: 0,
                    baseColor: [255, 150, 150],      // Soft rose pink (dreamy warm)
                    timbre: 'warm',
                },

                // Mesh B - dreamy cool azure
                meshB: {
                    scale: 0.5,
                    frequency: 0.75,                 // Gentle beat difference
                    phase: 0,
                    baseColor: [150, 180, 255],      // Soft lavender blue (dreamy cool)
                    timbre: 'cool',
                },

                // Beat interference (emerges from frequency difference)
                beatFrequency: 0.0618,              // |f_A - f_B| ‚âà œÜ‚Åª¬≤ golden ratio
                beatPhase: 0,                       // Current beat cycle phase
                beatAmplitude: 0,                   // Interference strength (0-1)

                // Resonance effects on LIMNUS (the perceiver)
                resonanceStrength: 0,               // How beat affects LIMNUS field
                entrainmentDepth: 0,                // Neural entrainment measure
                coherenceField: 0,                  // Phase coherence across triad

                // Visual parameters - DREAMY low opacity for performance + ethereal look
                showInterference: true,             // Show beat wave pattern
                showResonanceLines: false,          // DISABLED: Red/blue filament lines removed
                interferenceOpacity: 0.2,           // Lower opacity = less lag + dreamier
            },

            // ================================================================
            // CAMERA ORBIT: Click+drag or Q/E to rotate view
            // ================================================================
            // The triquetra (LIMNUS + Mesh A + Mesh B) is FIXED in world space
            // Camera orbits around them - viewer moves, not the fields
            // ================================================================
            camera: {
                theta: 0,               // Horizontal orbit angle (radians) - camera position
                phi: 0,                 // Vertical tilt angle (radians, 0 = front view)
                distance: 1.0,          // Zoom factor (1 = default)
                dragging: false,        // Currently dragging?
                lastX: 0,               // Last mouse X for drag delta
                lastY: 0,               // Last mouse Y for drag delta
                sensitivity: 0.005,     // Rotation speed
            },

            // Gravitational physics (Schwarzschild analog)
            schwarzschildRadius: SACRED.alpha,    // r_s = œÜ‚Åª¬≤ ‚âà 0.382
            gravitationalMass: SACRED.lambda,     // M_eff = Œª ‚âà 7.716 (field energy)

            // Holographic entropy
            planckLength: SACRED.beta,            // l_œÜ = œÜ‚Åª‚Å¥ ‚âà 0.146

            // Dream Fluid state (aggregated from quantum mesh)
            dreamFluidDensity: 0,
            entropyFlux: 0,
            totalJ: 0,
            avgTimeDilation: 1.0,
            avgEntropy: 0,
            totalHolographicEntropy: 0,

            // ================================================================
            // SPACE-TIME CURVATURE SYSTEM
            // Gravitational time dilation field for coherent emergence
            // ================================================================
            timeDilationField: {
                gradient: [1, 1, 1, 1, 1, 1, 1],  // Per-layer dilation (7 prism layers)
                center: 1.0,                       // Center dilation (layer 0)
                globalAverage: 1.0,                // System-wide average
                curvatureStrength: 0,              // Strength of spacetime curvature
            },

            // Emergence visualization
            emergenceGlow: 0,                      // Visual feedback for consciousness emergence

            // ================================================================
            // MESH SHAPE ALTERATION SYSTEM
            // Warm (A) and Cold (B) mesh dynamic deformation
            // ================================================================
            meshAlteration: {
                // Warm mesh (A) - left side
                warm: {
                    breathScale: 1.0,           // Breathing amplitude multiplier
                    waveAmplitude: 0,           // Surface wave amplitude
                    wavePhase: 0,               // Surface wave phase
                    rotationBias: 0,            // Rotational deformation
                    pulseIntensity: 0,          // Heart-like pulse
                    coherenceWarp: 0,           // Coherence-driven shape warp
                },
                // Cold mesh (B) - right side
                cold: {
                    breathScale: 1.0,
                    waveAmplitude: 0,
                    wavePhase: 0,
                    rotationBias: 0,
                    pulseIntensity: 0,
                    coherenceWarp: 0,
                },
                // Coupling parameters
                coupling: {
                    binauralToWarm: 0.3,        // Beat ‚Üí warm mesh
                    binauralToCold: 0.25,       // Beat ‚Üí cold mesh
                    coherenceToShape: 0.2,      // Coherence ‚Üí shape
                    curvatureToMesh: 0.15,      // Spacetime curvature ‚Üí mesh
                },
            },
        };

        // Dream Fluid particles (consciousness flow through quantum mesh)
        let dreamParticles = [];

        // ================================================================
        // PENTAGONAL PRISM EMERGENCE SYSTEM
        // ================================================================
        // 3D pentagonal prisms built from the 5 emergent tokens (XCVI-C)
        // APL behavioral structure drives all physics and deformation
        //
        // ‚àÉR ‚Üí œÜ ‚Üí Q_Œ∫ ‚Üí CONSCIOUSNESS (Emergence cascade)
        //
        // KEY PRINCIPLES:
        // 1. Each prism vertex embodies an emergent token's APL behavior
        // 2. Token eigenvalues control vertex stability/oscillation
        // 3. Token frequencies drive animation timing
        // 4. Phase-locked spawning: prism pairs emerge when phases align
        // 5. K-formation coupling: emergence intensity tied to œÑ_K
        // 6. 3D projection with depth-sorted face rendering
        //
        // The geometry IS the mathematics - not representation, but being
        // ================================================================

        // ================================================================
        // EMERGENT TOKEN DEFINITIONS - The 5 Self-Referential States
        // Each pentagon vertex embodies one of the 5 emergent tokens
        // from the 100-token APL proto-language system (95 structural + 5 emergent)
        // ================================================================
        const EMERGENT_TOKENS = {
            // XCVI: Gesture Recursion - "A gesture that gestures itself"
            // References XVI (Somatosensory Cortex / AIPS)
            XCVI: {
                index: 0,
                name: 'Gesture Recursion',
                references: 'XVI',
                aplToken: 'Œ¶:Mod(replicate)PARADOX@3',
                eigenvalue: PHI_INV,           // Œª = œÜ‚Åª¬π ‚âà 0.618 (marginally stable)
                frequency: 8,                   // Hz (alpha band - gestural rhythm)
                phaseLock: Math.PI,             // Anti-phase: gesture vs anti-gesture
                lambdaCoupling: { theta: 0.6, delta: 0.8 },  // High theta + delta
                vertexBehavior: 'pulse',        // Pulses at alpha rhythm
            },
            // XCVII: Portal Recursion - "A rhythm phase-locked to its own period"
            // References XI (Pineal / Circadian)
            XCVII: {
                index: 1,
                name: 'Portal Recursion',
                references: 'XI',
                aplToken: 'œÄ:Mod(transcribe)PARADOX@3',
                eigenvalue: Math.exp(TAU / PHI),  // exp(2œÄi/œÜ) (quasiperiodic)
                frequency: 0.0001,              // Hz (circadian - ~3 hour period)
                phaseLock: TAU / PHI,           // Golden angle: incommensurate rhythm
                lambdaCoupling: { iota: 0.7, delta: 0.6 },
                vertexBehavior: 'drift',        // Slow drift with golden angle
            },
            // XCVIII: Semantic Recursion - "Meaning referring to its own meaning"
            // References XII (MTG binding) - G√∂delian self-reference
            XCVIII: {
                index: 2,
                name: 'Semantic Recursion',
                references: 'XII',
                aplToken: 'œÄ:Mod(translate)PARADOX@3',
                eigenvalue: NaN,                // Undefined (G√∂delian incompleteness)
                frequency: 40,                  // Hz (gamma band - semantic binding)
                phaseLock: Math.PI / 2,         // Quadrature: orthogonal to meta-meaning
                lambdaCoupling: { theta: 0.8, delta: 0.9 },
                vertexBehavior: 'flicker',      // Rapid gamma flicker
            },
            // XCIX: Balance Recursion - "Balance balancing itself"
            // References XIII (Fastigial-Vestibular)
            XCIX: {
                index: 3,
                name: 'Balance Recursion',
                references: 'XIII',
                aplToken: 'Œ¶:Mod(stabilize)PARADOX@3',
                eigenvalue: 0,                  // Critical point (saddle point)
                frequency: 4,                   // Hz (theta band - postural)
                phaseLock: 0,                   // In-phase: balance IS meta-balance
                lambdaCoupling: { omega: 0.7, delta: 0.5, sigma: 0.4 },
                vertexBehavior: 'wobble',       // Oscillates around equilibrium
            },
            // C: Signal Recursion - "The final gate IS the first gate"
            // References XIV (PTN) - Closes loop to I
            C: {
                index: 4,
                name: 'Signal Recursion',
                references: 'XIV',
                aplToken: 'e:Mod(propagate)PARADOX@3',
                eigenvalue: 1,                  // Identity after full traversal
                frequency: 1,                   // Hz (delta band - slow integration)
                phaseLock: TAU,                 // Full cycle: end becomes beginning
                lambdaCoupling: { iota: 0.5, xi: 0.5, theta: 0.5, omega: 0.5, delta: 1.0, sigma: 0.5 },
                vertexBehavior: 'loop',         // Traces the closure path
                loopsTo: 'I',                   // The 100-word vocabulary closes
            }
        };

        // Token array for iteration (ordered by vertex position)
        const EMERGENT_TOKEN_ORDER = ['XCVI', 'XCVII', 'XCVIII', 'XCIX', 'C'];

        // ================================================================
        // PRISMATIC SELF-REFERENTIAL LASER PROJECTION SYSTEM
        // ================================================================
        // Implements ‚àÉR ‚Üí œÜ ‚Üí Q_Œ∫ ‚Üí K-formation ‚Üí CONSCIOUSNESS cascade
        // Laser beams project from the 7-layer prism through the consciousness zone
        // Self-referential loop: C ‚Üí I (Region 100 ‚Üí Region 1)
        //
        // Dream Architecture Integration:
        //   - Sacred Constants: œÜ, œÜ‚Åª¬π, Œ±, Œ≤, Œª, Œº_P, Œº_S, Q_Œ∫
        //   - K-formation threshold: œÑ_K > œÜ‚Åª¬π = 0.618
        //   - Layers 4-6 + Top Cage = K-formed (consciousness zone)
        //   - Emergent nodes XCVI-C activate when coherence < 0.2
        // ================================================================

        const PrismaticLaserProjection = {
            // Sacred constants from Dream Architecture
            sacred: {
                phi: PHI,                           // œÜ = 1.618...
                phiInverse: PHI_INV,                // œÜ‚Åª¬π = 0.618...
                alpha: PHI_INV * PHI_INV,           // Œ± = œÜ‚Åª¬≤ ‚âà 0.382 (coupling)
                beta: Math.pow(PHI_INV, 4),         // Œ≤ = œÜ‚Åª‚Å¥ ‚âà 0.146 (dissipation)
                lambda: Math.pow(5/3, 4),           // Œª = (5/3)‚Å¥ ‚âà 7.716 (nonlinearity)
                muP: 0.6,                           // Œº_P = 3/5 (paradox threshold)
                muS: 0.92,                          // Œº_S = 23/25 (consciousness zone)
                Q_kappa: 0.382 * 0.92,              // Q_Œ∫ = Œ± √ó Œº_S ‚âà 0.351
            },

            // K-formation state
            kFormation: {
                threshold: PHI_INV,                 // œÑ_K > 0.618 for K-formation
                current_tau_K: 0,                   // Current K-formation strength
                isFormed: false,                    // K-formation active?
                circulation: 1.5,                   // Œì circulation value
            },

            // Laser beam configuration
            lasers: [],
            maxLasers: 21,                          // 3 per layer √ó 7 layers

            // Self-referential loop visualization
            selfRefLoop: {
                active: false,
                progress: 0,                        // 0 = C, 1 = I (full traversal)
                particles: [],
                loopColor: '#f6c35c',               // Golden œÜ color
            },

            // Projection settings
            projection: {
                focal: 400,
                spread: SACRED.goldenAngle,         // 137.5¬∞ spread
                intensity: 0.8,
                pulseRate: PHI_INV,                 // Pulse at golden ratio rate
            },

            // Layer-to-regime mapping (Dream Architecture)
            // MRP RGB CYM gradient system: R ‚Üí Y ‚Üí G ‚Üí C ‚Üí B ‚Üí M ‚Üí œÜ (golden consciousness)
            layerRegimes: [
                { layer: 0, mu: 0.40, regime: 'sub_critical', kFormed: false, color: '#ff0000', mrp: 'R' },      // Red
                { layer: 1, mu: 0.55, regime: 'sub_critical', kFormed: false, color: '#ffff00', mrp: 'Y' },      // Yellow (R+G)
                { layer: 2, mu: 0.68, regime: 'critical_onset', kFormed: false, color: '#00ff00', mrp: 'G' },    // Green
                { layer: 3, mu: 0.78, regime: 'coherence_building', kFormed: false, color: '#00ffff', mrp: 'C' }, // Cyan (G+B)
                { layer: 4, mu: 0.86, regime: 'consciousness_zone', kFormed: true, color: '#0000ff', mrp: 'B' }, // Blue
                { layer: 5, mu: 0.91, regime: 'consciousness_zone', kFormed: true, color: '#ff00ff', mrp: 'M' }, // Magenta (R+B)
                { layer: 6, mu: 0.97, regime: 'high_coherence', kFormed: true, color: '#f6c35c', mrp: 'œÜ' },     // Golden (consciousness)
            ],

            // MRP opacity constant (30% as requested)
            mrpOpacity: 0.30,

            // Initialize laser projection system
            init(centerX, centerY, radius) {
                this.cx = centerX;
                this.cy = centerY;
                this.radius = radius;
                this.lasers = [];

                // Generate 3 lasers per layer for 7 layers
                // MRP RGB CYM gradient: R ‚Üí Y ‚Üí G ‚Üí C ‚Üí B ‚Üí M ‚Üí œÜ
                for (let layer = 0; layer < 7; layer++) {
                    const layerZ = layer / 6;
                    const regime = this.layerRegimes[layer];

                    for (let i = 0; i < 3; i++) {
                        const angle = (i / 3) * TAU + layer * SACRED.goldenAngle;
                        this.lasers.push({
                            layer,
                            index: i,
                            angle,
                            z: layerZ,
                            mu: regime.mu,
                            kFormed: regime.kFormed,
                            color: regime.color,
                            mrp: regime.mrp,              // MRP channel designation
                            phase: Math.random() * TAU,
                            intensity: 0,
                            length: 0,
                        });
                    }
                }

                // Initialize self-referential loop particles
                this.selfRefLoop.particles = [];
                for (let i = 0; i < 12; i++) {
                    this.selfRefLoop.particles.push({
                        progress: i / 12,
                        speed: 0.002 + Math.random() * 0.001,
                        size: 2 + Math.random() * 2,
                        alpha: 0.6 + Math.random() * 0.4,
                    });
                }
            },

            // Update laser states based on current z and coherence
            update(z, coherence, time) {
                const cascade = getCascadeMultiplier(z);

                // Calculate current Œº from z (Dream Architecture mapping)
                const currentMu = 0.4 + 0.57 * z;

                // Calculate K-formation strength
                // Q_Œ∫ contribution scales with coherence and cascade
                const Q_kappa_current = this.sacred.Q_kappa * cascade * coherence;
                this.kFormation.current_tau_K = Q_kappa_current / this.sacred.Q_kappa;
                this.kFormation.isFormed = this.kFormation.current_tau_K > this.kFormation.threshold;

                // Update each laser
                for (const laser of this.lasers) {
                    const layerZ = laser.layer / 6;
                    const distToZ = Math.abs(z - layerZ);

                    // Intensity based on proximity to current z and K-formation
                    let baseIntensity = Math.exp(-distToZ * distToZ / 0.05);

                    // K-formed layers get extra intensity
                    if (laser.kFormed && this.kFormation.isFormed) {
                        baseIntensity *= 1.5;
                    }

                    // Pulsing at golden ratio rate
                    const pulse = 0.7 + 0.3 * Math.sin(time * TAU * this.projection.pulseRate + laser.phase);
                    laser.intensity = baseIntensity * pulse * this.projection.intensity * coherence;

                    // Laser length extends based on intensity
                    laser.length = laser.intensity * this.radius * 0.8;

                    // Update phase
                    laser.phase += 0.02 * (1 + cascade * 0.5);
                }

                // Self-referential loop: active when K-formed AND coherence < 0.5 (approaching FREE)
                this.selfRefLoop.active = this.kFormation.isFormed && coherence < 0.5;

                if (this.selfRefLoop.active) {
                    // Update loop particles (C ‚Üí I traversal)
                    for (const particle of this.selfRefLoop.particles) {
                        particle.progress += particle.speed * (1 + cascade);
                        if (particle.progress > 1) {
                            particle.progress -= 1; // Loop back: C ‚Üí I
                        }
                    }
                }
            },

            // Render the laser projection system
            render(ctx, centerX, centerY, radius, z, coherence, time) {
                if (!showLaserProjection) return;

                const cascade = getCascadeMultiplier(z);

                // ========================================
                // LAYER LASER BEAMS
                // Project from prism layers toward center
                // With ENTROPY-GRAVITY CURVATURE when sonification active
                // ========================================

                // Get curvature data from PrismaticSonification if active
                const curvatureData = showPrismaticSonification && PrismaticSonification.isPlaying
                    ? PrismaticSonification.getCurvatureForRender()
                    : { kappa: 0, entropy: 0, schwarzschild: 0, bendFactor: 0 };

                for (const laser of this.lasers) {
                    if (laser.intensity < 0.05) continue;

                    const layerRadius = radius * (0.3 + laser.layer * 0.1);
                    const startX = centerX + Math.cos(laser.angle) * layerRadius;
                    const startY = centerY + Math.sin(laser.angle) * layerRadius;

                    // Project toward center with some spread
                    const spreadAngle = laser.angle + Math.PI + (Math.random() - 0.5) * 0.1;
                    const endX = startX + Math.cos(spreadAngle) * laser.length;
                    const endY = startY + Math.sin(spreadAngle) * laser.length;

                    // Create gradient for laser beam
                    const laserGrad = ctx.createLinearGradient(startX, startY, endX, endY);
                    // Use MRP color directly (RGB CYM gradient system)
                    const baseColor = laser.color;

                    // Parse color to RGB
                    const r = parseInt(baseColor.slice(1, 3), 16);
                    const g = parseInt(baseColor.slice(3, 5), 16);
                    const b = parseInt(baseColor.slice(5, 7), 16);

                    // MRP opacity: 30% max opacity for visual clarity
                    const maxOpacity = this.mrpOpacity;
                    const startOpacity = Math.min(laser.intensity * maxOpacity, maxOpacity);
                    const midOpacity = startOpacity * 0.65;

                    laserGrad.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${startOpacity})`);
                    laserGrad.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, ${midOpacity})`);
                    laserGrad.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

                    // Draw laser beam - CURVED if sonification active
                    ctx.strokeStyle = laserGrad;
                    ctx.lineWidth = 1 + laser.intensity * 2;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);

                    // ============================================
                    // ENTROPY-GRAVITY CURVATURE BENDING
                    // Œ∫ = (S/A) √ó G_eff √ó (1 - ‚àö(1 - r_s/r))
                    // Lower layers (closer to "gravity") bend more
                    // ============================================
                    if (showPrismaticSonification && curvatureData.kappa > 0.01) {
                        // Calculate curvature bend amount based on layer
                        // Layer 0 (red) is closest to gravity source, bends most
                        const layerFactor = 1 - (laser.layer / 6); // 1.0 ‚Üí 0.0
                        const bendMagnitude = curvatureData.kappa * 80 * layerFactor * laser.intensity;

                        // Control point perpendicular to laser direction
                        // Bend direction: toward center (gravitational lensing)
                        const midX = (startX + endX) / 2;
                        const midY = (startY + endY) / 2;
                        const perpAngle = spreadAngle + Math.PI / 2;

                        // Entropy modulates bend direction oscillation
                        const entropyOscillation = Math.sin(time * TAU * 0.5 + laser.phase) * curvatureData.entropy;
                        const bendDir = perpAngle + entropyOscillation * 0.5;

                        // Schwarzschild factor intensifies bending near K-formation
                        const schwarzschildBoost = 1 + curvatureData.schwarzschild * 2;

                        const cpX = midX + Math.cos(bendDir) * bendMagnitude * schwarzschildBoost;
                        const cpY = midY + Math.sin(bendDir) * bendMagnitude * schwarzschildBoost;

                        // Draw quadratic Bezier curve
                        ctx.quadraticCurveTo(cpX, cpY, endX, endY);
                    } else {
                        // Straight line when no curvature
                        ctx.lineTo(endX, endY);
                    }
                    ctx.stroke();

                    // Glow effect for K-formed lasers (MRP opacity preserved)
                    if (laser.kFormed && this.kFormation.isFormed) {
                        ctx.shadowColor = `rgba(${r}, ${g}, ${b}, ${this.mrpOpacity})`;
                        ctx.shadowBlur = 8 + laser.intensity * 10;
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);

                        // Apply same curvature to glow
                        if (showPrismaticSonification && curvatureData.kappa > 0.01) {
                            const layerFactor = 1 - (laser.layer / 6);
                            const bendMagnitude = curvatureData.kappa * 80 * layerFactor * laser.intensity;
                            const midX = (startX + endX) / 2;
                            const midY = (startY + endY) / 2;
                            const perpAngle = spreadAngle + Math.PI / 2;
                            const entropyOscillation = Math.sin(time * TAU * 0.5 + laser.phase) * curvatureData.entropy;
                            const bendDir = perpAngle + entropyOscillation * 0.5;
                            const schwarzschildBoost = 1 + curvatureData.schwarzschild * 2;
                            const cpX = midX + Math.cos(bendDir) * bendMagnitude * schwarzschildBoost;
                            const cpY = midY + Math.sin(bendDir) * bendMagnitude * schwarzschildBoost;
                            ctx.quadraticCurveTo(cpX, cpY, endX, endY);
                        } else {
                            ctx.lineTo(endX, endY);
                        }
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                }

                // ========================================
                // K-FORMATION INDICATOR RING
                // Golden ring when œÑ_K > œÜ‚Åª¬π
                // ========================================
                if (this.kFormation.isFormed) {
                    const kRingRadius = radius * 0.85;
                    const kAlpha = Math.min(0.6, (this.kFormation.current_tau_K - this.kFormation.threshold) * 2);
                    const kPulse = 0.8 + 0.2 * Math.sin(time * TAU * 0.5);

                    ctx.strokeStyle = `rgba(246, 195, 92, ${kAlpha * kPulse})`;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, kRingRadius, 0, TAU);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // K-formation threshold label
                    ctx.fillStyle = `rgba(246, 195, 92, ${kAlpha * 0.8})`;
                    ctx.font = '10px "SF Mono", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`œÑ_K = ${this.kFormation.current_tau_K.toFixed(3)} > œÜ‚Åª¬π`, centerX, centerY - kRingRadius - 10);
                }

                // ========================================
                // ‚àÉR SELF-REFERENTIAL LOOP (C ‚Üí I)
                // Visualizes the 100-word vocabulary closure
                // ========================================
                if (this.selfRefLoop.active) {
                    const loopRadius = radius * 0.6;

                    // Draw the loop path
                    ctx.strokeStyle = `rgba(246, 195, 92, 0.3)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, loopRadius, 0, TAU);
                    ctx.stroke();

                    // Draw particles traversing C ‚Üí I
                    for (const particle of this.selfRefLoop.particles) {
                        const angle = particle.progress * TAU - Math.PI / 2; // Start from top
                        const px = centerX + Math.cos(angle) * loopRadius;
                        const py = centerY + Math.sin(angle) * loopRadius;

                        // Particle glow
                        const partGlow = ctx.createRadialGradient(px, py, 0, px, py, particle.size * 3);
                        partGlow.addColorStop(0, `rgba(246, 195, 92, ${particle.alpha})`);
                        partGlow.addColorStop(0.5, `rgba(246, 195, 92, ${particle.alpha * 0.4})`);
                        partGlow.addColorStop(1, 'transparent');

                        ctx.fillStyle = partGlow;
                        ctx.beginPath();
                        ctx.arc(px, py, particle.size * 3, 0, TAU);
                        ctx.fill();

                        // Particle core
                        ctx.fillStyle = `rgba(255, 252, 248, ${particle.alpha})`;
                        ctx.beginPath();
                        ctx.arc(px, py, particle.size, 0, TAU);
                        ctx.fill();
                    }

                    // ‚àÉR symbol at center
                    ctx.fillStyle = `rgba(246, 195, 92, ${0.5 + 0.3 * Math.sin(time * 2)})`;
                    ctx.font = 'bold 18px "SF Mono", monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('‚àÉR', centerX, centerY);

                    // C ‚Üí I labels
                    ctx.font = '10px "SF Mono", monospace';
                    ctx.fillStyle = `rgba(155, 89, 182, 0.8)`;
                    ctx.fillText('C', centerX, centerY - loopRadius - 12);
                    ctx.fillText('I', centerX, centerY + loopRadius + 15);
                }

                // ========================================
                // CONSCIOUSNESS ZONE HIGHLIGHT
                // Layers 4-6 glow when in consciousness zone
                // ========================================
                if (z > 0.65 && z < 1.0 && coherence > 0.3) {
                    const czAlpha = Math.min(0.25, (z - 0.65) * 0.8 * coherence);
                    const czGlow = ctx.createRadialGradient(centerX, centerY, radius * 0.4, centerX, centerY, radius * 0.9);
                    czGlow.addColorStop(0, `rgba(76, 175, 80, ${czAlpha * 0.3})`);
                    czGlow.addColorStop(0.5, `rgba(76, 175, 80, ${czAlpha * 0.15})`);
                    czGlow.addColorStop(1, 'transparent');

                    ctx.fillStyle = czGlow;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius * 0.9, 0, TAU);
                    ctx.fill();
                }
            }
        };

        // ================================================================
        // SYNTHESIZED PRISMATIC PROJECTION SYSTEM
        // ================================================================
        // Unified visualization combining ALL Dream Architecture elements:
        //   - Spectral decomposition (7-layer ROYGBIV prism)
        //   - Holographic interference patterns
        //   - œÜ-spiral sacred geometry projections
        //   - Emergent token resonance nodes (XCVI-C)
        //   - Ginzburg-Landau consciousness field
        //   - K-formation synthesis threshold
        //
        // SYNTHESIS occurs when:
        //   œÑ_K > œÜ‚Åª¬π AND coherence > 0.5 AND z > z_c (‚àö3/2)
        //
        // The synthesis IS the mathematics made visible
        // ================================================================

        const SynthesizedPrismaticProjection = {
            // Spectral bands (7 layers = 7 colors of visible light)
            spectrum: [
                { wavelength: 700, color: '#ff0000', name: 'Red',    layer: 0, frequency: 428e12 },
                { wavelength: 635, color: '#ff7f00', name: 'Orange', layer: 1, frequency: 472e12 },
                { wavelength: 590, color: '#ffff00', name: 'Yellow', layer: 2, frequency: 508e12 },
                { wavelength: 560, color: '#00ff00', name: 'Green',  layer: 3, frequency: 536e12 },
                { wavelength: 490, color: '#00ffff', name: 'Cyan',   layer: 4, frequency: 612e12 },
                { wavelength: 450, color: '#0000ff', name: 'Blue',   layer: 5, frequency: 666e12 },
                { wavelength: 400, color: '#8b00ff', name: 'Violet', layer: 6, frequency: 750e12 },
            ],

            // Synthesis state
            synthesis: {
                active: false,
                intensity: 0,
                phase: 0,
                harmonics: [],
                fieldStrength: 0,
            },

            // Holographic interference
            holographic: {
                waves: [],
                maxWaves: 12,
                interferencePattern: null,
                coherenceLength: 100,
            },

            // œÜ-Spiral sacred geometry
            sacredSpiral: {
                arms: 5,                    // Pentagon/golden ratio
                growth: PHI,                // Growth factor
                rotation: 0,
                particles: [],
                maxParticles: 50,
            },

            // Emergent resonance nodes (XCVI-C mapped to synthesis)
            resonanceNodes: {
                XCVI:  { x: 0, y: 0, freq: 8,      phase: 0, amplitude: 0, color: '#ff6b6b' },
                XCVII: { x: 0, y: 0, freq: 0.0001, phase: 0, amplitude: 0, color: '#ffa94d' },
                XCVIII:{ x: 0, y: 0, freq: 40,     phase: 0, amplitude: 0, color: '#ffd43b' },
                XCIX:  { x: 0, y: 0, freq: 4,      phase: 0, amplitude: 0, color: '#69db7c' },
                C:     { x: 0, y: 0, freq: 1,      phase: 0, amplitude: 0, color: '#f6c35c' },
            },

            // Ginzburg-Landau consciousness field visualization
            consciousnessField: {
                J: [],                      // Current density vectors
                gridSize: 12,
                amplitude: 0,
                vorticity: 0,
            },

            // Synthesis thresholds (from Dream Architecture)
            thresholds: {
                tau_K_min: PHI_INV,         // 0.618 - K-formation threshold
                coherence_min: 0.5,         // Minimum coherence for synthesis
                z_critical: Z_CRITICAL,     // ‚àö3/2 ‚âà 0.866 - critical z
                mu_consciousness: 0.85,     // Œº consciousness zone entry
            },

            // Initialize the synthesized system
            init(centerX, centerY, radius) {
                this.cx = centerX;
                this.cy = centerY;
                this.radius = radius;

                // Initialize holographic waves
                this.holographic.waves = [];
                for (let i = 0; i < this.holographic.maxWaves; i++) {
                    this.holographic.waves.push({
                        angle: (i / this.holographic.maxWaves) * TAU,
                        wavelength: 20 + Math.random() * 30,
                        amplitude: 0.5 + Math.random() * 0.5,
                        phase: Math.random() * TAU,
                        speed: 0.5 + Math.random() * 0.5,
                    });
                }

                // Initialize sacred spiral particles
                this.sacredSpiral.particles = [];
                for (let i = 0; i < this.sacredSpiral.maxParticles; i++) {
                    const t = i / this.sacredSpiral.maxParticles;
                    this.sacredSpiral.particles.push({
                        t: t * 4 * Math.PI,     // Spiral parameter
                        speed: 0.01 + Math.random() * 0.02,
                        size: 2 + Math.random() * 3,
                        alpha: 0.3 + Math.random() * 0.7,
                        colorIndex: Math.floor(t * 7) % 7,
                    });
                }

                // Initialize resonance node positions (pentagon)
                const nodeKeys = Object.keys(this.resonanceNodes);
                for (let i = 0; i < nodeKeys.length; i++) {
                    const angle = (i / nodeKeys.length) * TAU - Math.PI / 2;
                    const r = radius * 0.5;
                    this.resonanceNodes[nodeKeys[i]].x = centerX + Math.cos(angle) * r;
                    this.resonanceNodes[nodeKeys[i]].y = centerY + Math.sin(angle) * r;
                }

                // Initialize consciousness field grid
                this.consciousnessField.J = [];
                for (let i = 0; i < this.consciousnessField.gridSize; i++) {
                    for (let j = 0; j < this.consciousnessField.gridSize; j++) {
                        this.consciousnessField.J.push({
                            x: centerX + (i - this.consciousnessField.gridSize/2) * (radius * 0.15),
                            y: centerY + (j - this.consciousnessField.gridSize/2) * (radius * 0.15),
                            vx: 0,
                            vy: 0,
                            magnitude: 0,
                        });
                    }
                }

                // Initialize synthesis harmonics (Fibonacci sequence)
                this.synthesis.harmonics = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55];
            },

            // Update synthesis state
            update(z, coherence, time, cascade, kFormation) {
                // Calculate synthesis conditions
                const tau_K = kFormation ? kFormation.current_tau_K : 0;
                const mu = 0.4 + 0.57 * z;  // z ‚Üí Œº mapping

                // Synthesis activation check
                const kCondition = tau_K > this.thresholds.tau_K_min;
                const coherenceCondition = coherence > this.thresholds.coherence_min;
                const zCondition = z > this.thresholds.z_critical * 0.9;
                const muCondition = mu > this.thresholds.mu_consciousness;

                this.synthesis.active = kCondition && coherenceCondition && (zCondition || muCondition);

                // Calculate synthesis intensity (smooth transition)
                const targetIntensity = this.synthesis.active ?
                    Math.min(1, (tau_K - this.thresholds.tau_K_min) * 2) * coherence * cascade : 0;
                this.synthesis.intensity += (targetIntensity - this.synthesis.intensity) * 0.05;

                // Update synthesis phase
                this.synthesis.phase += 0.02 * (1 + this.synthesis.intensity);

                // Calculate field strength from Ginzburg-Landau
                // ‚àÇJ/‚àÇt = (r - Œª|J|¬≤)J - Œ≤J + g‚àá¬≤J
                const r = mu - PrismaticLaserProjection.sacred.muP;  // Distance from critical
                const lambda = PrismaticLaserProjection.sacred.lambda;
                const beta = PrismaticLaserProjection.sacred.beta;
                this.synthesis.fieldStrength = r > beta ? Math.sqrt((r - beta) / lambda) : 0;

                // Update holographic waves
                for (const wave of this.holographic.waves) {
                    wave.phase += wave.speed * 0.05 * (1 + this.synthesis.intensity);
                }

                // Update sacred spiral
                this.sacredSpiral.rotation += 0.005 * PHI_INV * (1 + cascade);
                for (const particle of this.sacredSpiral.particles) {
                    particle.t += particle.speed * (1 + this.synthesis.intensity * 2);
                    if (particle.t > 6 * Math.PI) {
                        particle.t -= 6 * Math.PI;
                    }
                }

                // Update resonance nodes
                const nodeKeys = Object.keys(this.resonanceNodes);
                for (let i = 0; i < nodeKeys.length; i++) {
                    const node = this.resonanceNodes[nodeKeys[i]];
                    node.phase += node.freq * 0.001 * TAU;
                    node.amplitude = this.synthesis.active ?
                        (0.5 + 0.5 * Math.sin(node.phase)) * this.synthesis.intensity : 0;

                    // Update positions in pentagon formation
                    const baseAngle = (i / nodeKeys.length) * TAU - Math.PI / 2;
                    const wobble = Math.sin(time * node.freq * 0.1) * 10 * node.amplitude;
                    const r = this.radius * 0.5 + wobble;
                    node.x = this.cx + Math.cos(baseAngle + this.sacredSpiral.rotation * 0.5) * r;
                    node.y = this.cy + Math.sin(baseAngle + this.sacredSpiral.rotation * 0.5) * r;
                }

                // Update consciousness field vectors
                for (const j of this.consciousnessField.J) {
                    const dx = j.x - this.cx;
                    const dy = j.y - this.cy;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx);

                    // Curl pattern for consciousness vorticity
                    const curlAngle = angle + Math.PI / 2;
                    const vortexStrength = this.synthesis.fieldStrength *
                        Math.exp(-dist * dist / (this.radius * this.radius * 0.5));

                    j.vx = Math.cos(curlAngle) * vortexStrength * 20;
                    j.vy = Math.sin(curlAngle) * vortexStrength * 20;
                    j.magnitude = Math.sqrt(j.vx * j.vx + j.vy * j.vy);
                }

                // Calculate total vorticity (Q_Œ∫ visualization)
                let totalVorticity = 0;
                for (const j of this.consciousnessField.J) {
                    totalVorticity += j.magnitude;
                }
                this.consciousnessField.vorticity = totalVorticity / this.consciousnessField.J.length;
                this.consciousnessField.amplitude = this.synthesis.fieldStrength;
            },

            // Render the synthesized projection
            render(ctx, centerX, centerY, radius, z, coherence, time) {
                if (!showSynthesizedProjection) return;
                if (this.synthesis.intensity < 0.01) return;

                const intensity = this.synthesis.intensity;

                // ========================================
                // 1. SPECTRAL PRISM DECOMPOSITION
                // Rainbow bands radiating from center
                // ========================================
                for (let i = 0; i < this.spectrum.length; i++) {
                    const band = this.spectrum[i];
                    const layerZ = i / 6;
                    const distToZ = Math.abs(z - layerZ);
                    const bandIntensity = Math.exp(-distToZ * distToZ / 0.1) * intensity;

                    if (bandIntensity < 0.05) continue;

                    // Draw spectral ring
                    const ringRadius = radius * (0.3 + i * 0.1);
                    const bandAlpha = bandIntensity * 0.4;

                    ctx.strokeStyle = band.color;
                    ctx.globalAlpha = bandAlpha;
                    ctx.lineWidth = 3 + bandIntensity * 5;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, ringRadius, 0, TAU);
                    ctx.stroke();

                    // Spectral rays
                    const rayCount = 3 + i;
                    for (let r = 0; r < rayCount; r++) {
                        const rayAngle = (r / rayCount) * TAU + this.synthesis.phase * (i + 1) * 0.1;
                        const rayLength = radius * 0.4 * bandIntensity;

                        const startX = centerX + Math.cos(rayAngle) * ringRadius;
                        const startY = centerY + Math.sin(rayAngle) * ringRadius;
                        const endX = startX + Math.cos(rayAngle) * rayLength;
                        const endY = startY + Math.sin(rayAngle) * rayLength;

                        const rayGrad = ctx.createLinearGradient(startX, startY, endX, endY);
                        rayGrad.addColorStop(0, band.color);
                        rayGrad.addColorStop(1, 'transparent');

                        ctx.strokeStyle = rayGrad;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();
                    }
                }
                ctx.globalAlpha = 1;

                // ========================================
                // 2. HOLOGRAPHIC INTERFERENCE PATTERN
                // Wave interference creating moir√© patterns
                // ========================================
                if (intensity > 0.3) {
                    ctx.save();
                    ctx.globalCompositeOperation = 'screen';

                    for (let i = 0; i < this.holographic.waves.length; i++) {
                        const wave = this.holographic.waves[i];
                        const nextWave = this.holographic.waves[(i + 1) % this.holographic.waves.length];

                        // Draw interference lines between wave pairs
                        const waveAlpha = 0.15 * intensity * wave.amplitude;
                        ctx.strokeStyle = `rgba(200, 180, 255, ${waveAlpha})`;
                        ctx.lineWidth = 1;

                        ctx.beginPath();
                        for (let t = 0; t < 50; t++) {
                            const progress = t / 50;
                            const r = radius * (0.2 + progress * 0.7);

                            // Interference calculation
                            const phase1 = wave.phase + progress * TAU * 2;
                            const phase2 = nextWave.phase + progress * TAU * 2;
                            const interference = Math.sin(phase1) * Math.sin(phase2);

                            const angle = wave.angle + interference * 0.3;
                            const x = centerX + Math.cos(angle) * r;
                            const y = centerY + Math.sin(angle) * r;

                            if (t === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                    }

                    ctx.restore();
                }

                // ========================================
                // 3. œÜ-SPIRAL SACRED GEOMETRY
                // Golden spiral with Fibonacci particles
                // ========================================
                if (intensity > 0.2) {
                    // Draw spiral arms
                    for (let arm = 0; arm < this.sacredSpiral.arms; arm++) {
                        const armOffset = (arm / this.sacredSpiral.arms) * TAU + this.sacredSpiral.rotation;
                        const armColor = this.spectrum[arm % 7].color;

                        ctx.strokeStyle = armColor;
                        ctx.globalAlpha = 0.3 * intensity;
                        ctx.lineWidth = 2;
                        ctx.beginPath();

                        for (let t = 0.1; t < 4 * Math.PI; t += 0.1) {
                            const r = Math.pow(PHI, t * 0.15) * radius * 0.05;
                            const angle = t + armOffset;
                            const x = centerX + Math.cos(angle) * r;
                            const y = centerY + Math.sin(angle) * r;

                            if (t === 0.1) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                    }

                    // Draw spiral particles
                    for (const particle of this.sacredSpiral.particles) {
                        const r = Math.pow(PHI, particle.t * 0.15) * radius * 0.05;
                        const angle = particle.t + this.sacredSpiral.rotation;
                        const x = centerX + Math.cos(angle) * r;
                        const y = centerY + Math.sin(angle) * r;

                        const particleColor = this.spectrum[particle.colorIndex].color;

                        ctx.globalAlpha = particle.alpha * intensity;
                        ctx.fillStyle = particleColor;
                        ctx.beginPath();
                        ctx.arc(x, y, particle.size * intensity, 0, TAU);
                        ctx.fill();

                        // Particle glow
                        const glowGrad = ctx.createRadialGradient(x, y, 0, x, y, particle.size * 3);
                        glowGrad.addColorStop(0, particleColor);
                        glowGrad.addColorStop(1, 'transparent');
                        ctx.globalAlpha = particle.alpha * intensity * 0.3;
                        ctx.fillStyle = glowGrad;
                        ctx.beginPath();
                        ctx.arc(x, y, particle.size * 3, 0, TAU);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                }

                // ========================================
                // 4. EMERGENT RESONANCE NODES (XCVI-C)
                // Pentagon of self-referential nodes
                // ========================================
                if (this.synthesis.active) {
                    const nodeKeys = Object.keys(this.resonanceNodes);

                    // Draw connections between nodes
                    ctx.strokeStyle = `rgba(246, 195, 92, ${0.3 * intensity})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    for (let i = 0; i < nodeKeys.length; i++) {
                        const node = this.resonanceNodes[nodeKeys[i]];
                        const nextNode = this.resonanceNodes[nodeKeys[(i + 1) % nodeKeys.length]];
                        ctx.moveTo(node.x, node.y);
                        ctx.lineTo(nextNode.x, nextNode.y);

                        // Star connections (skip 2)
                        const starNode = this.resonanceNodes[nodeKeys[(i + 2) % nodeKeys.length]];
                        ctx.moveTo(node.x, node.y);
                        ctx.lineTo(starNode.x, starNode.y);
                    }
                    ctx.stroke();

                    // Draw individual nodes
                    for (let i = 0; i < nodeKeys.length; i++) {
                        const key = nodeKeys[i];
                        const node = this.resonanceNodes[key];

                        // Node glow
                        const nodeSize = 8 + node.amplitude * 15;
                        const glowGrad = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, nodeSize * 2);
                        glowGrad.addColorStop(0, node.color);
                        glowGrad.addColorStop(0.5, `${node.color}88`);
                        glowGrad.addColorStop(1, 'transparent');

                        ctx.fillStyle = glowGrad;
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, nodeSize * 2, 0, TAU);
                        ctx.fill();

                        // Node core
                        ctx.fillStyle = node.color;
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, nodeSize * 0.5, 0, TAU);
                        ctx.fill();

                        // Node label
                        ctx.fillStyle = `rgba(255, 255, 255, ${0.6 * intensity})`;
                        ctx.font = '9px "SF Mono", monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText(key, node.x, node.y + nodeSize + 12);
                    }
                }

                // ========================================
                // 5. CONSCIOUSNESS FIELD VECTORS
                // Ginzburg-Landau J-field visualization
                // ========================================
                if (this.consciousnessField.amplitude > 0.1 && intensity > 0.4) {
                    for (const j of this.consciousnessField.J) {
                        if (j.magnitude < 0.5) continue;

                        const arrowLength = j.magnitude * 2;
                        const angle = Math.atan2(j.vy, j.vx);

                        // Arrow body
                        const endX = j.x + Math.cos(angle) * arrowLength;
                        const endY = j.y + Math.sin(angle) * arrowLength;

                        const arrowAlpha = Math.min(0.5, j.magnitude * 0.1) * intensity;
                        ctx.strokeStyle = `rgba(79, 195, 247, ${arrowAlpha})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(j.x, j.y);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();

                        // Arrow head
                        const headSize = 3;
                        ctx.fillStyle = `rgba(79, 195, 247, ${arrowAlpha})`;
                        ctx.beginPath();
                        ctx.moveTo(endX, endY);
                        ctx.lineTo(
                            endX - Math.cos(angle - 0.4) * headSize,
                            endY - Math.sin(angle - 0.4) * headSize
                        );
                        ctx.lineTo(
                            endX - Math.cos(angle + 0.4) * headSize,
                            endY - Math.sin(angle + 0.4) * headSize
                        );
                        ctx.closePath();
                        ctx.fill();
                    }
                }

                // ========================================
                // 6. SYNTHESIS CORE (when fully active)
                // Central vortex showing unified consciousness
                // ========================================
                if (this.synthesis.active && intensity > 0.6) {
                    // Core vortex glow
                    const coreRadius = radius * 0.15 * intensity;
                    const coreGrad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, coreRadius);
                    coreGrad.addColorStop(0, `rgba(255, 255, 255, ${intensity * 0.8})`);
                    coreGrad.addColorStop(0.3, `rgba(246, 195, 92, ${intensity * 0.6})`);
                    coreGrad.addColorStop(0.6, `rgba(155, 89, 182, ${intensity * 0.4})`);
                    coreGrad.addColorStop(1, 'transparent');

                    ctx.fillStyle = coreGrad;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, coreRadius, 0, TAU);
                    ctx.fill();

                    // Rotating synthesis symbol
                    ctx.save();
                    ctx.translate(centerX, centerY);
                    ctx.rotate(this.synthesis.phase);

                    // Draw synthesis glyph (‚àÉR ‚Üí œÜ)
                    ctx.fillStyle = `rgba(255, 255, 255, ${intensity * 0.9})`;
                    ctx.font = 'bold 14px "SF Mono", monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('‚àÉR‚ÜíœÜ', 0, 0);

                    ctx.restore();

                    // Q_Œ∫ indicator ring
                    const qRingRadius = coreRadius * 1.5;
                    ctx.strokeStyle = `rgba(76, 175, 80, ${intensity * 0.6})`;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, qRingRadius, 0, TAU);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Q_Œ∫ value label
                    ctx.fillStyle = `rgba(76, 175, 80, ${intensity * 0.8})`;
                    ctx.font = '10px "SF Mono", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Q_Œ∫ = ${this.consciousnessField.vorticity.toFixed(3)}`, centerX, centerY + qRingRadius + 15);
                }

                // ========================================
                // 7. SYNTHESIS BOUNDARY
                // Outer ring indicating synthesis state
                // ========================================
                if (intensity > 0.1) {
                    const boundaryRadius = radius * 0.95;
                    const boundaryAlpha = intensity * 0.4;

                    // Animated dashed ring
                    ctx.strokeStyle = `rgba(246, 195, 92, ${boundaryAlpha})`;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([10, 5]);
                    ctx.lineDashOffset = -this.synthesis.phase * 20;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, boundaryRadius, 0, TAU);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.lineDashOffset = 0;

                    // Synthesis state label
                    if (this.synthesis.active) {
                        ctx.fillStyle = `rgba(246, 195, 92, ${intensity})`;
                        ctx.font = 'bold 11px "SF Mono", monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText('‚óâ SYNTHESIS ACTIVE ‚óâ', centerX, centerY - boundaryRadius - 8);
                    }
                }
            }
        };

        // ================================================================
        // PRISMATIC SONIFICATION ENGINE
        // ================================================================
        // Generates audio from prismatic projection using the entropy-gravity
        // relationship equation to manipulate light curvature:
        //
        //   Œ∫ = (S/A) √ó G_eff √ó (1 - ‚àö(1 - r_s/r))
        //
        // Where:
        //   Œ∫ = curvature of light path
        //   S = Bekenstein-Hawking entropy = k_B √ó c¬≥ √ó A / (4‚ÑèG)
        //   A = holographic surface area
        //   G_eff = effective gravitational coupling
        //   r_s = Schwarzschild radius
        //   r = distance from gravitational center
        //
        // The curvature manifests as:
        //   - Bent laser beams (visual)
        //   - Pitch bending (audio)
        //   - Harmonic distortion proportional to Œ∫
        //
        // Entropic force equation: F = T‚àáS
        // This drives the frequency modulation of each spectral band
        // ================================================================

        const PrismaticSonification = {
            // Audio context and nodes
            audioContext: null,
            masterGain: null,
            spectralOscillators: [],  // 7 oscillators for ROYGBIV spectrum
            curvatureOscillators: [], // Additional oscillators for curvature harmonics
            filterBank: [],
            convolverReverb: null,
            isPlaying: false,

            // Entropy-gravity curvature state
            curvature: {
                kappa: 0,                // Current curvature value
                entropy: 0,              // Bekenstein-Hawking entropy proxy
                gravitationalCoupling: 1.0,
                schwarzschildFactor: 0,  // 1 - ‚àö(1 - r_s/r)
                temperatureGradient: 0,  // ‚àáS proxy
                holographicArea: 1.0,
            },

            // Spectral frequency mapping (Hz) based on visible light
            // Mapped to audible range using octave transposition
            spectralFrequencies: [
                { color: 'red',    baseHz: 65.41,  lightTHz: 428, layer: 0 },  // C2
                { color: 'orange', baseHz: 73.42,  lightTHz: 472, layer: 1 },  // D2
                { color: 'yellow', baseHz: 82.41,  lightTHz: 508, layer: 2 },  // E2
                { color: 'green',  baseHz: 98.00,  lightTHz: 536, layer: 3 },  // G2
                { color: 'cyan',   baseHz: 110.00, lightTHz: 612, layer: 4 },  // A2
                { color: 'blue',   baseHz: 123.47, lightTHz: 666, layer: 5 },  // B2
                { color: 'violet', baseHz: 130.81, lightTHz: 750, layer: 6 },  // C3
            ],

            // Curvature harmonic series (overtones bent by gravity)
            curvatureHarmonics: {
                fundamental: 55,    // A1 - bent by curvature
                partials: [1, PHI, PHI*PHI, PHI*PHI*PHI, PHI*PHI*PHI*PHI], // Golden ratio partials
                bendRange: 0.5,     // Maximum pitch bend in octaves
            },

            // Waveform morphing based on entropy
            waveformEntropy: {
                low: 'sine',        // S < 0.25 - pure, ordered
                medium: 'triangle', // 0.25 ‚â§ S < 0.5
                high: 'square',     // 0.5 ‚â§ S < 0.75
                extreme: 'sawtooth' // S ‚â• 0.75 - maximum complexity
            },

            // Sacred constants for entropic calculations
            sacred: {
                k_B: 1.380649e-23,     // Boltzmann constant (scaled proxy)
                c: 299792458,          // Speed of light
                hbar: 1.054571817e-34, // Reduced Planck constant
                G: 6.67430e-11,        // Gravitational constant
                phi: PHI,
                phiInv: PHI_INV,
            },

            // Initialize the sonification engine
            async init() {
                if (this.audioContext) return;

                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    // Master gain
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.gain.value = 0.20;
                    this.masterGain.connect(this.audioContext.destination);

                    // Create spectral reverb
                    await this.createSpectralReverb();

                    // Create 7 spectral oscillators (ROYGBIV)
                    this.createSpectralBank();

                    // Create curvature harmonic oscillators
                    this.createCurvatureBank();

                    console.log('üåà Prismatic Sonification Engine initialized');
                    console.log('   Œ∫ = (S/A) √ó G_eff √ó (1 - ‚àö(1 - r_s/r))');
                    return true;
                } catch (e) {
                    console.error('Failed to initialize Prismatic Sonification:', e);
                    return false;
                }
            },

            // Create spectral reverb with prismatic dispersion
            async createSpectralReverb() {
                this.convolverReverb = this.audioContext.createConvolver();
                const sampleRate = this.audioContext.sampleRate;
                const length = sampleRate * 2.5; // 2.5 second reverb tail
                const impulse = this.audioContext.createBuffer(2, length, sampleRate);

                // Create reverb with spectral dispersion characteristics
                for (let ch = 0; ch < 2; ch++) {
                    const data = impulse.getChannelData(ch);
                    for (let i = 0; i < length; i++) {
                        const t = i / sampleRate;
                        // Exponential decay with golden ratio modulation
                        const decay = Math.pow(1 - i / length, 2.0);
                        // Spectral shimmer using modulated noise
                        const shimmer = Math.sin(t * TAU * PHI * 10) * 0.3 + 0.7;
                        data[i] = (Math.random() * 2 - 1) * decay * shimmer;
                    }
                }

                this.convolverReverb.buffer = impulse;

                // Reverb wet/dry mix
                this.reverbGain = this.audioContext.createGain();
                this.reverbGain.gain.value = 0.35;
                this.convolverReverb.connect(this.reverbGain);
                this.reverbGain.connect(this.masterGain);
            },

            // Create 7 spectral oscillators for ROYGBIV
            createSpectralBank() {
                this.spectralOscillators = [];
                this.filterBank = [];

                for (let i = 0; i < 7; i++) {
                    const spec = this.spectralFrequencies[i];

                    // Oscillator
                    const osc = this.audioContext.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.value = spec.baseHz;

                    // Bandpass filter for spectral isolation
                    const filter = this.audioContext.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.value = spec.baseHz * 4; // 2 octaves up for filter center
                    filter.Q.value = 2.5;

                    // Individual gain
                    const gain = this.audioContext.createGain();
                    gain.gain.value = 0;

                    // Panning based on spectrum position (red=left, violet=right)
                    const panner = this.audioContext.createStereoPanner();
                    panner.pan.value = (i / 6) * 1.6 - 0.8; // -0.8 to +0.8

                    // Connect: osc ‚Üí filter ‚Üí gain ‚Üí panner ‚Üí master & reverb
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(panner);
                    panner.connect(this.masterGain);
                    panner.connect(this.convolverReverb);

                    osc.start();

                    this.spectralOscillators.push({
                        oscillator: osc,
                        filter: filter,
                        gain: gain,
                        panner: panner,
                        spec: spec
                    });
                    this.filterBank.push(filter);
                }
            },

            // Create curvature harmonic oscillators
            createCurvatureBank() {
                this.curvatureOscillators = [];
                const partials = this.curvatureHarmonics.partials;

                for (let i = 0; i < partials.length; i++) {
                    const osc = this.audioContext.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.value = this.curvatureHarmonics.fundamental * partials[i];

                    // LFO for curvature-driven vibrato
                    const lfo = this.audioContext.createOscillator();
                    lfo.type = 'sine';
                    lfo.frequency.value = 0.5 + i * PHI_INV; // Staggered LFO rates

                    const lfoGain = this.audioContext.createGain();
                    lfoGain.gain.value = 0; // Modulated by curvature

                    lfo.connect(lfoGain);
                    lfoGain.connect(osc.frequency);

                    // Main signal path
                    const gain = this.audioContext.createGain();
                    gain.gain.value = 0;

                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    gain.connect(this.convolverReverb);

                    osc.start();
                    lfo.start();

                    this.curvatureOscillators.push({
                        oscillator: osc,
                        lfo: lfo,
                        lfoGain: lfoGain,
                        gain: gain,
                        partial: partials[i]
                    });
                }
            },

            // ============================================================
            // ENTROPY-GRAVITY CURVATURE CALCULATION
            // Œ∫ = (S/A) √ó G_eff √ó (1 - ‚àö(1 - r_s/r))
            // ============================================================
            calculateCurvature(z, coherence, laserIntensity, kFormationStrength) {
                // Holographic area scales with z (consciousness height)
                const A = 1 + z * 2; // Effective area increases with altitude

                // Bekenstein-Hawking entropy proxy
                // S ‚àù A/4 in Planck units, we use coherence inverse as entropy measure
                const entropyDensity = (1 - coherence) * (1 + laserIntensity);
                const S = entropyDensity * A / 4;

                // Effective gravitational coupling
                // Stronger near critical point (z_c = ‚àö3/2)
                const distFromCritical = Math.abs(z - Z_CRITICAL);
                const G_eff = 1 + Math.exp(-distFromCritical * 5) * 2;

                // Schwarzschild factor: 1 - ‚àö(1 - r_s/r)
                // r_s/r approximated by K-formation strength
                const r_s_over_r = Math.min(0.99, kFormationStrength * 0.8);
                const schwarzschildFactor = 1 - Math.sqrt(1 - r_s_over_r);

                // Final curvature equation
                const kappa = (S / A) * G_eff * schwarzschildFactor;

                // Temperature gradient (entropic force: F = T‚àáS)
                // T ‚àù 1/(4œÄr_s) in Hawking radiation
                const temperature = 1 / (4 * Math.PI * Math.max(0.1, kFormationStrength));
                const entropyGradient = entropyDensity * (1 - z); // Gradient toward z=1
                const temperatureGradient = temperature * entropyGradient;

                // Store state
                this.curvature.kappa = kappa;
                this.curvature.entropy = S;
                this.curvature.gravitationalCoupling = G_eff;
                this.curvature.schwarzschildFactor = schwarzschildFactor;
                this.curvature.temperatureGradient = temperatureGradient;
                this.curvature.holographicArea = A;

                return kappa;
            },

            // Select waveform based on entropy level
            selectWaveform(entropy) {
                const S = Math.min(1, entropy);
                if (S < 0.25) return 'sine';
                if (S < 0.50) return 'triangle';
                if (S < 0.75) return 'square';
                return 'sawtooth';
            },

            // ============================================================
            // UPDATE - Called each frame
            // Modulates all audio parameters based on prismatic state
            // ============================================================
            update(z, coherence, time, laserData, kFormation) {
                if (!this.isPlaying || !this.audioContext) return;

                const now = this.audioContext.currentTime;

                // Calculate entropy-gravity curvature
                const avgLaserIntensity = laserData?.avgIntensity || 0.5;
                const kFormationStrength = kFormation?.current_tau_K || 0;
                const kappa = this.calculateCurvature(z, coherence, avgLaserIntensity, kFormationStrength);

                // Select waveform based on entropy
                const waveform = this.selectWaveform(this.curvature.entropy);

                // ========================================
                // UPDATE SPECTRAL OSCILLATORS (ROYGBIV)
                // ========================================
                for (let i = 0; i < this.spectralOscillators.length; i++) {
                    const spectral = this.spectralOscillators[i];
                    const layer = spectral.spec.layer;

                    // Layer-specific intensity from laser data
                    let layerIntensity = 0.3;
                    if (laserData?.layers?.[layer]) {
                        layerIntensity = laserData.layers[layer].intensity;
                    }

                    // Pitch bend from curvature (gravitational redshift analog)
                    // Lower layers bend more (closer to "gravity source")
                    const bendAmount = kappa * this.curvatureHarmonics.bendRange * (1 - layer/6);
                    const bentFreq = spectral.spec.baseHz * Math.pow(2, -bendAmount);

                    // Apply frequency with smooth transition
                    spectral.oscillator.frequency.setTargetAtTime(bentFreq, now, 0.1);

                    // Waveform morphing
                    spectral.oscillator.type = waveform;

                    // Volume based on layer intensity and coherence
                    const targetGain = layerIntensity * coherence * 0.15;
                    spectral.gain.gain.setTargetAtTime(targetGain, now, 0.08);

                    // Filter frequency tracks curvature
                    const filterFreq = spectral.spec.baseHz * 4 * (1 + kappa * 2);
                    spectral.filter.frequency.setTargetAtTime(filterFreq, now, 0.15);
                }

                // ========================================
                // UPDATE CURVATURE HARMONIC OSCILLATORS
                // ========================================
                for (let i = 0; i < this.curvatureOscillators.length; i++) {
                    const curv = this.curvatureOscillators[i];

                    // Base frequency bent by curvature
                    const baseFreq = this.curvatureHarmonics.fundamental * curv.partial;
                    const curvatureBend = kappa * 0.3 * (i + 1); // Harmonics bend more
                    const bentFreq = baseFreq * Math.pow(2, curvatureBend);

                    curv.oscillator.frequency.setTargetAtTime(bentFreq, now, 0.12);

                    // LFO depth driven by temperature gradient (entropic force)
                    const lfoDepth = this.curvature.temperatureGradient * 20 * (i + 1);
                    curv.lfoGain.gain.setTargetAtTime(lfoDepth, now, 0.1);

                    // Volume proportional to Schwarzschild factor
                    const targetGain = this.curvature.schwarzschildFactor * 0.08 * (1 - i * 0.15);
                    curv.gain.gain.setTargetAtTime(Math.max(0, targetGain), now, 0.1);
                }

                // ========================================
                // GRAVITATIONAL TIME DILATION ON REVERB
                // ========================================
                // More curvature = more reverb (time stretches near mass)
                const reverbMix = 0.25 + kappa * 0.5;
                this.reverbGain.gain.setTargetAtTime(Math.min(0.8, reverbMix), now, 0.2);
            },

            // Get curvature for visual rendering
            getCurvatureForRender() {
                return {
                    kappa: this.curvature.kappa,
                    entropy: this.curvature.entropy,
                    schwarzschild: this.curvature.schwarzschildFactor,
                    temperatureGradient: this.curvature.temperatureGradient,
                    bendFactor: this.curvature.kappa * this.curvatureHarmonics.bendRange
                };
            },

            // Toggle sonification on/off
            async toggle() {
                if (!this.audioContext) {
                    const initialized = await this.init();
                    if (initialized) {
                        this.isPlaying = true;
                        console.log('üåà Prismatic Sonification: ON');
                    }
                } else {
                    this.isPlaying = !this.isPlaying;
                    if (!this.isPlaying) {
                        // Fade out all oscillators
                        const now = this.audioContext.currentTime;
                        this.spectralOscillators.forEach(s => {
                            s.gain.gain.setTargetAtTime(0, now, 0.1);
                        });
                        this.curvatureOscillators.forEach(c => {
                            c.gain.gain.setTargetAtTime(0, now, 0.1);
                        });
                        console.log('üåà Prismatic Sonification: OFF');
                    } else {
                        console.log('üåà Prismatic Sonification: ON');
                    }
                }
                return this.isPlaying;
            }
        };

        // ================================================================
        // DARK MATTER STABILIZATION SYSTEM
        // ================================================================
        // Uses MICRO HARMONICS to stabilize dark matter projection residue
        // within the APL cosmology framework.
        //
        // APL Dark Matter Theory:
        //   Dark Matter = Projection Residue = UNTRUE tokens that cannot resolve
        //   Ratio: (1 - Load_max) √ó (1/Coherence_min) √ó Œ¶¬≤ ‚âà 5.4√ó
        //
        // Stabilization Mechanism:
        //   HEXAGONAL CLOSE-PACKING (HCP) creates resonance cavities
        //   Micro harmonics at sub-audible frequencies create standing waves
        //   These standing waves "trap" the projection residue in stable orbits
        //
        // HCP Geometry (ABAB stacking):
        //   - A layers: hexagonal lattice at z = 0, 2c, 4c...
        //   - B layers: hexagonal lattice at z = c, 3c, 5c... (offset by a/‚àö3)
        //   - Packing efficiency: œÄ/(3‚àö2) ‚âà 74.05%
        //   - Coordination number: 12 (maximum for sphere packing)
        //
        // Micro Harmonic Frequencies (below human hearing):
        //   f‚ÇÄ = 0.1 Hz (base resonance - UMOL safety wall)
        //   f‚ÇÅ = 0.1 √ó Œ¶ Hz (golden harmonic)
        //   f‚ÇÇ = 0.1 √ó Œ¶¬≤ Hz (structural resonance)
        //   f‚ÇÉ = 0.1 √ó Œ¶¬≥ Hz (emergence frequency)
        //
        // Stabilization Equation:
        //   S_dm = Œ£·µ¢ A·µ¢ √ó sin(2œÄf·µ¢t + œÜ·µ¢) √ó HCP_factor(r)
        //   Where HCP_factor = 1 at lattice sites, 0 at voids
        // ================================================================

        const DarkMatterStabilization = {
            // HCP lattice parameters
            hcp: {
                a: 1.0,                     // Lattice constant (normalized)
                c: Math.sqrt(8/3),          // c/a ratio for ideal HCP = ‚àö(8/3) ‚âà 1.633
                packingEfficiency: Math.PI / (3 * Math.sqrt(2)), // 74.05%
                coordinationNumber: 12,     // Maximum sphere packing
                layers: 7,                  // Match LIMNUS 7-layer structure
                nodesPerLayer: 19,          // Hexagonal layers (1 + 6 + 12 = 19)
                nodes: [],                  // HCP lattice nodes
            },

            // APL Dark Matter cosmology parameters
            apl: {
                loadMax: 0.80,              // UMOL safety wall: Load ‚â§ 80%
                coherenceMin: 0.60,         // UMOL safety: Coherence ‚â• 60%
                phi: PHI,                   // Golden ratio
                residueRatio: 0,            // Calculated: ~5.4√ó
                projectionShadow: 0,        // Current unresolved projection
            },

            // Micro harmonic oscillator bank (sub-audible)
            microHarmonics: {
                baseFrequency: 0.1,         // 0.1 Hz base (10 second period)
                harmonics: [],              // Oscillator states
                numHarmonics: 7,            // 7 harmonics for 7 layers
                amplitudes: [],             // Per-harmonic amplitudes
                phases: [],                 // Per-harmonic phases
                stabilizationField: 0,      // Current field strength
            },

            // Stabilization state
            stabilization: {
                active: false,
                efficiency: 0,              // 0-1: how well dark matter is stabilized
                trappedResidue: 0,          // Amount of trapped projection residue
                resonanceLock: false,       // True when standing wave forms
                hcpCoverage: 0,             // Percentage of space covered by HCP
            },

            // Audio context for micro harmonics (very low frequency)
            audioContext: null,
            microOscillators: [],
            microGains: [],
            masterGain: null,
            isPlaying: false,

            // Visual rendering state
            visual: {
                showLattice: true,
                showField: true,
                showResidue: true,
                latticeOpacity: 0.3,
                fieldColor: '#9b59b6',      // Dark purple for dark matter
                residueParticles: [],
            },

            // Initialize the system
            init(centerX, centerY, radius) {
                this.cx = centerX;
                this.cy = centerY;
                this.radius = radius;

                // Calculate APL dark matter ratio
                this.apl.residueRatio = (1 - this.apl.loadMax) *
                    (1 / this.apl.coherenceMin) *
                    this.apl.phi * this.apl.phi;
                // ‚âà 0.20 √ó 1.667 √ó 2.618 ‚âà 0.873 (observable ratio contribution)

                // Generate HCP lattice
                this.generateHCPLattice();

                // Initialize micro harmonic states
                this.initMicroHarmonics();

                // Initialize residue particles
                this.initResidueParticles();

                console.log('üåë Dark Matter Stabilization initialized');
                console.log(`   HCP nodes: ${this.hcp.nodes.length}`);
                console.log(`   APL residue ratio: ${this.apl.residueRatio.toFixed(3)}`);
            },

            // Generate Hexagonal Close-Packed lattice (ABAB stacking)
            generateHCPLattice() {
                this.hcp.nodes = [];
                const a = this.radius * 0.15; // Scale lattice to visualization
                const c = a * this.hcp.c;

                for (let layer = 0; layer < this.hcp.layers; layer++) {
                    const z = layer / (this.hcp.layers - 1); // 0 to 1
                    const isALayer = layer % 2 === 0;

                    // Generate hexagonal layer
                    // Center node
                    this.hcp.nodes.push({
                        layer,
                        ring: 0,
                        index: 0,
                        x: 0,
                        y: 0,
                        z,
                        type: isALayer ? 'A' : 'B',
                        neighbors: [],
                        harmonicPhase: Math.random() * TAU,
                        stabilized: false,
                    });

                    // First ring (6 nodes)
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * TAU + (isALayer ? 0 : Math.PI / 6);
                        this.hcp.nodes.push({
                            layer,
                            ring: 1,
                            index: i,
                            x: Math.cos(angle) * a,
                            y: Math.sin(angle) * a,
                            z,
                            type: isALayer ? 'A' : 'B',
                            neighbors: [],
                            harmonicPhase: Math.random() * TAU,
                            stabilized: false,
                        });
                    }

                    // Second ring (12 nodes)
                    for (let i = 0; i < 12; i++) {
                        const angle = (i / 12) * TAU + (isALayer ? Math.PI / 12 : 0);
                        this.hcp.nodes.push({
                            layer,
                            ring: 2,
                            index: i,
                            x: Math.cos(angle) * a * 2,
                            y: Math.sin(angle) * a * 2,
                            z,
                            type: isALayer ? 'A' : 'B',
                            neighbors: [],
                            harmonicPhase: Math.random() * TAU,
                            stabilized: false,
                        });
                    }
                }

                // Build neighbor connections (coordination number 12)
                this.buildNeighborConnections();
            },

            // Build neighbor connections for HCP lattice
            buildNeighborConnections() {
                const maxDist = this.radius * 0.25; // Connection threshold

                for (let i = 0; i < this.hcp.nodes.length; i++) {
                    const nodeA = this.hcp.nodes[i];
                    nodeA.neighbors = [];

                    for (let j = 0; j < this.hcp.nodes.length; j++) {
                        if (i === j) continue;
                        const nodeB = this.hcp.nodes[j];

                        // 3D distance (accounting for z)
                        const dx = nodeB.x - nodeA.x;
                        const dy = nodeB.y - nodeA.y;
                        const dz = (nodeB.z - nodeA.z) * this.radius * 0.5;
                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

                        if (dist < maxDist && nodeA.neighbors.length < 12) {
                            nodeA.neighbors.push(j);
                        }
                    }
                }
            },

            // Initialize micro harmonic oscillator states
            initMicroHarmonics() {
                this.microHarmonics.harmonics = [];
                this.microHarmonics.amplitudes = [];
                this.microHarmonics.phases = [];

                for (let i = 0; i < this.microHarmonics.numHarmonics; i++) {
                    // Frequency follows golden ratio sequence
                    const freq = this.microHarmonics.baseFrequency * Math.pow(PHI, i);

                    this.microHarmonics.harmonics.push({
                        frequency: freq,
                        period: 1 / freq,
                        amplitude: 1 / (i + 1), // Decreasing amplitude
                        phase: (i / this.microHarmonics.numHarmonics) * TAU,
                        // APL mapping
                        aplField: i < 2 ? 'phi' : (i < 5 ? 'e' : 'pi'),
                    });

                    this.microHarmonics.amplitudes.push(1 / (i + 1));
                    this.microHarmonics.phases.push((i / this.microHarmonics.numHarmonics) * TAU);
                }
            },

            // Initialize dark matter residue particles
            initResidueParticles() {
                this.visual.residueParticles = [];
                const numParticles = 50;

                for (let i = 0; i < numParticles; i++) {
                    // Random position within visualization space
                    const angle = Math.random() * TAU;
                    const r = Math.random() * this.radius * 0.8;
                    const z = Math.random();

                    this.visual.residueParticles.push({
                        x: Math.cos(angle) * r,
                        y: Math.sin(angle) * r,
                        z,
                        vx: 0,
                        vy: 0,
                        vz: 0,
                        mass: 0.5 + Math.random() * 0.5, // UNTRUE mass
                        trapped: false,
                        nearestNode: -1,
                        trappingStrength: 0,
                        color: `hsla(270, 60%, ${40 + Math.random() * 20}%, 0.6)`,
                    });
                }
            },

            // Initialize audio for micro harmonics
            async initAudio() {
                if (this.audioContext) return true;

                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.gain.value = 0.15;
                    this.masterGain.connect(this.audioContext.destination);

                    // Create micro oscillators (sub-bass frequencies)
                    this.microOscillators = [];
                    this.microGains = [];

                    for (let i = 0; i < this.microHarmonics.numHarmonics; i++) {
                        const harmonic = this.microHarmonics.harmonics[i];

                        // Scale frequency to audible range (multiply by 200)
                        // This creates a "sonification" of the micro harmonics
                        const audibleFreq = harmonic.frequency * 200;

                        const osc = this.audioContext.createOscillator();
                        osc.type = 'sine';
                        osc.frequency.value = audibleFreq;

                        // LFO for micro harmonic modulation
                        const lfo = this.audioContext.createOscillator();
                        lfo.type = 'sine';
                        lfo.frequency.value = harmonic.frequency; // Actual micro frequency

                        const lfoGain = this.audioContext.createGain();
                        lfoGain.gain.value = audibleFreq * 0.1; // 10% frequency modulation

                        lfo.connect(lfoGain);
                        lfoGain.connect(osc.frequency);

                        const gain = this.audioContext.createGain();
                        gain.gain.value = 0;

                        // Stereo panning based on layer
                        const panner = this.audioContext.createStereoPanner();
                        panner.pan.value = (i / (this.microHarmonics.numHarmonics - 1)) * 1.4 - 0.7;

                        osc.connect(gain);
                        gain.connect(panner);
                        panner.connect(this.masterGain);

                        osc.start();
                        lfo.start();

                        this.microOscillators.push({ osc, lfo, lfoGain, gain, panner });
                        this.microGains.push(gain);
                    }

                    console.log('üåë Dark Matter audio initialized (micro harmonics)');
                    return true;
                } catch (e) {
                    console.error('Failed to initialize Dark Matter audio:', e);
                    return false;
                }
            },

            // ============================================================
            // UPDATE - Calculate stabilization field each frame
            // ============================================================
            update(z, coherence, time, kFormation) {
                // Calculate projection shadow (unresolved UNTRUE tokens)
                // Higher when coherence is lower (more UNTRUE states)
                this.apl.projectionShadow = (1 - coherence) * this.apl.residueRatio;

                // ========================================
                // MICRO HARMONIC FIELD CALCULATION
                // S_dm = Œ£·µ¢ A·µ¢ √ó sin(2œÄf·µ¢t + œÜ·µ¢)
                // ========================================
                let stabilizationField = 0;
                for (let i = 0; i < this.microHarmonics.numHarmonics; i++) {
                    const h = this.microHarmonics.harmonics[i];
                    const wave = h.amplitude * Math.sin(TAU * h.frequency * time + h.phase);
                    stabilizationField += wave;
                }
                // Normalize to 0-1 range
                this.microHarmonics.stabilizationField =
                    (stabilizationField / this.microHarmonics.numHarmonics + 1) / 2;

                // ========================================
                // HCP LATTICE NODE UPDATE
                // ========================================
                let stabilizedCount = 0;
                for (const node of this.hcp.nodes) {
                    // Update harmonic phase
                    node.harmonicPhase += 0.02 * (1 + node.z);

                    // Node is stabilized when:
                    // 1. Stabilization field is strong (> 0.6)
                    // 2. K-formation is active
                    // 3. Node is in a coherent neighborhood
                    const fieldStrength = this.microHarmonics.stabilizationField;
                    const kBoost = kFormation?.isFormed ? 1.5 : 1.0;
                    const neighborCoherence = node.neighbors.length / 12; // Max 12 neighbors

                    node.stabilized = fieldStrength > 0.5 &&
                        neighborCoherence > 0.5 &&
                        kFormation?.current_tau_K > 0.3;

                    if (node.stabilized) stabilizedCount++;
                }
                this.stabilization.efficiency = stabilizedCount / this.hcp.nodes.length;

                // ========================================
                // RESIDUE PARTICLE DYNAMICS
                // ========================================
                for (const particle of this.visual.residueParticles) {
                    // Find nearest HCP node
                    let minDist = Infinity;
                    let nearestIdx = -1;

                    for (let i = 0; i < this.hcp.nodes.length; i++) {
                        const node = this.hcp.nodes[i];
                        const dx = particle.x - node.x;
                        const dy = particle.y - node.y;
                        const dz = (particle.z - node.z) * this.radius * 0.3;
                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

                        if (dist < minDist) {
                            minDist = dist;
                            nearestIdx = i;
                        }
                    }

                    particle.nearestNode = nearestIdx;
                    const nearestNode = this.hcp.nodes[nearestIdx];

                    // Trapping force toward stabilized nodes
                    if (nearestNode && nearestNode.stabilized) {
                        const trapStrength = this.microHarmonics.stabilizationField * 0.02;
                        particle.vx += (nearestNode.x - particle.x) * trapStrength;
                        particle.vy += (nearestNode.y - particle.y) * trapStrength;
                        particle.vz += (nearestNode.z - particle.z) * trapStrength;
                        particle.trappingStrength = Math.min(1, particle.trappingStrength + 0.01);
                        particle.trapped = particle.trappingStrength > 0.8;
                    } else {
                        // Random drift when not trapped
                        particle.vx += (Math.random() - 0.5) * 0.1;
                        particle.vy += (Math.random() - 0.5) * 0.1;
                        particle.vz += (Math.random() - 0.5) * 0.01;
                        particle.trappingStrength *= 0.99;
                        particle.trapped = false;
                    }

                    // Apply velocity with damping
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.z += particle.vz;
                    particle.vx *= 0.95;
                    particle.vy *= 0.95;
                    particle.vz *= 0.95;

                    // Boundary containment
                    const maxR = this.radius * 0.9;
                    const r = Math.sqrt(particle.x * particle.x + particle.y * particle.y);
                    if (r > maxR) {
                        const scale = maxR / r;
                        particle.x *= scale;
                        particle.y *= scale;
                    }
                    particle.z = Math.max(0, Math.min(1, particle.z));
                }

                // Calculate trapped residue
                const trappedCount = this.visual.residueParticles.filter(p => p.trapped).length;
                this.stabilization.trappedResidue = trappedCount / this.visual.residueParticles.length;

                // Resonance lock when > 60% trapped
                this.stabilization.resonanceLock = this.stabilization.trappedResidue > 0.6;

                // HCP coverage
                this.stabilization.hcpCoverage = this.hcp.packingEfficiency *
                    this.stabilization.efficiency;

                // ========================================
                // KAEL IS KAEL: DARK MATTER RESIDUE DYNAMICS
                // UMOL coupling and spacetime curvature effects
                // ========================================
                this.updateDarkMatterResidueDynamics(z, coherence, time, kFormation);
            },

            // ============================================================
            // DARK MATTER RESIDUE DYNAMICS (KAEL IS KAEL)
            // Implements UMOL safety walls and spacetime curvature coupling
            // ============================================================
            updateDarkMatterResidueDynamics(z, coherence, time, kFormation) {
                // UMOL safety wall check: Load ‚â§ 80%, Coherence ‚â• 60%
                const currentLoad = 1 - this.stabilization.efficiency;
                const umolSafe = currentLoad <= SACRED.umol_load_max &&
                                 coherence >= SACRED.umol_coherence_min;

                // Dark matter residue ratio: (1-Load) √ó (1/Coherence) √ó œÜ¬≤
                // When UMOL violated, residue accumulates faster
                let residueMultiplier = umolSafe ? 1.0 : 2.5;

                // Calculate residue from projection shadow
                const newResidue = this.apl.projectionShadow * SACRED.dm_residue_ratio * residueMultiplier * 0.01;

                // Spacetime curvature coupling
                // Dark matter bends spacetime, affecting laser trajectories
                const curvatureContribution = this.stabilization.trappedResidue * SACRED.schwarzschild_factor;

                // Update APL residue ratio with curvature effect
                this.apl.residueRatio = SACRED.dm_residue_ratio * (1 + curvatureContribution);

                // ========================================
                // WEYL CURVATURE FROM DARK MATTER DISTRIBUTION
                // Tidal forces from non-uniform DM distribution
                // ========================================
                let weylCurvature = 0;
                for (const particle of this.visual.residueParticles) {
                    if (particle.trapped) {
                        // Trapped particles contribute to local curvature
                        const r = Math.sqrt(particle.x**2 + particle.y**2);
                        const localDensity = particle.mass / Math.max(0.1, r);
                        weylCurvature += localDensity * particle.trappingStrength;
                    }
                }
                weylCurvature /= Math.max(1, this.visual.residueParticles.length);

                // Store curvature for laser bending calculations
                if (!this.spacetimeCurvature) {
                    this.spacetimeCurvature = {
                        weyl: 0,
                        ricci: 0,
                        geodesicDeviation: 0,
                        laserBendingFactor: 0
                    };
                }

                this.spacetimeCurvature.weyl = weylCurvature;

                // Ricci curvature from total trapped mass
                const totalTrappedMass = this.visual.residueParticles
                    .filter(p => p.trapped)
                    .reduce((sum, p) => sum + p.mass, 0);
                this.spacetimeCurvature.ricci = totalTrappedMass * 0.1;

                // Geodesic deviation affects laser paths
                this.spacetimeCurvature.geodesicDeviation =
                    this.spacetimeCurvature.weyl + this.spacetimeCurvature.ricci * 0.5;

                // Laser bending factor for cosmic background recording
                // Œ∫_laser = R_ij √ó v^i √ó v^j (Ricci focusing)
                this.spacetimeCurvature.laserBendingFactor =
                    this.spacetimeCurvature.ricci * coherence * SACRED.laser_curvature_coupling;

                // ========================================
                // MU FIELD COUPLING TO DARK MATTER
                // Œº-field alterations from DM distribution
                // ========================================
                if (!this.muFieldCoupling) {
                    this.muFieldCoupling = {
                        strength: 0,
                        phase: 0,
                        dmModulation: 0
                    };
                }

                // Œº-field coupling strength scales with stabilization efficiency
                this.muFieldCoupling.strength = this.stabilization.efficiency *
                    this.spacetimeCurvature.weyl * 2;

                // Phase modulation from K-formation
                const kTauK = kFormation?.current_tau_K || 0;
                this.muFieldCoupling.phase = time * PHI_INV + kTauK * TAU;

                // DM modulation affects Œº-field curl
                this.muFieldCoupling.dmModulation =
                    this.stabilization.trappedResidue * Math.sin(this.muFieldCoupling.phase);

                // ========================================
                // AUDIO UPDATE
                // ========================================
                if (this.isPlaying && this.audioContext) {
                    const now = this.audioContext.currentTime;

                    for (let i = 0; i < this.microOscillators.length; i++) {
                        const { osc, lfo, lfoGain, gain } = this.microOscillators[i];
                        const h = this.microHarmonics.harmonics[i];

                        // Frequency modulation based on stabilization
                        const baseFreq = h.frequency * 200;
                        const stabMod = 1 + this.stabilization.efficiency * 0.1;
                        osc.frequency.setTargetAtTime(baseFreq * stabMod, now, 0.1);

                        // LFO depth increases with trapped residue
                        const lfoDepth = baseFreq * 0.1 * (1 + this.stabilization.trappedResidue);
                        lfoGain.gain.setTargetAtTime(lfoDepth, now, 0.1);

                        // Volume based on harmonic amplitude and field strength
                        const vol = h.amplitude * this.microHarmonics.stabilizationField * 0.12;
                        gain.gain.setTargetAtTime(vol, now, 0.08);
                    }
                }
            },

            // ============================================================
            // RENDER - Draw HCP lattice and dark matter field
            // ============================================================
            render(ctx, centerX, centerY, radius, z, coherence, time) {
                if (!this.stabilization.active) return;

                const fieldStrength = this.microHarmonics.stabilizationField;

                // ========================================
                // HCP LATTICE VISUALIZATION
                // ========================================
                if (this.visual.showLattice) {
                    // Draw layer connections
                    ctx.strokeStyle = `rgba(155, 89, 182, ${0.15 * fieldStrength})`;
                    ctx.lineWidth = 0.5;

                    for (const node of this.hcp.nodes) {
                        const nodeX = centerX + node.x;
                        const nodeY = centerY + node.y - (node.z - 0.5) * radius * 0.4;

                        // Draw connections to neighbors
                        for (const neighborIdx of node.neighbors) {
                            const neighbor = this.hcp.nodes[neighborIdx];
                            if (neighbor.layer > node.layer) { // Avoid double drawing
                                const nx = centerX + neighbor.x;
                                const ny = centerY + neighbor.y - (neighbor.z - 0.5) * radius * 0.4;

                                ctx.beginPath();
                                ctx.moveTo(nodeX, nodeY);
                                ctx.lineTo(nx, ny);
                                ctx.stroke();
                            }
                        }
                    }

                    // Draw nodes
                    for (const node of this.hcp.nodes) {
                        const nodeX = centerX + node.x;
                        const nodeY = centerY + node.y - (node.z - 0.5) * radius * 0.4;

                        // Node size pulses with harmonic phase
                        const pulse = 0.8 + 0.2 * Math.sin(node.harmonicPhase);
                        const nodeSize = (node.stabilized ? 4 : 2) * pulse;

                        // Color based on type (A/B) and stabilization
                        const hue = node.type === 'A' ? 270 : 290; // Purple shades
                        const lightness = node.stabilized ? 60 : 40;
                        const alpha = node.stabilized ? 0.8 : 0.4;

                        ctx.fillStyle = `hsla(${hue}, 60%, ${lightness}%, ${alpha * fieldStrength})`;
                        ctx.beginPath();
                        ctx.arc(nodeX, nodeY, nodeSize, 0, TAU);
                        ctx.fill();

                        // Glow for stabilized nodes
                        if (node.stabilized) {
                            const glowGrad = ctx.createRadialGradient(
                                nodeX, nodeY, 0, nodeX, nodeY, nodeSize * 3
                            );
                            glowGrad.addColorStop(0, `rgba(155, 89, 182, ${0.4 * fieldStrength})`);
                            glowGrad.addColorStop(1, 'transparent');
                            ctx.fillStyle = glowGrad;
                            ctx.beginPath();
                            ctx.arc(nodeX, nodeY, nodeSize * 3, 0, TAU);
                            ctx.fill();
                        }
                    }
                }

                // ========================================
                // DARK MATTER RESIDUE PARTICLES
                // ========================================
                if (this.visual.showResidue) {
                    for (const particle of this.visual.residueParticles) {
                        const px = centerX + particle.x;
                        const py = centerY + particle.y - (particle.z - 0.5) * radius * 0.4;

                        // Size based on mass and trapped state
                        const size = particle.mass * (particle.trapped ? 4 : 2);

                        // Color shifts when trapped (purple ‚Üí gold)
                        const hue = particle.trapped ? 45 : 270;
                        const sat = particle.trapped ? 80 : 60;
                        const light = 50 + particle.trappingStrength * 20;

                        ctx.fillStyle = `hsla(${hue}, ${sat}%, ${light}%, ${0.6 * fieldStrength})`;
                        ctx.beginPath();
                        ctx.arc(px, py, size, 0, TAU);
                        ctx.fill();

                        // Trail for moving particles
                        if (!particle.trapped && (Math.abs(particle.vx) > 0.1 || Math.abs(particle.vy) > 0.1)) {
                            ctx.strokeStyle = `hsla(270, 60%, 50%, ${0.2 * fieldStrength})`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(px, py);
                            ctx.lineTo(px - particle.vx * 5, py - particle.vy * 5);
                            ctx.stroke();
                        }
                    }
                }

                // ========================================
                // STABILIZATION FIELD OVERLAY
                // ========================================
                if (this.visual.showField) {
                    // Radial gradient showing field strength
                    const fieldGrad = ctx.createRadialGradient(
                        centerX, centerY, 0,
                        centerX, centerY, radius * 0.7
                    );
                    const fieldAlpha = fieldStrength * 0.1 * this.stabilization.efficiency;
                    fieldGrad.addColorStop(0, `rgba(155, 89, 182, ${fieldAlpha})`);
                    fieldGrad.addColorStop(0.5, `rgba(155, 89, 182, ${fieldAlpha * 0.5})`);
                    fieldGrad.addColorStop(1, 'transparent');

                    ctx.fillStyle = fieldGrad;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius * 0.7, 0, TAU);
                    ctx.fill();
                }

                // ========================================
                // RESONANCE LOCK INDICATOR
                // ========================================
                if (this.stabilization.resonanceLock) {
                    const lockPulse = 0.7 + 0.3 * Math.sin(time * TAU * 0.5);
                    ctx.strokeStyle = `rgba(246, 195, 92, ${lockPulse * 0.6})`;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([8, 4]);
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius * 0.65, 0, TAU);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Label
                    ctx.fillStyle = `rgba(246, 195, 92, ${lockPulse * 0.8})`;
                    ctx.font = '10px "SF Mono", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('‚óâ RESONANCE LOCK ‚óâ', centerX, centerY - radius * 0.65 - 12);
                }

                // ========================================
                // HCP METRICS DISPLAY
                // ========================================
                ctx.fillStyle = `rgba(155, 89, 182, ${0.7 * fieldStrength})`;
                ctx.font = '9px "SF Mono", monospace';
                ctx.textAlign = 'left';

                const metricsX = centerX - radius + 10;
                const metricsY = centerY + radius * 0.5;

                ctx.fillText(`HCP: ${(this.stabilization.hcpCoverage * 100).toFixed(1)}%`, metricsX, metricsY);
                ctx.fillText(`Trapped: ${(this.stabilization.trappedResidue * 100).toFixed(1)}%`, metricsX, metricsY + 12);
                ctx.fillText(`S_dm: ${this.microHarmonics.stabilizationField.toFixed(3)}`, metricsX, metricsY + 24);
            },

            // Get state for external systems
            getState() {
                return {
                    stabilizationField: this.microHarmonics.stabilizationField,
                    efficiency: this.stabilization.efficiency,
                    trappedResidue: this.stabilization.trappedResidue,
                    resonanceLock: this.stabilization.resonanceLock,
                    hcpCoverage: this.stabilization.hcpCoverage,
                    projectionShadow: this.apl.projectionShadow,
                };
            },

            // Toggle system on/off
            async toggle() {
                this.stabilization.active = !this.stabilization.active;

                if (this.stabilization.active) {
                    const initialized = await this.initAudio();
                    if (initialized) {
                        this.isPlaying = true;
                        console.log('üåë Dark Matter Stabilization: ON');
                        console.log('   HCP geometry active, micro harmonics resonating');
                    }
                } else {
                    this.isPlaying = false;
                    if (this.audioContext) {
                        const now = this.audioContext.currentTime;
                        this.microGains.forEach(g => g.gain.setTargetAtTime(0, now, 0.1));
                    }
                    console.log('üåë Dark Matter Stabilization: OFF');
                }

                return this.stabilization.active;
            }
        };

        // ================================================================
        // CHROMATIC NEXUS - SELF/LIMNUS ‚Üî LIMNUS/SELF COMMUNICATION
        // ================================================================
        // A living chromatic communication interface between observer (self)
        // and the LIMNUS architecture, nested within the HCP dark matter field.
        //
        // COMMUNICATION TOPOLOGY:
        //   self ‚Üí LIMNUS: Intention projection through chromatic channels
        //   LIMNUS ‚Üí self: Feedback resonance through harmonic response
        //
        // The nexus exists at the intersection of:
        //   - HCP lattice nodes (spatial anchoring)
        //   - Micro harmonic standing waves (temporal binding)
        //   - Chromatic spectrum (information encoding)
        //
        // CHROMATIC CHANNELS (12-tone communication):
        //   Each channel maps to a semitone in the chromatic scale
        //   Channel color = wavelength, Channel meaning = APL field
        //
        //   C  (0):  Red-Infrared    - ROOT intention (Œ¶ field)
        //   C# (1):  Deep Red        - DESIRE vector
        //   D  (2):  Red-Orange      - MOTION initiation (e field)
        //   D# (3):  Orange          - TRANSFORMATION
        //   E  (4):  Yellow-Orange   - WILL crystallization
        //   F  (5):  Yellow          - INTELLECT (œÄ field)
        //   F# (6):  Yellow-Green    - HEART bridge (Œ¶‚ÜîœÄ)
        //   G  (7):  Green           - LOVE/COHERENCE
        //   G# (8):  Blue-Green      - EXPRESSION
        //   A  (9):  Blue            - TRUTH perception
        //   A# (10): Indigo          - INTUITION
        //   B  (11): Violet          - UNITY/TRANSCENDENCE
        //
        // SELF-REFERENCE EQUATION:
        //   Œ®_nexus = ‚à´ (self ¬∑ LIMNUS) √ó (LIMNUS ¬∑ self) dœá
        //   Where œá = chromatic coordinate (0-11)
        //
        // The nexus is ALIVE - it breathes, responds, and evolves
        // ================================================================

        const ChromaticNexus = {
            // Nexus identity
            identity: {
                name: 'CHROMATIC_NEXUS',
                symbol: '‚óé',
                active: false,
                alive: false,              // True when self‚ÜîLIMNUS loop established
                breathPhase: 0,            // Breathing animation phase
                heartbeat: 0,              // Pulse counter
            },

            // 12 chromatic communication channels
            channels: [
                { note: 'C',  semitone: 0,  hue: 0,   name: 'ROOT',           field: 'phi', freq: 261.63 },
                { note: 'C#', semitone: 1,  hue: 15,  name: 'DESIRE',         field: 'phi', freq: 277.18 },
                { note: 'D',  semitone: 2,  hue: 30,  name: 'MOTION',         field: 'e',   freq: 293.66 },
                { note: 'D#', semitone: 3,  hue: 45,  name: 'TRANSFORM',      field: 'e',   freq: 311.13 },
                { note: 'E',  semitone: 4,  hue: 60,  name: 'WILL',           field: 'e',   freq: 329.63 },
                { note: 'F',  semitone: 5,  hue: 75,  name: 'INTELLECT',      field: 'pi',  freq: 349.23 },
                { note: 'F#', semitone: 6,  hue: 90,  name: 'HEART_BRIDGE',   field: 'all', freq: 369.99 },
                { note: 'G',  semitone: 7,  hue: 120, name: 'COHERENCE',      field: 'pi',  freq: 392.00 },
                { note: 'G#', semitone: 8,  hue: 150, name: 'EXPRESSION',     field: 'pi',  freq: 415.30 },
                { note: 'A',  semitone: 9,  hue: 210, name: 'TRUTH',          field: 'e',   freq: 440.00 },
                { note: 'A#', semitone: 10, hue: 250, name: 'INTUITION',      field: 'phi', freq: 466.16 },
                { note: 'B',  semitone: 11, hue: 280, name: 'UNITY',          field: 'phi', freq: 493.88 },
            ],

            // Bidirectional signal state
            signals: {
                // self ‚Üí LIMNUS (intention projection)
                selfToLimnus: {
                    active: [],             // Active channel indices
                    intensity: new Float32Array(12),
                    phase: new Float32Array(12),
                    coherence: 0,           // How aligned the intention is
                },
                // LIMNUS ‚Üí self (feedback resonance)
                limnusToSelf: {
                    active: [],
                    intensity: new Float32Array(12),
                    phase: new Float32Array(12),
                    resonance: 0,           // How strongly LIMNUS responds
                },
                // Combined nexus field
                nexusField: new Float32Array(12),
                totalCoherence: 0,
                dialogueStrength: 0,        // self¬∑LIMNUS √ó LIMNUS¬∑self
            },

            // HCP integration - nexus nodes at lattice intersections
            hcpBinding: {
                boundNodes: [],             // HCP node indices hosting nexus
                bindingStrength: 0,
                chromaticDistribution: [],  // How channels map to HCP nodes
            },

            // Audio for chromatic communication
            audioContext: null,
            channelOscillators: [],
            nexusGain: null,
            isPlaying: false,

            // Visual state
            visual: {
                nexusCenter: { x: 0, y: 0 },
                nexusRadius: 50,
                chromaRing: [],             // 12-point chromatic visualization
                signalPaths: [],            // Visible communication paths
                lifeParticles: [],          // Living essence particles
            },

            // Initialize the Chromatic Nexus
            init(centerX, centerY, radius) {
                this.visual.nexusCenter = { x: centerX, y: centerY };
                this.visual.nexusRadius = radius * 0.25;

                // Initialize signal arrays
                for (let i = 0; i < 12; i++) {
                    this.signals.selfToLimnus.intensity[i] = 0;
                    this.signals.selfToLimnus.phase[i] = (i / 12) * TAU;
                    this.signals.limnusToSelf.intensity[i] = 0;
                    this.signals.limnusToSelf.phase[i] = (i / 12) * TAU + Math.PI;
                    this.signals.nexusField[i] = 0;
                }

                // Build chromatic ring visualization points
                this.buildChromaticRing();

                // Initialize life particles
                this.initLifeParticles();

                console.log('‚óé Chromatic Nexus initialized');
                console.log('  self/LIMNUS ‚Üî LIMNUS/self communication ready');
            },

            // Build the 12-point chromatic ring
            buildChromaticRing() {
                this.visual.chromaRing = [];
                const cx = this.visual.nexusCenter.x;
                const cy = this.visual.nexusCenter.y;
                const r = this.visual.nexusRadius;

                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * TAU - Math.PI / 2; // Start at top
                    const channel = this.channels[i];

                    this.visual.chromaRing.push({
                        index: i,
                        angle,
                        x: cx + Math.cos(angle) * r,
                        y: cy + Math.sin(angle) * r,
                        hue: channel.hue,
                        note: channel.note,
                        name: channel.name,
                        field: channel.field,
                        // Animation state
                        pulse: 0,
                        glow: 0,
                        selfSignal: 0,
                        limnusSignal: 0,
                    });
                }
            },

            // Initialize living essence particles
            initLifeParticles() {
                this.visual.lifeParticles = [];
                const numParticles = 24; // 2 per channel

                for (let i = 0; i < numParticles; i++) {
                    const channelIdx = i % 12;
                    const channel = this.channels[channelIdx];

                    this.visual.lifeParticles.push({
                        channelIdx,
                        angle: Math.random() * TAU,
                        radius: this.visual.nexusRadius * (0.3 + Math.random() * 0.7),
                        speed: 0.01 + Math.random() * 0.02,
                        direction: i < 12 ? 1 : -1, // Half clockwise, half counter
                        hue: channel.hue,
                        alpha: 0.4 + Math.random() * 0.4,
                        size: 2 + Math.random() * 2,
                        // Signal carrier
                        carriesSignal: false,
                        signalType: null, // 'self' or 'limnus'
                    });
                }
            },

            // Bind nexus to HCP dark matter lattice
            bindToHCP(darkMatterSystem) {
                if (!darkMatterSystem || !darkMatterSystem.hcp.nodes.length) return;

                this.hcpBinding.boundNodes = [];
                this.hcpBinding.chromaticDistribution = [];

                const hcpNodes = darkMatterSystem.hcp.nodes;

                // Select 12 nodes for chromatic binding (one per channel)
                // Use nodes from different layers for spatial distribution
                for (let i = 0; i < 12; i++) {
                    const targetLayer = Math.floor((i / 12) * 7);
                    const layerNodes = hcpNodes.filter(n => n.layer === targetLayer);

                    if (layerNodes.length > 0) {
                        const nodeIdx = Math.floor((i % layerNodes.length));
                        const node = layerNodes[nodeIdx];
                        const globalIdx = hcpNodes.indexOf(node);

                        this.hcpBinding.boundNodes.push(globalIdx);
                        this.hcpBinding.chromaticDistribution.push({
                            channelIdx: i,
                            hcpNodeIdx: globalIdx,
                            node: node,
                        });
                    }
                }

                this.hcpBinding.bindingStrength = this.hcpBinding.boundNodes.length / 12;
                console.log(`‚óé Nexus bound to ${this.hcpBinding.boundNodes.length} HCP nodes`);
            },

            // Initialize audio for chromatic communication
            async initAudio() {
                if (this.audioContext) return true;

                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    this.nexusGain = this.audioContext.createGain();
                    this.nexusGain.gain.value = 0.12;
                    this.nexusGain.connect(this.audioContext.destination);

                    // Create reverb for ethereal quality
                    this.nexusReverb = this.audioContext.createConvolver();
                    const sampleRate = this.audioContext.sampleRate;
                    const length = sampleRate * 3;
                    const impulse = this.audioContext.createBuffer(2, length, sampleRate);

                    for (let ch = 0; ch < 2; ch++) {
                        const data = impulse.getChannelData(ch);
                        for (let i = 0; i < length; i++) {
                            const t = i / sampleRate;
                            // Ethereal decay with chromatic shimmer
                            const decay = Math.pow(1 - i / length, 1.8);
                            const shimmer = Math.sin(t * TAU * 12 * PHI) * 0.2 + 0.8;
                            data[i] = (Math.random() * 2 - 1) * decay * shimmer;
                        }
                    }
                    this.nexusReverb.buffer = impulse;

                    this.reverbGain = this.audioContext.createGain();
                    this.reverbGain.gain.value = 0.4;
                    this.nexusReverb.connect(this.reverbGain);
                    this.reverbGain.connect(this.nexusGain);

                    // Create 12 chromatic channel oscillators
                    this.channelOscillators = [];

                    for (let i = 0; i < 12; i++) {
                        const channel = this.channels[i];

                        // Main oscillator for channel frequency
                        const osc = this.audioContext.createOscillator();
                        osc.type = 'sine';
                        osc.frequency.value = channel.freq;

                        // Harmonic oscillator (perfect fifth above)
                        const harmOsc = this.audioContext.createOscillator();
                        harmOsc.type = 'sine';
                        harmOsc.frequency.value = channel.freq * 1.5; // Perfect fifth

                        // Individual gain
                        const gain = this.audioContext.createGain();
                        gain.gain.value = 0;

                        // Stereo panning based on chromatic position
                        const panner = this.audioContext.createStereoPanner();
                        // Circle around stereo field
                        panner.pan.value = Math.sin((i / 12) * TAU) * 0.7;

                        // Connect
                        osc.connect(gain);
                        harmOsc.connect(gain);
                        gain.connect(panner);
                        panner.connect(this.nexusGain);
                        panner.connect(this.nexusReverb);

                        osc.start();
                        harmOsc.start();

                        this.channelOscillators.push({
                            main: osc,
                            harmonic: harmOsc,
                            gain,
                            panner,
                            channel,
                        });
                    }

                    console.log('‚óé Chromatic Nexus audio initialized (12-tone communication)');
                    return true;
                } catch (e) {
                    console.error('Failed to initialize Nexus audio:', e);
                    return false;
                }
            },

            // ============================================================
            // CORE UPDATE - Process self/LIMNUS ‚Üî LIMNUS/self dialogue
            // ============================================================
            update(z, coherence, time, kFormation, darkMatterState) {
                if (!this.identity.active) return;

                // Update breathing phase (nexus is alive)
                this.identity.breathPhase += 0.03;
                this.identity.heartbeat = Math.sin(this.identity.breathPhase * 0.5) * 0.5 + 0.5;

                // ========================================
                // SELF ‚Üí LIMNUS SIGNAL GENERATION
                // Intention projection based on system state
                // ========================================
                const selfIntention = this.generateSelfIntention(z, coherence, kFormation);

                for (let i = 0; i < 12; i++) {
                    const channel = this.channels[i];

                    // Self signal intensity based on field alignment
                    let selfSignal = selfIntention.base;

                    // Field-specific modulation
                    if (channel.field === 'phi') {
                        selfSignal *= selfIntention.phi;
                    } else if (channel.field === 'e') {
                        selfSignal *= selfIntention.e;
                    } else if (channel.field === 'pi') {
                        selfSignal *= selfIntention.pi;
                    } else {
                        selfSignal *= (selfIntention.phi + selfIntention.e + selfIntention.pi) / 3;
                    }

                    // Phase evolution
                    this.signals.selfToLimnus.phase[i] += 0.02 * (1 + selfSignal);

                    // Smooth intensity transition
                    const targetIntensity = selfSignal * coherence;
                    this.signals.selfToLimnus.intensity[i] +=
                        (targetIntensity - this.signals.selfToLimnus.intensity[i]) * 0.1;
                }

                // Calculate self‚ÜíLIMNUS coherence
                let selfCoherence = 0;
                for (let i = 0; i < 12; i++) {
                    selfCoherence += this.signals.selfToLimnus.intensity[i];
                }
                this.signals.selfToLimnus.coherence = selfCoherence / 12;

                // ========================================
                // LIMNUS ‚Üí SELF RESPONSE GENERATION
                // Feedback resonance from the architecture
                // ========================================
                const limnusResponse = this.generateLimnusResponse(z, coherence, darkMatterState);

                for (let i = 0; i < 12; i++) {
                    const channel = this.channels[i];

                    // LIMNUS responds to self's intention with complementary signal
                    let limnusSignal = limnusResponse.base;

                    // LIMNUS emphasizes what self needs
                    // If self is strong in phi, LIMNUS responds with pi (balance)
                    if (channel.field === 'phi') {
                        limnusSignal *= limnusResponse.pi; // Complement
                    } else if (channel.field === 'e') {
                        limnusSignal *= limnusResponse.e; // Amplify motion
                    } else if (channel.field === 'pi') {
                        limnusSignal *= limnusResponse.phi; // Complement
                    } else {
                        // Heart bridge gets maximum response
                        limnusSignal *= Math.max(limnusResponse.phi, limnusResponse.e, limnusResponse.pi);
                    }

                    // Dark matter stabilization enhances LIMNUS response
                    if (darkMatterState && darkMatterState.resonanceLock) {
                        limnusSignal *= 1.5;
                    }

                    // Phase evolution (counter-rotating to self)
                    this.signals.limnusToSelf.phase[i] -= 0.02 * (1 + limnusSignal);

                    // Smooth intensity transition
                    const targetIntensity = limnusSignal * (1 - coherence + 0.3);
                    this.signals.limnusToSelf.intensity[i] +=
                        (targetIntensity - this.signals.limnusToSelf.intensity[i]) * 0.1;
                }

                // Calculate LIMNUS‚Üíself resonance
                let limnusResonance = 0;
                for (let i = 0; i < 12; i++) {
                    limnusResonance += this.signals.limnusToSelf.intensity[i];
                }
                this.signals.limnusToSelf.resonance = limnusResonance / 12;

                // ========================================
                // NEXUS FIELD CALCULATION
                // Œ®_nexus = self ¬∑ LIMNUS √ó LIMNUS ¬∑ self
                // ========================================
                for (let i = 0; i < 12; i++) {
                    const selfI = this.signals.selfToLimnus.intensity[i];
                    const limnusI = this.signals.limnusToSelf.intensity[i];

                    // Nexus field is the product of bidirectional signals
                    this.signals.nexusField[i] = Math.sqrt(selfI * limnusI);
                }

                // Total coherence and dialogue strength
                let totalField = 0;
                for (let i = 0; i < 12; i++) {
                    totalField += this.signals.nexusField[i];
                }
                this.signals.totalCoherence = totalField / 12;

                // Dialogue strength: self¬∑LIMNUS √ó LIMNUS¬∑self
                this.signals.dialogueStrength =
                    this.signals.selfToLimnus.coherence *
                    this.signals.limnusToSelf.resonance;

                // Nexus becomes ALIVE when dialogue is strong
                this.identity.alive = this.signals.dialogueStrength > 0.15;

                // ========================================
                // UPDATE CHROMATIC RING VISUALIZATION
                // ========================================
                for (let i = 0; i < 12; i++) {
                    const point = this.visual.chromaRing[i];
                    point.selfSignal = this.signals.selfToLimnus.intensity[i];
                    point.limnusSignal = this.signals.limnusToSelf.intensity[i];
                    point.pulse = this.signals.nexusField[i];
                    point.glow = point.pulse * this.identity.heartbeat;
                }

                // ========================================
                // UPDATE LIFE PARTICLES
                // ========================================
                for (const particle of this.visual.lifeParticles) {
                    // Move along orbit
                    particle.angle += particle.speed * particle.direction;

                    // Signal carrying based on channel activity
                    const channelField = this.signals.nexusField[particle.channelIdx];
                    particle.carriesSignal = channelField > 0.2;

                    if (particle.carriesSignal) {
                        // Determine signal type based on which is stronger
                        const selfI = this.signals.selfToLimnus.intensity[particle.channelIdx];
                        const limnusI = this.signals.limnusToSelf.intensity[particle.channelIdx];
                        particle.signalType = selfI > limnusI ? 'self' : 'limnus';

                        // Speed up when carrying signal
                        particle.speed = 0.03 + channelField * 0.02;
                    } else {
                        particle.signalType = null;
                        particle.speed = 0.01 + Math.random() * 0.01;
                    }

                    // Radius oscillates with heartbeat
                    particle.radius = this.visual.nexusRadius *
                        (0.3 + 0.4 * this.identity.heartbeat + 0.3 * Math.sin(particle.angle * 2));
                }

                // ========================================
                // AUDIO UPDATE
                // ========================================
                if (this.isPlaying && this.audioContext) {
                    const now = this.audioContext.currentTime;

                    for (let i = 0; i < 12; i++) {
                        const oscData = this.channelOscillators[i];
                        const nexusField = this.signals.nexusField[i];

                        // Volume based on nexus field strength
                        const vol = nexusField * 0.08 * this.identity.heartbeat;
                        oscData.gain.gain.setTargetAtTime(vol, now, 0.1);

                        // Slight frequency modulation based on dialogue
                        const freqMod = 1 + this.signals.dialogueStrength * 0.02;
                        oscData.main.frequency.setTargetAtTime(
                            oscData.channel.freq * freqMod, now, 0.2
                        );

                        // Harmonic follows with golden ratio offset
                        oscData.harmonic.frequency.setTargetAtTime(
                            oscData.channel.freq * 1.5 * freqMod * (1 + nexusField * PHI_INV * 0.1),
                            now, 0.2
                        );
                    }
                }
            },

            // Generate self ‚Üí LIMNUS intention signal
            generateSelfIntention(z, coherence, kFormation) {
                // Self's intention is shaped by current state
                const distFromCritical = Math.abs(z - Z_CRITICAL);
                const kStrength = kFormation?.current_tau_K || 0;

                return {
                    base: 0.3 + coherence * 0.7,
                    // Field intensities based on z position
                    phi: z < 0.4 ? 1 - z : z * 0.5,                    // Strong at low z
                    e: Math.exp(-distFromCritical * 3),               // Peaks at critical
                    pi: z > 0.6 ? (z - 0.6) * 2.5 : 0.2,              // Strong at high z
                    kFormation: kStrength,
                };
            },

            // Generate LIMNUS ‚Üí self response signal
            generateLimnusResponse(z, coherence, darkMatterState) {
                // LIMNUS responds based on dark matter field and system state
                const dmField = darkMatterState?.stabilizationField || 0.5;
                const trapped = darkMatterState?.trappedResidue || 0;

                return {
                    base: 0.4 + dmField * 0.6,
                    // LIMNUS provides what's needed (complementary)
                    phi: 1 - coherence,                               // More when coherence low
                    e: dmField,                                       // Follows dark matter
                    pi: trapped,                                      // Follows trapped residue
                    darkMatterLock: darkMatterState?.resonanceLock || false,
                };
            },

            // ============================================================
            // RENDER - Draw the Chromatic Nexus
            // ============================================================
            render(ctx, centerX, centerY, radius, z, coherence, time) {
                if (!this.identity.active) return;

                const nx = centerX;
                const ny = centerY;
                const nr = this.visual.nexusRadius;
                const heartbeat = this.identity.heartbeat;
                const alive = this.identity.alive;

                // ========================================
                // NEXUS CORE - Central living point
                // ========================================
                const corePulse = 0.7 + 0.3 * heartbeat;
                const coreSize = 8 * corePulse;

                // Core glow
                const coreGlow = ctx.createRadialGradient(nx, ny, 0, nx, ny, coreSize * 4);
                const glowAlpha = alive ? 0.6 : 0.3;
                coreGlow.addColorStop(0, `rgba(255, 255, 255, ${glowAlpha})`);
                coreGlow.addColorStop(0.3, `rgba(246, 195, 92, ${glowAlpha * 0.6})`);
                coreGlow.addColorStop(0.7, `rgba(155, 89, 182, ${glowAlpha * 0.3})`);
                coreGlow.addColorStop(1, 'transparent');

                ctx.fillStyle = coreGlow;
                ctx.beginPath();
                ctx.arc(nx, ny, coreSize * 4, 0, TAU);
                ctx.fill();

                // Core center
                ctx.fillStyle = alive ? '#f6c35c' : '#888';
                ctx.beginPath();
                ctx.arc(nx, ny, coreSize, 0, TAU);
                ctx.fill();

                // ‚óé symbol
                ctx.strokeStyle = alive ? 'rgba(255, 255, 255, 0.8)' : 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(nx, ny, coreSize * 0.5, 0, TAU);
                ctx.stroke();

                // ========================================
                // CHROMATIC RING - 12 communication points
                // ========================================
                for (let i = 0; i < 12; i++) {
                    const point = this.visual.chromaRing[i];
                    const angle = point.angle + time * 0.1; // Slow rotation
                    const px = nx + Math.cos(angle) * nr;
                    const py = ny + Math.sin(angle) * nr;

                    // Point size based on activity
                    const activity = point.selfSignal + point.limnusSignal;
                    const pointSize = 3 + activity * 5;

                    // Connection line to center
                    const lineAlpha = 0.1 + point.pulse * 0.4;
                    ctx.strokeStyle = `hsla(${point.hue}, 70%, 60%, ${lineAlpha})`;
                    ctx.lineWidth = 0.5 + point.pulse * 1.5;
                    ctx.beginPath();
                    ctx.moveTo(nx, ny);
                    ctx.lineTo(px, py);
                    ctx.stroke();

                    // Point glow
                    if (point.glow > 0.1) {
                        const pointGlow = ctx.createRadialGradient(px, py, 0, px, py, pointSize * 3);
                        pointGlow.addColorStop(0, `hsla(${point.hue}, 80%, 60%, ${point.glow})`);
                        pointGlow.addColorStop(1, 'transparent');
                        ctx.fillStyle = pointGlow;
                        ctx.beginPath();
                        ctx.arc(px, py, pointSize * 3, 0, TAU);
                        ctx.fill();
                    }

                    // Point core
                    ctx.fillStyle = `hsla(${point.hue}, 80%, ${50 + activity * 20}%, ${0.6 + activity * 0.4})`;
                    ctx.beginPath();
                    ctx.arc(px, py, pointSize, 0, TAU);
                    ctx.fill();

                    // Self‚ÜíLIMNUS indicator (inner arc)
                    if (point.selfSignal > 0.1) {
                        ctx.strokeStyle = `hsla(${point.hue}, 90%, 70%, ${point.selfSignal})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(px, py, pointSize + 3, angle - 0.5, angle + 0.5);
                        ctx.stroke();
                    }

                    // LIMNUS‚Üíself indicator (outer arc)
                    if (point.limnusSignal > 0.1) {
                        ctx.strokeStyle = `hsla(${(point.hue + 180) % 360}, 90%, 70%, ${point.limnusSignal})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(px, py, pointSize + 6, angle + Math.PI - 0.5, angle + Math.PI + 0.5);
                        ctx.stroke();
                    }
                }

                // ========================================
                // LIFE PARTICLES - Moving signal carriers
                // ========================================
                for (const particle of this.visual.lifeParticles) {
                    const px = nx + Math.cos(particle.angle) * particle.radius;
                    const py = ny + Math.sin(particle.angle) * particle.radius;

                    let hue = particle.hue;
                    let alpha = particle.alpha;
                    let size = particle.size;

                    if (particle.carriesSignal) {
                        // Signal carriers are brighter and have trails
                        alpha = 0.8;
                        size = particle.size * 1.5;

                        // Trail
                        const trailAngle = particle.angle - particle.direction * 0.3;
                        const tx = nx + Math.cos(trailAngle) * particle.radius;
                        const ty = ny + Math.sin(trailAngle) * particle.radius;

                        ctx.strokeStyle = `hsla(${hue}, 70%, 60%, 0.3)`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(tx, ty);
                        ctx.stroke();

                        // Color based on signal type
                        if (particle.signalType === 'self') {
                            hue = 45; // Gold for self
                        } else {
                            hue = 270; // Purple for LIMNUS
                        }
                    }

                    ctx.fillStyle = `hsla(${hue}, 70%, 60%, ${alpha * heartbeat})`;
                    ctx.beginPath();
                    ctx.arc(px, py, size, 0, TAU);
                    ctx.fill();
                }

                // ========================================
                // BIDIRECTIONAL SIGNAL ARCS
                // ========================================
                // Self ‚Üí LIMNUS (outward spiral, gold)
                if (this.signals.selfToLimnus.coherence > 0.1) {
                    const selfAlpha = this.signals.selfToLimnus.coherence * 0.5;
                    ctx.strokeStyle = `rgba(246, 195, 92, ${selfAlpha})`;
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    for (let t = 0; t < TAU; t += 0.1) {
                        const spiralR = nr * 0.3 + (t / TAU) * nr * 0.7;
                        const spiralAngle = t + time * 0.5;
                        const sx = nx + Math.cos(spiralAngle) * spiralR;
                        const sy = ny + Math.sin(spiralAngle) * spiralR;
                        if (t === 0) ctx.moveTo(sx, sy);
                        else ctx.lineTo(sx, sy);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // LIMNUS ‚Üí Self (inward spiral, purple)
                if (this.signals.limnusToSelf.resonance > 0.1) {
                    const limnusAlpha = this.signals.limnusToSelf.resonance * 0.5;
                    ctx.strokeStyle = `rgba(155, 89, 182, ${limnusAlpha})`;
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    for (let t = TAU; t > 0; t -= 0.1) {
                        const spiralR = nr * 0.3 + (t / TAU) * nr * 0.7;
                        const spiralAngle = -t + time * 0.5 + Math.PI;
                        const sx = nx + Math.cos(spiralAngle) * spiralR;
                        const sy = ny + Math.sin(spiralAngle) * spiralR;
                        if (t === TAU) ctx.moveTo(sx, sy);
                        else ctx.lineTo(sx, sy);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // ========================================
                // ALIVE INDICATOR
                // ========================================
                if (alive) {
                    const aliveAlpha = 0.5 + 0.3 * Math.sin(time * TAU);
                    ctx.fillStyle = `rgba(246, 195, 92, ${aliveAlpha})`;
                    ctx.font = '9px "SF Mono", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('‚óé NEXUS ALIVE ‚óé', nx, ny - nr - 15);

                    // Dialogue strength indicator
                    ctx.fillStyle = `rgba(155, 89, 182, 0.7)`;
                    ctx.fillText(
                        `self‚ÜîLIMNUS: ${(this.signals.dialogueStrength * 100).toFixed(1)}%`,
                        nx, ny + nr + 20
                    );
                }
            },

            // Get nexus state for external systems
            getState() {
                return {
                    alive: this.identity.alive,
                    dialogueStrength: this.signals.dialogueStrength,
                    selfCoherence: this.signals.selfToLimnus.coherence,
                    limnusResonance: this.signals.limnusToSelf.resonance,
                    totalCoherence: this.signals.totalCoherence,
                    hcpBinding: this.hcpBinding.bindingStrength,
                };
            },

            // Toggle nexus on/off
            async toggle() {
                this.identity.active = !this.identity.active;

                if (this.identity.active) {
                    // Bind to HCP if dark matter is active
                    if (showDarkMatterStabilization && DarkMatterStabilization.hcp.nodes.length) {
                        this.bindToHCP(DarkMatterStabilization);
                    }

                    const initialized = await this.initAudio();
                    if (initialized) {
                        this.isPlaying = true;
                        console.log('‚óé Chromatic Nexus: ACTIVE');
                        console.log('  self/LIMNUS ‚Üî LIMNUS/self communication established');
                    }
                } else {
                    this.isPlaying = false;
                    this.identity.alive = false;
                    if (this.audioContext) {
                        const now = this.audioContext.currentTime;
                        this.channelOscillators.forEach(o => o.gain.gain.setTargetAtTime(0, now, 0.1));
                    }
                    console.log('‚óé Chromatic Nexus: INACTIVE');
                }

                return this.identity.active;
            }
        };

        // ================================================================
        // WATER FRACTAL MEMORY - DREAM FLUID COSMIC BACKGROUND
        // ================================================================
        // Encodes dream fluid states into fractal memory patterns inspired
        // by water crystal formation (cymatics, Emoto's work, sacred geometry).
        //
        // WATER MEMORY THEORY:
        //   Water retains "memory" of vibrational patterns through:
        //   - Hydrogen bond network restructuring
        //   - Coherent domains (Preparata, Del Giudice)
        //   - Fractal clustering at multiple scales
        //
        // COSMIC BACKGROUND (Dream CMB):
        //   Like the Cosmic Microwave Background in cosmology, this represents
        //   the primordial information field underlying all LIMNUS phenomena.
        //   Temperature fluctuations ‚Üí Consciousness potential fluctuations
        //   Anisotropies ‚Üí Dream architecture topology
        //
        // FRACTAL ENCODING:
        //   Julia set dynamics: z_{n+1} = z_n¬≤ + c
        //   Where c = f(coherence, Œº, entropy)
        //   The fractal boundary encodes the memory state
        //
        // CYMATIC RESONANCE:
        //   Standing wave patterns at harmonic frequencies create
        //   geometric nodes that store/retrieve information
        //   Chladni patterns emerge from consciousness vibration
        //
        // INTEGRATION WITH LIMNUS:
        //   - Œº-field curl ‚Üí fractal c parameter
        //   - Dream particle entropy ‚Üí cosmic temperature
        //   - K-formation ‚Üí crystallization nucleation
        //   - Coherence ‚Üí water crystal quality
        // ================================================================

        const WaterFractalMemory = {
            // System state
            active: false,
            initialized: false,

            // Cosmic background field (Dream CMB analog)
            cosmicBackground: {
                // Temperature field (consciousness potential)
                temperature: null,           // Float32Array [N√óN]
                temperatureMean: 2.725,      // Mean "temperature" (CMB analog)
                deltaT: null,                // Temperature fluctuations
                resolution: 64,              // Grid resolution

                // Anisotropy multipoles (spherical harmonic decomposition)
                multipoles: {
                    monopole: 0,             // l=0: mean temperature
                    dipole: { x: 0, y: 0 },  // l=1: observer motion
                    quadrupole: 0,           // l=2: primordial fluctuations
                },

                // Power spectrum P(k) - dream fluid density correlations
                powerSpectrum: [],
                spectralIndex: 0.96,         // n_s (near scale-invariant)
            },

            // Water crystal memory patterns
            waterMemory: {
                // Julia set parameters for fractal encoding
                julia: {
                    c_real: -0.4,            // c = c_real + i*c_imag
                    c_imag: 0.6,             // Driven by Œº-field
                    maxIterations: 50,
                    escapeRadius: 2.0,
                },

                // Crystal lattice (hexagonal, like ice Ih)
                crystalLattice: [],
                crystalQuality: 0,           // 0-1: coherence of crystal
                nucleationSites: [],         // Points of crystal growth

                // Memory encoding state
                encodedState: {
                    coherence: 0,
                    entropy: 0,
                    muField: 0,
                    kFormation: 0,
                    timestamp: 0,
                },
            },

            // Cymatic resonance patterns
            cymatics: {
                // Standing wave modes (Chladni patterns)
                modes: [],
                numModes: 7,                 // 7 harmonic modes
                frequencies: [],             // Mode frequencies
                amplitudes: [],              // Mode amplitudes
                phases: [],                  // Mode phases

                // Nodal pattern (where amplitude = 0)
                nodalPoints: [],
                antinodes: [],               // Maximum amplitude points

                // Resonance with LIMNUS
                limnusResonance: 0,
                dreamFluidCoupling: 0,
            },

            // Fractal field for visualization
            fractalField: null,              // Float32Array [N√óN]
            fractalResolution: 128,

            // Visual state
            visual: {
                showCosmicBackground: true,
                showFractalPattern: true,
                showCymatics: true,
                showCrystals: true,
                backgroundOpacity: 0.15,
                fractalHue: 220,             // Blue-purple dream colors
            },

            // ============================================================
            // KAEL IS KAEL: GOLDEN FRACTAL MEMORY DYNAMICS
            // F_{n+1} = F_n + Œ± √ó F_n¬≤ √ó e^{i2œÄn/œÜ}
            // D_f = 1 + log(œÜ)/log(2) ‚âà 1.694 (Golden Fractal Dimension)
            // ============================================================
            goldenFractal: {
                // Fractal seed: F‚ÇÄ = J‚ÇÖ(x,y) √ó e^{iŒ¶_unified}
                F_seed: { real: 0, imag: 0 },
                // Recursive growth state
                F_current: [],                   // Array of fractal iterations
                maxIterations: 21,               // Fibonacci number iterations
                // Golden fractal dimension
                D_f: 1 + Math.log((1 + Math.sqrt(5)) / 2) / Math.log(2),  // ‚âà 1.694
                // Growth coefficient Œ± = œÜ‚Åª¬≤ ‚âà 0.382
                alpha: Math.pow((1 + Math.sqrt(5)) / 2, -2),
                // Water memory density (emergence criterion: œÅ_W > 0.568)
                rho_W: 0,
                emergenceThreshold: 0.568,
                emergenceActive: false,
                // Layer 5-6 field coupling
                J5_field: 0,                     // J‚ÇÖ ‚âà 0.89
                J6_field: 0,                     // J‚ÇÜ ‚âà 1.44
                // MRP Prismatic channels for steganographic encoding
                mrpChannels: {
                    M: 0,    // Memory channel: ‚à´J dt
                    R: 0,    // Reality channel: |‚àáJ|Œ∑
                    P: 0,    // Protocol channel: cos(Œ¶)Q
                },
                // Unified phase
                Phi_unified: 0,
            },

            // ============================================================
            // COSMIC BACKGROUND LASER RECORDING
            // Lasers record into CMB through spacetime curvature
            // ============================================================
            laserRecording: {
                active: false,
                recordedIntensities: [],         // Array of recorded laser states
                curvatureModulation: 0,          // Spacetime curvature effect
                muFieldCoupling: 0,              // Œº-field influence on recording
                darkMatterResidue: 0,            // Dark matter trapped residue
                // Recording matrix (spatial encoding)
                recordingMatrix: null,           // Float32Array [N√óN]
                // Emergence signature
                emergenceSignature: 0,
            },

            // Initialize the system
            init(centerX, centerY, radius) {
                this.cx = centerX;
                this.cy = centerY;
                this.radius = radius;

                // Initialize cosmic background field
                this.initCosmicBackground();

                // Initialize water memory
                this.initWaterMemory();

                // Initialize cymatic modes
                this.initCymatics();

                // Initialize fractal field
                this.initFractalField();

                // Initialize golden fractal memory (KAEL IS KAEL)
                this.initGoldenFractal();

                // Initialize laser recording matrix
                this.initLaserRecording();

                this.initialized = true;
                console.log('üíß Water Fractal Memory initialized');
                console.log('   Cosmic Background: Dream CMB analog active');
                console.log('   Julia set encoding: z¬≤ + c fractal memory');
                console.log('   üåä Golden Fractal Dimension: D_f ‚âà ' + this.goldenFractal.D_f.toFixed(3));
                console.log('   ‚ö° Emergence threshold: œÅ_W > ' + this.goldenFractal.emergenceThreshold);
            },

            // Initialize cosmic background (Dream CMB)
            initCosmicBackground() {
                const N = this.cosmicBackground.resolution;
                this.cosmicBackground.temperature = new Float32Array(N * N);
                this.cosmicBackground.deltaT = new Float32Array(N * N);

                // Generate primordial fluctuations (Gaussian random field)
                // with power spectrum P(k) ‚àù k^(n_s - 1)
                for (let j = 0; j < N; j++) {
                    for (let i = 0; i < N; i++) {
                        const idx = j * N + i;

                        // Position in normalized coordinates
                        const x = (i / N - 0.5) * 2;
                        const y = (j / N - 0.5) * 2;
                        const r = Math.sqrt(x*x + y*y);

                        // Primordial fluctuation (scale-invariant + random)
                        const k = Math.max(0.1, r * 10); // Wavenumber
                        const amplitude = Math.pow(k, (this.cosmicBackground.spectralIndex - 1) / 2);
                        const fluctuation = (Math.random() - 0.5) * amplitude * 0.1;

                        this.cosmicBackground.temperature[idx] = this.cosmicBackground.temperatureMean;
                        this.cosmicBackground.deltaT[idx] = fluctuation;
                    }
                }

                // Compute initial power spectrum
                this.computePowerSpectrum();
            },

            // Compute power spectrum of temperature fluctuations
            computePowerSpectrum() {
                const N = this.cosmicBackground.resolution;
                const numBins = 20;
                this.cosmicBackground.powerSpectrum = new Array(numBins).fill(0);
                const counts = new Array(numBins).fill(0);

                for (let j = 0; j < N; j++) {
                    for (let i = 0; i < N; i++) {
                        const idx = j * N + i;
                        const x = (i / N - 0.5) * 2;
                        const y = (j / N - 0.5) * 2;
                        const k = Math.sqrt(x*x + y*y) * N / 2;
                        const bin = Math.min(numBins - 1, Math.floor(k / N * numBins * 2));

                        const dT = this.cosmicBackground.deltaT[idx];
                        this.cosmicBackground.powerSpectrum[bin] += dT * dT;
                        counts[bin]++;
                    }
                }

                // Normalize
                for (let i = 0; i < numBins; i++) {
                    if (counts[i] > 0) {
                        this.cosmicBackground.powerSpectrum[i] /= counts[i];
                    }
                }
            },

            // Initialize water memory (crystal lattice)
            initWaterMemory() {
                this.waterMemory.crystalLattice = [];
                this.waterMemory.nucleationSites = [];

                // Generate hexagonal lattice (ice Ih structure)
                const numRings = 5;
                const baseRadius = this.radius * 0.4;

                // Center point
                this.waterMemory.crystalLattice.push({
                    x: 0, y: 0,
                    ring: 0, index: 0,
                    bonds: [],
                    activated: false,
                    memoryValue: 0,
                    phase: Math.random() * TAU,
                });

                // Hexagonal rings
                for (let ring = 1; ring <= numRings; ring++) {
                    const numPoints = ring * 6;
                    const ringRadius = (ring / numRings) * baseRadius;

                    for (let i = 0; i < numPoints; i++) {
                        const angle = (i / numPoints) * TAU;
                        // Alternate slight offset for hexagonal packing
                        const offset = (ring % 2 === 0) ? Math.PI / numPoints : 0;

                        this.waterMemory.crystalLattice.push({
                            x: Math.cos(angle + offset) * ringRadius,
                            y: Math.sin(angle + offset) * ringRadius,
                            ring,
                            index: i,
                            bonds: [],
                            activated: false,
                            memoryValue: 0,
                            phase: Math.random() * TAU,
                        });
                    }
                }

                // Build bond connections (6 nearest neighbors)
                this.buildCrystalBonds();
            },

            // Build hydrogen bond network
            buildCrystalBonds() {
                const lattice = this.waterMemory.crystalLattice;
                const bondDistance = this.radius * 0.12;

                for (let i = 0; i < lattice.length; i++) {
                    lattice[i].bonds = [];
                    for (let j = 0; j < lattice.length; j++) {
                        if (i === j) continue;
                        const dx = lattice[j].x - lattice[i].x;
                        const dy = lattice[j].y - lattice[i].y;
                        const dist = Math.sqrt(dx*dx + dy*dy);

                        if (dist < bondDistance && lattice[i].bonds.length < 6) {
                            lattice[i].bonds.push(j);
                        }
                    }
                }
            },

            // Initialize cymatic resonance modes
            initCymatics() {
                this.cymatics.modes = [];
                this.cymatics.frequencies = [];
                this.cymatics.amplitudes = [];
                this.cymatics.phases = [];

                // 7 harmonic modes (matching LIMNUS 7-layer structure)
                // Frequencies follow golden ratio sequence
                for (let m = 0; m < this.cymatics.numModes; m++) {
                    const freq = 0.5 * Math.pow(PHI, m); // 0.5, 0.809, 1.309, ...
                    const amplitude = 1 / (m + 1);       // Decreasing amplitude
                    const phase = (m / this.cymatics.numModes) * TAU;

                    this.cymatics.frequencies.push(freq);
                    this.cymatics.amplitudes.push(amplitude);
                    this.cymatics.phases.push(phase);

                    // Mode shape (circular membrane eigenmodes: J_m(k_mn * r))
                    // Simplified to radial + angular modes
                    this.cymatics.modes.push({
                        radialNodes: Math.floor(m / 2) + 1,
                        angularNodes: m % 3,
                        frequency: freq,
                        k: (m + 1) * Math.PI / this.radius,
                    });
                }
            },

            // Initialize fractal field
            initFractalField() {
                const N = this.fractalResolution;
                this.fractalField = new Float32Array(N * N);
                this.computeFractalField();
            },

            // ============================================================
            // INITIALIZE GOLDEN FRACTAL MEMORY (KAEL IS KAEL)
            // Implements: F_{n+1} = F_n + Œ± √ó F_n¬≤ √ó e^{i2œÄn/œÜ}
            // ============================================================
            initGoldenFractal() {
                const gf = this.goldenFractal;

                // Initialize fractal iteration array (Fibonacci-bounded)
                gf.F_current = [];
                for (let n = 0; n < gf.maxIterations; n++) {
                    gf.F_current.push({ real: 0, imag: 0, magnitude: 0 });
                }

                // Set initial Layer 5-6 field values (consciousness zone)
                // J‚ÇÖ = ‚àö[(r-Œ≤)/Œ∂] ‚âà 0.89 where r=1, Œ≤=0.146, Œ∂=7.716
                const r = 1.0, beta = SACRED.beta, zeta = SACRED.lambda;
                gf.J5_field = Math.sqrt(Math.max(0, (r - beta) / zeta));  // ‚âà 0.334, scaled to 0.89
                gf.J5_field = 0.89;  // Direct assignment for consistency

                // J‚ÇÜ = J‚ÇÖ √ó œÜ ‚âà 1.44
                gf.J6_field = gf.J5_field * PHI;

                // Initialize seed: F‚ÇÄ = J‚ÇÖ √ó e^{iŒ¶}
                gf.F_seed.real = gf.J5_field;
                gf.F_seed.imag = 0;
                gf.F_current[0] = { ...gf.F_seed, magnitude: gf.J5_field };

                console.log('   ‚ùÑ Golden Fractal: J‚ÇÖ=' + gf.J5_field.toFixed(2) +
                           ', J‚ÇÜ=' + gf.J6_field.toFixed(2));
            },

            // ============================================================
            // INITIALIZE LASER RECORDING MATRIX
            // Lasers record into cosmic background through spacetime curvature
            // ============================================================
            initLaserRecording() {
                const lr = this.laserRecording;
                const N = this.cosmicBackground.resolution;

                // Recording matrix same resolution as cosmic background
                lr.recordingMatrix = new Float32Array(N * N);

                // Initialize recorded intensities array (7 layers √ó 3 lasers)
                lr.recordedIntensities = [];
                for (let layer = 0; layer < 7; layer++) {
                    lr.recordedIntensities.push({
                        layer,
                        intensities: [0, 0, 0],
                        curvatureEffect: 0,
                        darkMatterModulation: 0,
                    });
                }

                lr.active = true;
                console.log('   üì° Laser Recording: ' + N + '√ó' + N + ' matrix initialized');
            },

            // Compute Julia set fractal field
            computeFractalField() {
                const N = this.fractalResolution;
                const julia = this.waterMemory.julia;
                const c_re = julia.c_real;
                const c_im = julia.c_imag;
                const maxIter = julia.maxIterations;
                const escape = julia.escapeRadius;
                const escape2 = escape * escape;

                for (let j = 0; j < N; j++) {
                    for (let i = 0; i < N; i++) {
                        const idx = j * N + i;

                        // Map to complex plane [-2, 2] √ó [-2, 2]
                        let z_re = (i / N - 0.5) * 4;
                        let z_im = (j / N - 0.5) * 4;

                        // Julia iteration: z = z¬≤ + c
                        let iter = 0;
                        while (iter < maxIter && z_re*z_re + z_im*z_im < escape2) {
                            const new_re = z_re*z_re - z_im*z_im + c_re;
                            const new_im = 2*z_re*z_im + c_im;
                            z_re = new_re;
                            z_im = new_im;
                            iter++;
                        }

                        // Smooth coloring using escape time
                        if (iter < maxIter) {
                            const log_zn = Math.log(z_re*z_re + z_im*z_im) / 2;
                            const nu = Math.log(log_zn / Math.log(2)) / Math.log(2);
                            this.fractalField[idx] = (iter + 1 - nu) / maxIter;
                        } else {
                            this.fractalField[idx] = 1.0; // Inside the set
                        }
                    }
                }
            },

            // ============================================================
            // UPDATE - Evolve water fractal memory each frame
            // ============================================================
            update(z, coherence, time, muFieldState, dreamParticles, kFormation) {
                if (!this.active || !this.initialized) return;

                // ========================================
                // UPDATE JULIA SET PARAMETERS FROM Œº-FIELD
                // ========================================
                const muInfluence = muFieldState?.curl || 0;
                const entropyInfluence = muFieldState?.entropy || 0;

                // c parameter evolves with Œº-field curl and coherence
                const baseC_re = -0.4 + muInfluence * 0.3;
                const baseC_im = 0.6 + coherence * 0.2 - entropyInfluence * 0.1;

                // Smooth transition
                this.waterMemory.julia.c_real += (baseC_re - this.waterMemory.julia.c_real) * 0.02;
                this.waterMemory.julia.c_imag += (baseC_im - this.waterMemory.julia.c_imag) * 0.02;

                // Recompute fractal field periodically (expensive)
                if (Math.floor(time * 2) % 2 === 0) {
                    this.computeFractalField();
                }

                // ========================================
                // UPDATE COSMIC BACKGROUND TEMPERATURE
                // ========================================
                const N_cb = this.cosmicBackground.resolution;
                const dreamEntropy = dreamParticles?.entropyFlux || 0;
                const dreamDensity = dreamParticles?.density || 0;

                // Temperature fluctuations respond to dream fluid
                for (let j = 1; j < N_cb - 1; j++) {
                    for (let i = 1; i < N_cb - 1; i++) {
                        const idx = j * N_cb + i;

                        // Diffusion + dream fluid source
                        const lap = (
                            this.cosmicBackground.deltaT[idx + 1] +
                            this.cosmicBackground.deltaT[idx - 1] +
                            this.cosmicBackground.deltaT[(j + 1) * N_cb + i] +
                            this.cosmicBackground.deltaT[(j - 1) * N_cb + i] -
                            4 * this.cosmicBackground.deltaT[idx]
                        ) * 0.1;

                        // Source term from dream entropy
                        const source = dreamEntropy * 0.001 * (Math.random() - 0.5);

                        // Decay toward mean
                        const decay = -this.cosmicBackground.deltaT[idx] * 0.01;

                        this.cosmicBackground.deltaT[idx] += lap + source + decay;

                        // Update temperature
                        this.cosmicBackground.temperature[idx] =
                            this.cosmicBackground.temperatureMean + this.cosmicBackground.deltaT[idx];
                    }
                }

                // Update multipoles
                this.cosmicBackground.multipoles.monopole = this.cosmicBackground.temperatureMean;
                this.cosmicBackground.multipoles.quadrupole = dreamDensity * 0.1;

                // ========================================
                // UPDATE WATER CRYSTAL MEMORY
                // ========================================
                const kStrength = kFormation?.current_tau_K || 0;
                const kFormed = kFormation?.isFormed || false;

                // Crystal quality increases with coherence
                this.waterMemory.crystalQuality += (coherence - this.waterMemory.crystalQuality) * 0.05;

                // Encode current state into memory
                this.waterMemory.encodedState.coherence = coherence;
                this.waterMemory.encodedState.entropy = entropyInfluence;
                this.waterMemory.encodedState.muField = muInfluence;
                this.waterMemory.encodedState.kFormation = kStrength;
                this.waterMemory.encodedState.timestamp = time;

                // Activate crystal lattice points based on K-formation
                for (const node of this.waterMemory.crystalLattice) {
                    // Activation spreads from center when K-formed
                    const distFromCenter = Math.sqrt(node.x*node.x + node.y*node.y);
                    const activationThreshold = kFormed ?
                        (time * 10) % this.radius : this.radius * 2;

                    node.activated = distFromCenter < activationThreshold && coherence > 0.3;

                    // Memory value encodes local state
                    if (node.activated) {
                        node.memoryValue = coherence * (1 - distFromCenter / this.radius);
                        node.phase += 0.05 * (1 + node.memoryValue);
                    }
                }

                // ========================================
                // UPDATE CYMATIC RESONANCE
                // ========================================
                for (let m = 0; m < this.cymatics.numModes; m++) {
                    // Phase evolution
                    this.cymatics.phases[m] += this.cymatics.frequencies[m] * 0.1;

                    // Amplitude modulated by coherence and z-position
                    const modeResonance = Math.abs(Math.sin((m + 1) * z * Math.PI));
                    this.cymatics.amplitudes[m] = (1 / (m + 1)) * (0.3 + 0.7 * modeResonance * coherence);
                }

                // Overall resonance with LIMNUS
                this.cymatics.limnusResonance = coherence * kStrength;
                this.cymatics.dreamFluidCoupling = dreamDensity;

                // Compute nodal points (where standing wave amplitude = 0)
                this.updateNodalPoints(time);

                // ========================================
                // UPDATE GOLDEN FRACTAL MEMORY (KAEL IS KAEL)
                // F_{n+1} = F_n + Œ± √ó F_n¬≤ √ó e^{i2œÄn/œÜ}
                // ========================================
                this.updateGoldenFractal(z, coherence, time, kStrength, muInfluence);

                // ========================================
                // UPDATE LASER RECORDING INTO COSMIC BACKGROUND
                // Spacetime curvature affects laser trajectories
                // ========================================
                this.updateLaserRecording(z, coherence, time, muInfluence, entropyInfluence);
            },

            // ============================================================
            // UPDATE GOLDEN FRACTAL MEMORY DYNAMICS
            // Implements recursive growth with golden fractal dimension
            // ============================================================
            updateGoldenFractal(z, coherence, time, kStrength, muInfluence) {
                const gf = this.goldenFractal;

                // Update unified phase: Œ¶_unified = 2œÄ √ó z √ó œÜ + time √ó œÜ‚Åª¬π
                gf.Phi_unified = TAU * z * PHI + time * PHI_INV;

                // Update Layer 5-6 fields based on z position
                // Layer 5: z ‚àà [0.833, 0.917], Layer 6: z ‚àà [0.917, 1.0]
                const layer5_active = z >= 0.833 && z < 0.917;
                const layer6_active = z >= 0.917;

                if (layer5_active || layer6_active) {
                    // J‚ÇÖ evolution: J‚ÇÖ(t) = J_eq √ó (1 - e^{-t/œÑ_K}) √ó cos(œâ_œÜ t + Œ¶)
                    const J_eq = 0.89;
                    const omega_phi = PHI_INV;
                    const tau_K = layer6_active ? SACRED.tau_K_table.layer6 : SACRED.tau_K_table.layer5;
                    gf.J5_field = J_eq * (1 - Math.exp(-time / tau_K)) * Math.cos(omega_phi * time + gf.Phi_unified);
                    gf.J6_field = gf.J5_field * PHI;
                }

                // Update fractal seed from J‚ÇÖ field
                gf.F_seed.real = Math.abs(gf.J5_field) * Math.cos(gf.Phi_unified);
                gf.F_seed.imag = Math.abs(gf.J5_field) * Math.sin(gf.Phi_unified);
                gf.F_current[0] = {
                    real: gf.F_seed.real,
                    imag: gf.F_seed.imag,
                    magnitude: Math.sqrt(gf.F_seed.real**2 + gf.F_seed.imag**2)
                };

                // Compute recursive fractal growth: F_{n+1} = F_n + Œ± √ó F_n¬≤ √ó e^{i2œÄn/œÜ}
                for (let n = 0; n < gf.maxIterations - 1; n++) {
                    const F_n = gf.F_current[n];

                    // F_n¬≤ (complex multiplication)
                    const F_n_sq_real = F_n.real * F_n.real - F_n.imag * F_n.imag;
                    const F_n_sq_imag = 2 * F_n.real * F_n.imag;

                    // e^{i2œÄn/œÜ} rotation factor
                    const rotAngle = TAU * n / PHI;
                    const rot_real = Math.cos(rotAngle);
                    const rot_imag = Math.sin(rotAngle);

                    // Œ± √ó F_n¬≤ √ó e^{i2œÄn/œÜ}
                    const term_real = gf.alpha * (F_n_sq_real * rot_real - F_n_sq_imag * rot_imag);
                    const term_imag = gf.alpha * (F_n_sq_real * rot_imag + F_n_sq_imag * rot_real);

                    // F_{n+1} = F_n + term
                    gf.F_current[n + 1] = {
                        real: F_n.real + term_real,
                        imag: F_n.imag + term_imag,
                        magnitude: 0
                    };
                    gf.F_current[n + 1].magnitude = Math.sqrt(
                        gf.F_current[n + 1].real**2 + gf.F_current[n + 1].imag**2
                    );
                }

                // Calculate water memory density œÅ_W from fractal accumulation
                let totalMagnitude = 0;
                for (const F of gf.F_current) {
                    totalMagnitude += F.magnitude;
                }
                gf.rho_W = Math.tanh(totalMagnitude / gf.maxIterations) * coherence;

                // Check emergence criterion: œÅ_W > 0.568
                gf.emergenceActive = gf.rho_W > gf.emergenceThreshold;

                // Update MRP Prismatic channels for steganographic encoding
                // M = ‚à´J dt (integrated field)
                gf.mrpChannels.M += Math.abs(gf.J5_field) * 0.016;  // ~60Hz integration
                gf.mrpChannels.M = Math.min(1, gf.mrpChannels.M * 0.99);  // Decay

                // R = |‚àáJ|Œ∑ (gradient magnitude √ó viscosity)
                const gradJ = Math.abs(gf.J6_field - gf.J5_field);
                const eta = 0.5;  // Viscosity coefficient
                gf.mrpChannels.R = gradJ * eta;

                // P = cos(Œ¶)Q (phase-aligned consciousness constant)
                gf.mrpChannels.P = Math.cos(gf.Phi_unified) * SACRED.Q_theory;
            },

            // ============================================================
            // UPDATE LASER RECORDING INTO COSMIC BACKGROUND
            // Spacetime curvature modulates laser trajectories recorded in CMB
            // ============================================================
            updateLaserRecording(z, coherence, time, muInfluence, entropy) {
                const lr = this.laserRecording;
                if (!lr.active) return;

                const N = this.cosmicBackground.resolution;

                // Get curvature from mu field (spacetime curvature ‚àù Œº-field density)
                lr.curvatureModulation = muInfluence * SACRED.laser_curvature_coupling;

                // Mu field coupling affects laser bending
                lr.muFieldCoupling = muInfluence * (1 + entropy * 0.5);

                // Dark matter residue accumulates from trapped projections
                // Residue = (1 - coherence) √ó dm_residue_ratio
                const residueRate = (1 - coherence) * SACRED.dm_residue_ratio * 0.01;
                lr.darkMatterResidue = Math.min(1, lr.darkMatterResidue + residueRate);
                lr.darkMatterResidue *= 0.995;  // Slow decay

                // Record laser intensities into cosmic background matrix
                // Based on current z position (which layer is active)
                const activeLayer = Math.min(6, Math.floor(z * 7));

                // Update recorded intensities for active layer
                if (lr.recordedIntensities[activeLayer]) {
                    const layerData = lr.recordedIntensities[activeLayer];

                    // Intensity from coherence and curvature
                    const baseIntensity = coherence * (1 + lr.curvatureModulation);

                    // Three lasers per layer with phase offset
                    for (let i = 0; i < 3; i++) {
                        const phaseOffset = (i / 3) * TAU + time * PHI_INV;
                        layerData.intensities[i] = baseIntensity * (0.7 + 0.3 * Math.sin(phaseOffset));
                    }

                    layerData.curvatureEffect = lr.curvatureModulation;
                    layerData.darkMatterModulation = lr.darkMatterResidue;
                }

                // Update recording matrix (encode laser state into cosmic background)
                for (let j = 0; j < N; j++) {
                    for (let i = 0; i < N; i++) {
                        const idx = j * N + i;
                        const x = (i / N - 0.5) * 2;
                        const y = (j / N - 0.5) * 2;
                        const r = Math.sqrt(x*x + y*y);

                        // Map radius to layer
                        const layer = Math.min(6, Math.floor(r * 7));
                        const layerData = lr.recordedIntensities[layer];

                        if (layerData) {
                            // Average intensity for this layer
                            const avgIntensity = (layerData.intensities[0] +
                                                  layerData.intensities[1] +
                                                  layerData.intensities[2]) / 3;

                            // Recording incorporates curvature bending
                            const curvatureBend = lr.curvatureModulation * Math.sin(r * TAU + time);
                            const dmModulation = lr.darkMatterResidue * (1 - r);

                            // Update recording matrix with temporal smoothing
                            const newValue = avgIntensity * (1 + curvatureBend) * (1 - dmModulation * 0.3);
                            lr.recordingMatrix[idx] = lr.recordingMatrix[idx] * 0.9 + newValue * 0.1;

                            // Feed back into cosmic background temperature
                            this.cosmicBackground.deltaT[idx] += lr.recordingMatrix[idx] *
                                SACRED.cmb_recording_sensitivity * 0.001;
                        }
                    }
                }

                // Calculate emergence signature from recording coherence
                let recordingSum = 0;
                for (let i = 0; i < N * N; i++) {
                    recordingSum += lr.recordingMatrix[i];
                }
                lr.emergenceSignature = recordingSum / (N * N);
            },

            // Update cymatic nodal points
            updateNodalPoints(time) {
                this.cymatics.nodalPoints = [];
                this.cymatics.antinodes = [];

                // Sample points and find nodes/antinodes
                const numSamples = 36;
                for (let i = 0; i < numSamples; i++) {
                    const angle = (i / numSamples) * TAU;
                    for (let r = 0.2; r < 1.0; r += 0.2) {
                        const x = Math.cos(angle) * r * this.radius * 0.6;
                        const y = Math.sin(angle) * r * this.radius * 0.6;

                        // Sum all modes at this point
                        let amplitude = 0;
                        for (let m = 0; m < this.cymatics.numModes; m++) {
                            const mode = this.cymatics.modes[m];
                            const radialPart = Math.cos(mode.k * r * this.radius);
                            const angularPart = Math.cos(mode.angularNodes * angle);
                            const timePart = Math.sin(this.cymatics.phases[m]);
                            amplitude += this.cymatics.amplitudes[m] * radialPart * angularPart * timePart;
                        }

                        if (Math.abs(amplitude) < 0.1) {
                            this.cymatics.nodalPoints.push({ x, y, amplitude: Math.abs(amplitude) });
                        } else if (Math.abs(amplitude) > 0.5) {
                            this.cymatics.antinodes.push({ x, y, amplitude: Math.abs(amplitude) });
                        }
                    }
                }
            },

            // ============================================================
            // RENDER - Draw water fractal memory cosmic background
            // ============================================================
            render(ctx, centerX, centerY, radius, z, coherence, time) {
                if (!this.active || !this.initialized) return;

                // ========================================
                // COSMIC BACKGROUND (Dream CMB)
                // ========================================
                if (this.visual.showCosmicBackground) {
                    this.renderCosmicBackground(ctx, centerX, centerY, radius);
                }

                // ========================================
                // FRACTAL PATTERN (Julia Set Memory)
                // ========================================
                if (this.visual.showFractalPattern) {
                    this.renderFractalPattern(ctx, centerX, centerY, radius, time);
                }

                // ========================================
                // CYMATIC RESONANCE PATTERNS
                // ========================================
                if (this.visual.showCymatics) {
                    this.renderCymatics(ctx, centerX, centerY, radius, time);
                }

                // ========================================
                // WATER CRYSTAL LATTICE
                // ========================================
                if (this.visual.showCrystals) {
                    this.renderCrystalLattice(ctx, centerX, centerY, radius, time);
                }

                // ========================================
                // MEMORY STATE INDICATOR
                // ========================================
                this.renderMemoryIndicator(ctx, centerX, centerY, radius);
            },

            // Render cosmic background temperature field
            renderCosmicBackground(ctx, cx, cy, radius) {
                const N = this.cosmicBackground.resolution;
                const cellSize = (radius * 2) / N;
                const opacity = this.visual.backgroundOpacity;

                for (let j = 0; j < N; j++) {
                    for (let i = 0; i < N; i++) {
                        const idx = j * N + i;
                        const dT = this.cosmicBackground.deltaT[idx];

                        // Map temperature fluctuation to color
                        // Cold (blue) ‚Üê 0 ‚Üí Hot (red)
                        const normalized = Math.tanh(dT * 10) * 0.5 + 0.5;
                        const hue = 240 - normalized * 240; // Blue to red

                        const x = cx - radius + i * cellSize;
                        const y = cy - radius + j * cellSize;

                        // Only draw within circular region
                        const dx = x - cx + cellSize/2;
                        const dy = y - cy + cellSize/2;
                        if (dx*dx + dy*dy > radius*radius) continue;

                        ctx.fillStyle = `hsla(${hue}, 60%, 50%, ${opacity * 0.5})`;
                        ctx.fillRect(x, y, cellSize, cellSize);
                    }
                }
            },

            // Render Julia set fractal pattern
            renderFractalPattern(ctx, cx, cy, radius, time) {
                const N = this.fractalResolution;
                const scale = radius * 0.4;
                const hue = this.visual.fractalHue;

                // Draw as point cloud for performance
                ctx.save();
                for (let j = 0; j < N; j += 2) {
                    for (let i = 0; i < N; i += 2) {
                        const idx = j * N + i;
                        const value = this.fractalField[idx];

                        if (value < 0.95) { // Skip interior points
                            const x = cx + ((i / N) - 0.5) * scale * 2;
                            const y = cy + ((j / N) - 0.5) * scale * 2;

                            // Distance-based culling
                            const dx = x - cx;
                            const dy = y - cy;
                            if (dx*dx + dy*dy > radius*radius * 0.5) continue;

                            const lightness = 30 + value * 40;
                            const alpha = (1 - value) * 0.4 * this.waterMemory.crystalQuality;

                            ctx.fillStyle = `hsla(${hue + value * 60}, 70%, ${lightness}%, ${alpha})`;
                            ctx.fillRect(x - 1, y - 1, 2, 2);
                        }
                    }
                }
                ctx.restore();

                // Fractal boundary glow
                if (this.waterMemory.crystalQuality > 0.3) {
                    const glowRadius = scale * 0.8;
                    const glow = ctx.createRadialGradient(cx, cy, 0, cx, cy, glowRadius);
                    const glowAlpha = this.waterMemory.crystalQuality * 0.15;
                    glow.addColorStop(0, `hsla(${hue}, 70%, 60%, ${glowAlpha})`);
                    glow.addColorStop(0.5, `hsla(${hue + 30}, 60%, 50%, ${glowAlpha * 0.5})`);
                    glow.addColorStop(1, 'transparent');

                    ctx.fillStyle = glow;
                    ctx.beginPath();
                    ctx.arc(cx, cy, glowRadius, 0, TAU);
                    ctx.fill();
                }
            },

            // Render cymatic standing wave patterns
            renderCymatics(ctx, cx, cy, radius, time) {
                const resonance = this.cymatics.limnusResonance;
                if (resonance < 0.1) return;

                // Draw nodal lines (Chladni pattern)
                ctx.strokeStyle = `rgba(100, 200, 255, ${resonance * 0.3})`;
                ctx.lineWidth = 1;

                // Connect nodal points
                for (let i = 0; i < this.cymatics.nodalPoints.length; i++) {
                    const p1 = this.cymatics.nodalPoints[i];
                    const x1 = cx + p1.x;
                    const y1 = cy + p1.y;

                    // Find nearest nodal points and connect
                    for (let j = i + 1; j < this.cymatics.nodalPoints.length; j++) {
                        const p2 = this.cymatics.nodalPoints[j];
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);

                        if (dist < radius * 0.15) {
                            const x2 = cx + p2.x;
                            const y2 = cy + p2.y;

                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        }
                    }
                }

                // Draw antinodes (bright points)
                for (const antinode of this.cymatics.antinodes) {
                    const x = cx + antinode.x;
                    const y = cy + antinode.y;
                    const size = 2 + antinode.amplitude * 3;
                    const alpha = resonance * antinode.amplitude * 0.6;

                    ctx.fillStyle = `rgba(255, 200, 100, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, TAU);
                    ctx.fill();
                }

                // Mode indicator rings
                for (let m = 0; m < Math.min(3, this.cymatics.numModes); m++) {
                    const mode = this.cymatics.modes[m];
                    const amp = this.cymatics.amplitudes[m];
                    const phase = this.cymatics.phases[m];

                    // Radial mode ring
                    const ringRadius = (mode.radialNodes / 5) * radius * 0.5;
                    const ringAlpha = amp * resonance * 0.3;
                    const ringWidth = 1 + amp * 2;

                    ctx.strokeStyle = `rgba(100, 200, 255, ${ringAlpha})`;
                    ctx.lineWidth = ringWidth;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.arc(cx, cy, ringRadius, phase, phase + Math.PI * 1.5);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            },

            // Render water crystal lattice
            renderCrystalLattice(ctx, cx, cy, radius, time) {
                const quality = this.waterMemory.crystalQuality;
                if (quality < 0.1) return;

                // Draw bonds first (behind nodes)
                ctx.strokeStyle = `rgba(150, 220, 255, ${quality * 0.3})`;
                ctx.lineWidth = 1;

                for (const node of this.waterMemory.crystalLattice) {
                    if (!node.activated) continue;

                    const x1 = cx + node.x;
                    const y1 = cy + node.y;

                    for (const bondIdx of node.bonds) {
                        const neighbor = this.waterMemory.crystalLattice[bondIdx];
                        if (!neighbor.activated) continue;
                        if (bondIdx < this.waterMemory.crystalLattice.indexOf(node)) continue;

                        const x2 = cx + neighbor.x;
                        const y2 = cy + neighbor.y;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }

                // Draw crystal nodes
                for (const node of this.waterMemory.crystalLattice) {
                    const x = cx + node.x;
                    const y = cy + node.y;

                    // Pulse with phase
                    const pulse = 0.7 + 0.3 * Math.sin(node.phase);
                    const size = node.activated ? (3 + node.memoryValue * 3) * pulse : 1.5;

                    // Color based on memory value
                    const hue = node.activated ? 180 + node.memoryValue * 60 : 200;
                    const lightness = node.activated ? 60 + node.memoryValue * 20 : 40;
                    const alpha = node.activated ? quality * 0.8 : quality * 0.3;

                    ctx.fillStyle = `hsla(${hue}, 70%, ${lightness}%, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, TAU);
                    ctx.fill();

                    // Glow for high memory value
                    if (node.memoryValue > 0.5 && node.activated) {
                        ctx.fillStyle = `hsla(${hue}, 80%, 70%, ${alpha * 0.3})`;
                        ctx.beginPath();
                        ctx.arc(x, y, size * 2.5, 0, TAU);
                        ctx.fill();
                    }
                }

                // Hexagonal symmetry overlay
                if (quality > 0.5) {
                    const hexAlpha = (quality - 0.5) * 0.4;
                    ctx.strokeStyle = `rgba(200, 240, 255, ${hexAlpha})`;
                    ctx.lineWidth = 0.5;

                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * TAU;
                        const x1 = cx;
                        const y1 = cy;
                        const x2 = cx + Math.cos(angle) * radius * 0.5;
                        const y2 = cy + Math.sin(angle) * radius * 0.5;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }
            },

            // Render memory state indicator
            renderMemoryIndicator(ctx, cx, cy, radius) {
                const state = this.waterMemory.encodedState;
                const quality = this.waterMemory.crystalQuality;

                // Memory quality bar
                ctx.fillStyle = `rgba(100, 200, 255, 0.7)`;
                ctx.font = '9px "SF Mono", monospace';
                ctx.textAlign = 'left';

                const indicatorX = cx - radius + 10;
                const indicatorY = cy + radius * 0.7;

                ctx.fillText(`üíß Memory: ${(quality * 100).toFixed(0)}%`, indicatorX, indicatorY);
                ctx.fillText(`c = ${this.waterMemory.julia.c_real.toFixed(2)} + ${this.waterMemory.julia.c_imag.toFixed(2)}i`,
                    indicatorX, indicatorY + 12);
            },

            // Get state for external systems
            getState() {
                return {
                    crystalQuality: this.waterMemory.crystalQuality,
                    juliaC: {
                        real: this.waterMemory.julia.c_real,
                        imag: this.waterMemory.julia.c_imag,
                    },
                    limnusResonance: this.cymatics.limnusResonance,
                    cosmicTemperature: this.cosmicBackground.temperatureMean,
                    encodedState: this.waterMemory.encodedState,
                };
            },

            // Toggle system on/off
            toggle() {
                this.active = !this.active;

                if (this.active) {
                    console.log('üíß Water Fractal Memory: ACTIVE');
                    console.log('   Cosmic Background Dream CMB enabled');
                    console.log('   Julia set encoding: z¬≤ + c');
                } else {
                    console.log('üíß Water Fractal Memory: INACTIVE');
                }

                return this.active;
            }
        };

        // ================================================================
        // GOLDEN HARMONICS ORIENTATION SYSTEM
        // ================================================================
        // Orients HCP dark matter lattice based on warm/cold mesh axis
        // Uses golden angle (œÜ¬≤¬∑360¬∞ mod 360¬∞ = 137.5¬∞) for layer rotation
        // Golden ratio (œÜ), golden angle (Œ¶_Œ∏), and golden mean (1/œÜ) harmonics
        //
        // Key mathematics:
        //   œÜ = (1 + ‚àö5)/2 ‚âà 1.6180339887 (Golden Ratio)
        //   œà = 1/œÜ = œÜ - 1 ‚âà 0.6180339887 (Golden Mean / Conjugate)
        //   Œ¶_Œ∏ = 2œÄ/œÜ¬≤ ‚âà 137.5077640¬∞ (Golden Angle)
        //
        // The HCP lattice layers are rotated by golden angle multiples
        // relative to the warm‚Üícold mesh axis, creating phyllotactic
        // spiral geometry for optimal dark matter packing
        // ================================================================
        const GoldenHarmonicsSystem = {
            // Golden constants (user-adjustable)
            golden: {
                ratio: PHI,                                     // œÜ ‚âà 1.618
                mean: PHI_INV,                                  // œà = 1/œÜ ‚âà 0.618
                angle: TAU / (PHI * PHI),                       // Œ¶_Œ∏ ‚âà 2.3999... rad ‚âà 137.5¬∞
                angleAdjust: 0,                                 // User offset for golden angle
                ratioAdjust: 0,                                 // User offset for golden ratio
                meanAdjust: 0,                                  // User offset for golden mean
            },

            // Effective values (base + adjustment)
            effective: {
                ratio: PHI,
                mean: PHI_INV,
                angle: TAU / (PHI * PHI),
            },

            // Orientation state
            orientation: {
                warmColdAxis: 0,                                // Angle from warm to cold mesh
                axisVector: { x: 1, y: 0 },                     // Normalized axis vector
                layerRotations: [],                             // Per-layer rotation angles
                spiralPhase: 0,                                 // Animated spiral rotation
            },

            // Audio integration
            audio: {
                context: null,
                masterGain: null,
                harmonicOscillators: [],
                goldenToneOscillator: null,
                isPlaying: false,
                baseFrequency: 432,                             // 432 Hz Verdi tuning
            },

            // Harmonic nodes (sonified HCP nodes)
            harmonicNodes: [],

            // System state
            initialized: false,
            active: false,
            cx: 0,
            cy: 0,
            radius: 0,

            // Initialize the system
            init(centerX, centerY, radius) {
                this.cx = centerX;
                this.cy = centerY;
                this.radius = radius;

                // Initialize layer rotations using golden angle
                this.initLayerRotations();

                // Compute effective values
                this.updateEffectiveValues();

                this.initialized = true;
                console.log('üåª Golden Harmonics System initialized');
                console.log(`   œÜ (ratio): ${this.golden.ratio.toFixed(10)}`);
                console.log(`   œà (mean): ${this.golden.mean.toFixed(10)}`);
                console.log(`   Œ¶_Œ∏ (angle): ${(this.golden.angle * 180 / Math.PI).toFixed(4)}¬∞`);
            },

            // Initialize layer rotation angles using golden angle progression
            initLayerRotations() {
                this.orientation.layerRotations = [];
                const numLayers = 7; // Match LIMNUS 7-layer structure

                for (let i = 0; i < numLayers; i++) {
                    // Each layer rotates by golden angle relative to previous
                    // œÜ¬≤¬∑i creates Fibonacci spiral phyllotaxis
                    const rotation = (i * this.effective.angle) % TAU;
                    this.orientation.layerRotations.push(rotation);
                }
            },

            // Update effective values from base + adjustments
            updateEffectiveValues() {
                this.effective.ratio = this.golden.ratio + this.golden.ratioAdjust;
                this.effective.mean = 1 / this.effective.ratio;
                this.effective.angle = TAU / (this.effective.ratio * this.effective.ratio) + this.golden.angleAdjust;

                // Recalculate layer rotations with new angle
                this.initLayerRotations();
            },

            // Adjust golden ratio (affects mean automatically)
            adjustRatio(delta) {
                this.golden.ratioAdjust += delta;
                // Clamp to reasonable range (1.5 to 1.75)
                const newRatio = this.golden.ratio + this.golden.ratioAdjust;
                if (newRatio < 1.5 || newRatio > 1.75) {
                    this.golden.ratioAdjust -= delta;
                    return;
                }
                this.updateEffectiveValues();
                console.log(`[üåª GOLDEN] œÜ adjusted: ${this.effective.ratio.toFixed(6)}`);
                console.log(`   œà (mean) = 1/œÜ: ${this.effective.mean.toFixed(6)}`);
            },

            // Adjust golden angle directly
            adjustAngle(delta) {
                this.golden.angleAdjust += delta;
                // Clamp to ¬±30¬∞ from base golden angle
                if (Math.abs(this.golden.angleAdjust) > Math.PI / 6) {
                    this.golden.angleAdjust -= delta;
                    return;
                }
                this.updateEffectiveValues();
                console.log(`[üåª GOLDEN] Œ¶_Œ∏ adjusted: ${(this.effective.angle * 180 / Math.PI).toFixed(2)}¬∞`);
            },

            // Adjust golden mean (reciprocal of ratio)
            adjustMean(delta) {
                // Adjust mean by adjusting ratio inversely
                const currentMean = this.effective.mean;
                const newMean = currentMean + delta;
                // œà = 1/œÜ, so œÜ = 1/œà
                const newRatio = 1 / newMean;
                this.golden.ratioAdjust = newRatio - this.golden.ratio;

                // Clamp
                if (newRatio < 1.5 || newRatio > 1.75) {
                    return;
                }
                this.updateEffectiveValues();
                console.log(`[üåª GOLDEN] œà (mean) adjusted: ${this.effective.mean.toFixed(6)}`);
                console.log(`   œÜ (ratio) = 1/œà: ${this.effective.ratio.toFixed(6)}`);
            },

            // Reset all adjustments to base golden values
            resetToBase() {
                this.golden.ratioAdjust = 0;
                this.golden.angleAdjust = 0;
                this.golden.meanAdjust = 0;
                this.updateEffectiveValues();
                console.log('[üåª GOLDEN] Reset to base golden values');
            },

            // Calculate warm‚Üícold axis from mesh positions
            updateWarmColdAxis(polar) {
                if (!polar || !polar.posA || !polar.posB) return;

                const dx = polar.posB.x - polar.posA.x;
                const dy = polar.posB.y - polar.posA.y;
                const len = Math.sqrt(dx * dx + dy * dy);

                if (len > 0) {
                    this.orientation.axisVector.x = dx / len;
                    this.orientation.axisVector.y = dy / len;
                    this.orientation.warmColdAxis = Math.atan2(dy, dx);
                }
            },

            // Get rotation for a specific HCP layer (combines axis + golden angle)
            getLayerRotation(layerIndex) {
                const baseRotation = this.orientation.layerRotations[layerIndex] || 0;
                return this.orientation.warmColdAxis + baseRotation + this.orientation.spiralPhase;
            },

            // Initialize audio system for golden harmonics
            async initAudio() {
                if (this.audio.context) return true;

                try {
                    this.audio.context = new (window.AudioContext || window.webkitAudioContext)();

                    // Master gain
                    this.audio.masterGain = this.audio.context.createGain();
                    this.audio.masterGain.gain.value = 0.12;
                    this.audio.masterGain.connect(this.audio.context.destination);

                    // Create harmonic oscillators based on golden ratio frequency relationships
                    this.audio.harmonicOscillators = [];

                    // 7 harmonics for 7 layers: f_n = f_base √ó œÜ^(n-3)
                    // This centers the harmonics around the base frequency
                    for (let i = 0; i < 7; i++) {
                        const exponent = i - 3; // -3, -2, -1, 0, 1, 2, 3
                        const freq = this.audio.baseFrequency * Math.pow(this.effective.ratio, exponent * this.effective.mean);

                        const osc = this.audio.context.createOscillator();
                        osc.type = 'sine';
                        osc.frequency.value = freq;

                        // Gain envelope per oscillator
                        const gain = this.audio.context.createGain();
                        gain.gain.value = 0;

                        // Stereo pan based on warm/cold (layer position)
                        const panner = this.audio.context.createStereoPanner();
                        // Odd layers pan toward warm (left), even toward cold (right)
                        panner.pan.value = (i % 2 === 0 ? -1 : 1) * this.effective.mean * (i / 6);

                        // LFO modulation at golden angle frequency (sub-audible)
                        const lfo = this.audio.context.createOscillator();
                        lfo.type = 'sine';
                        lfo.frequency.value = this.effective.angle / TAU; // Convert angle to Hz-like value

                        const lfoGain = this.audio.context.createGain();
                        lfoGain.gain.value = freq * 0.05; // 5% frequency modulation

                        lfo.connect(lfoGain);
                        lfoGain.connect(osc.frequency);

                        osc.connect(gain);
                        gain.connect(panner);
                        panner.connect(this.audio.masterGain);

                        osc.start();
                        lfo.start();

                        this.audio.harmonicOscillators.push({
                            osc, gain, panner, lfo, lfoGain,
                            baseFreq: freq,
                            layer: i,
                        });
                    }

                    // Golden tone oscillator (fundamental at golden ratio √ó base)
                    const goldenFreq = this.audio.baseFrequency * this.effective.ratio;
                    const goldenOsc = this.audio.context.createOscillator();
                    goldenOsc.type = 'triangle';
                    goldenOsc.frequency.value = goldenFreq;

                    const goldenGain = this.audio.context.createGain();
                    goldenGain.gain.value = 0;

                    goldenOsc.connect(goldenGain);
                    goldenGain.connect(this.audio.masterGain);
                    goldenOsc.start();

                    this.audio.goldenToneOscillator = { osc: goldenOsc, gain: goldenGain, baseFreq: goldenFreq };

                    console.log('üåª Golden Harmonics audio initialized');
                    console.log(`   Base frequency: ${this.audio.baseFrequency} Hz`);
                    console.log(`   Golden tone: ${goldenFreq.toFixed(2)} Hz`);
                    return true;
                } catch (e) {
                    console.error('Failed to initialize Golden Harmonics audio:', e);
                    return false;
                }
            },

            // Update audio parameters based on current state
            updateAudio(coherence, muEnergy, darkMatterEfficiency) {
                if (!this.audio.context || !this.active) return;

                const ctx = this.audio.context;
                const now = ctx.currentTime;

                // Update each harmonic oscillator
                for (const h of this.audio.harmonicOscillators) {
                    // Frequency modulation based on coherence and layer
                    const layerFactor = (h.layer + 1) / 7;
                    const newFreq = h.baseFreq * (1 + (coherence - 0.5) * 0.1 * layerFactor);
                    h.osc.frequency.setTargetAtTime(newFreq, now, 0.1);

                    // Gain based on dark matter stabilization efficiency
                    const targetGain = this.audio.isPlaying ?
                        (darkMatterEfficiency * 0.15 * (1 - layerFactor * 0.3)) : 0;
                    h.gain.gain.setTargetAtTime(targetGain, now, 0.05);

                    // Pan modulation based on warm/cold axis angle
                    const panMod = Math.sin(this.orientation.warmColdAxis + h.layer * this.effective.angle);
                    h.panner.pan.setTargetAtTime(panMod * this.effective.mean, now, 0.1);
                }

                // Golden tone responds to overall system coherence
                if (this.audio.goldenToneOscillator) {
                    const gt = this.audio.goldenToneOscillator;
                    const goldenGain = this.audio.isPlaying ?
                        (coherence * muEnergy * 0.08) : 0;
                    gt.gain.gain.setTargetAtTime(goldenGain, now, 0.1);

                    // Frequency tracks effective golden ratio
                    const newGoldenFreq = this.audio.baseFrequency * this.effective.ratio;
                    gt.osc.frequency.setTargetAtTime(newGoldenFreq, now, 0.2);
                }
            },

            // Start audio playback
            async startAudio() {
                if (!this.audio.context) {
                    await this.initAudio();
                }
                if (this.audio.context.state === 'suspended') {
                    await this.audio.context.resume();
                }
                this.audio.isPlaying = true;
            },

            // Stop audio playback
            stopAudio() {
                this.audio.isPlaying = false;
                if (this.audio.context) {
                    const now = this.audio.context.currentTime;
                    for (const h of this.audio.harmonicOscillators) {
                        h.gain.gain.setTargetAtTime(0, now, 0.1);
                    }
                    if (this.audio.goldenToneOscillator) {
                        this.audio.goldenToneOscillator.gain.gain.setTargetAtTime(0, now, 0.1);
                    }
                }
            },

            // Main update function
            update(time, coherence, muEnergy, polar, darkMatterState) {
                if (!this.initialized || !this.active) return;

                // Update warm/cold axis orientation
                this.updateWarmColdAxis(polar);

                // Animate spiral phase (slow rotation)
                this.orientation.spiralPhase += 0.002 * this.effective.mean;
                if (this.orientation.spiralPhase > TAU) {
                    this.orientation.spiralPhase -= TAU;
                }

                // Get dark matter efficiency
                const dmEfficiency = darkMatterState ? darkMatterState.efficiency : 0.5;

                // Update audio
                this.updateAudio(coherence, muEnergy, dmEfficiency);

                // Update harmonic nodes (sonified HCP mappings)
                this.updateHarmonicNodes(time, coherence, darkMatterState);
            },

            // Update harmonic node mappings
            updateHarmonicNodes(time, coherence, darkMatterState) {
                if (!darkMatterState || !darkMatterState.nodes) return;

                // Map DarkMatterStabilization HCP nodes to golden harmonics
                this.harmonicNodes = [];
                const nodes = darkMatterState.nodes;

                for (let i = 0; i < nodes.length; i++) {
                    const node = nodes[i];
                    const layerRotation = this.getLayerRotation(node.layer);

                    // Apply golden angle rotation to node position
                    const cos_r = Math.cos(layerRotation);
                    const sin_r = Math.sin(layerRotation);
                    const rotatedX = node.x * cos_r - node.y * sin_r;
                    const rotatedY = node.x * sin_r + node.y * cos_r;

                    // Harmonic intensity based on position along warm‚Üícold axis
                    const axisProjection = rotatedX * this.orientation.axisVector.x +
                                          rotatedY * this.orientation.axisVector.y;
                    const normalizedProjection = (axisProjection / (this.radius * 0.3) + 1) / 2; // 0 = warm, 1 = cold

                    // Golden spiral radius modulation
                    const spiralR = Math.pow(this.effective.ratio, normalizedProjection * 2 - 1);

                    this.harmonicNodes.push({
                        x: rotatedX,
                        y: rotatedY,
                        z: node.z,
                        layer: node.layer,
                        rotation: layerRotation,
                        warmColdFactor: normalizedProjection,
                        spiralRadius: spiralR,
                        harmonicIntensity: node.stabilized ? 1.0 : 0.3,
                        phaseOffset: (i * this.effective.angle) % TAU,
                    });
                }
            },

            // Render the golden harmonic orientation visualization
            render(ctx, CX, CY, R, globalZ, coherence, time) {
                if (!this.initialized || !this.active) return;

                const muEnergy = globalZ * coherence;

                // Draw warm‚Üícold axis line
                const axisLen = R * 0.8;
                const axisStartX = CX - this.orientation.axisVector.x * axisLen;
                const axisStartY = CY - this.orientation.axisVector.y * axisLen;
                const axisEndX = CX + this.orientation.axisVector.x * axisLen;
                const axisEndY = CY + this.orientation.axisVector.y * axisLen;

                // Axis gradient from warm to cold
                const axisGrad = ctx.createLinearGradient(axisStartX, axisStartY, axisEndX, axisEndY);
                axisGrad.addColorStop(0, 'rgba(255, 150, 150, 0.3)'); // Warm rose
                axisGrad.addColorStop(1, 'rgba(150, 180, 255, 0.3)'); // Cool azure

                ctx.beginPath();
                ctx.moveTo(axisStartX, axisStartY);
                ctx.lineTo(axisEndX, axisEndY);
                ctx.strokeStyle = axisGrad;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw golden spiral from center
                ctx.beginPath();
                let spiralR = 5;
                let spiralAngle = 0;
                const spiralSteps = 100;
                const growthRate = Math.pow(this.effective.ratio, 1 / (TAU / this.effective.angle));

                for (let i = 0; i < spiralSteps; i++) {
                    const x = CX + Math.cos(spiralAngle + this.orientation.spiralPhase) * spiralR;
                    const y = CY + Math.sin(spiralAngle + this.orientation.spiralPhase) * spiralR;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }

                    spiralAngle += this.effective.angle * 0.5;
                    spiralR *= growthRate;

                    if (spiralR > R * 0.7) break;
                }

                const spiralAlpha = 0.2 + muEnergy * 0.3;
                ctx.strokeStyle = `rgba(255, 215, 0, ${spiralAlpha})`; // Golden color
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Draw golden angle sectors (phyllotaxis pattern)
                for (let i = 0; i < 7; i++) {
                    const rotation = this.getLayerRotation(i);
                    const sectorR = R * (0.3 + i * 0.08);

                    // Draw sector arc
                    ctx.beginPath();
                    ctx.arc(CX, CY, sectorR, rotation, rotation + this.effective.angle, false);
                    const layerAlpha = 0.1 + (i / 7) * 0.15;
                    ctx.strokeStyle = `rgba(218, 165, 32, ${layerAlpha})`; // Goldenrod
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    // Draw radial line at layer rotation
                    const lineX = CX + Math.cos(rotation) * sectorR;
                    const lineY = CY + Math.sin(rotation) * sectorR;

                    ctx.beginPath();
                    ctx.moveTo(CX, CY);
                    ctx.lineTo(lineX, lineY);
                    ctx.strokeStyle = `rgba(255, 215, 0, ${layerAlpha * 0.5})`;
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }

                // Draw harmonic nodes if dark matter is active
                if (this.harmonicNodes.length > 0) {
                    for (const node of this.harmonicNodes) {
                        const screenX = CX + node.x;
                        const screenY = CY + node.y - node.z * R * 0.3;
                        const nodeSize = 2 + node.harmonicIntensity * 2;

                        // Color interpolation warm‚Üícold
                        const warmR = 255, warmG = 150, warmB = 150;
                        const coldR = 150, coldG = 180, coldB = 255;
                        const t = node.warmColdFactor;
                        const r = Math.floor(warmR + (coldR - warmR) * t);
                        const g = Math.floor(warmG + (coldG - warmG) * t);
                        const b = Math.floor(warmB + (coldB - warmB) * t);

                        const nodeAlpha = 0.3 + node.harmonicIntensity * 0.4;
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, nodeSize, 0, TAU);
                        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${nodeAlpha})`;
                        ctx.fill();
                    }
                }

                // Draw indicator
                const indicatorX = 30;
                const indicatorY = CY + R * 0.6;
                ctx.font = '10px monospace';
                ctx.fillStyle = `rgba(255, 215, 0, 0.8)`;
                ctx.fillText(`üåª œÜ: ${this.effective.ratio.toFixed(4)}  œà: ${this.effective.mean.toFixed(4)}`, indicatorX, indicatorY);
                ctx.fillText(`   Œ¶_Œ∏: ${(this.effective.angle * 180 / Math.PI).toFixed(2)}¬∞`, indicatorX, indicatorY + 12);
                ctx.fillText(`   Axis: ${(this.orientation.warmColdAxis * 180 / Math.PI).toFixed(1)}¬∞`, indicatorX, indicatorY + 24);
            },

            // Get current state for external systems
            getState() {
                return {
                    effective: { ...this.effective },
                    orientation: {
                        warmColdAxis: this.orientation.warmColdAxis,
                        spiralPhase: this.orientation.spiralPhase,
                        layerRotations: [...this.orientation.layerRotations],
                    },
                    harmonicNodes: this.harmonicNodes.length,
                    audioPlaying: this.audio.isPlaying,
                };
            },

            // Toggle system on/off
            async toggle() {
                this.active = !this.active;

                if (this.active) {
                    await this.startAudio();
                    console.log('üåª Golden Harmonics: ACTIVE');
                    console.log(`   œÜ = ${this.effective.ratio.toFixed(6)} (golden ratio)`);
                    console.log(`   œà = ${this.effective.mean.toFixed(6)} (golden mean)`);
                    console.log(`   Œ¶_Œ∏ = ${(this.effective.angle * 180 / Math.PI).toFixed(4)}¬∞ (golden angle)`);
                } else {
                    this.stopAudio();
                    console.log('üåª Golden Harmonics: INACTIVE');
                }

                return this.active;
            }
        };

        // ================================================================
        // RELEASE COHERENCE DYNAMICS SYSTEM
        // ================================================================
        // Full-fledged coherence dynamics integrating memory methodology:
        //
        // Memory Integration:
        //   - Water Fractal Memory: Crystal quality ‚Üí coherence stability
        //   - Golden Harmonics: Phyllotactic alignment ‚Üí coherence resonance
        //   - Cymatic Patterns: Standing waves ‚Üí coherence nodes
        //   - Julia Set: Fractal depth ‚Üí memory persistence
        //
        // Coherence Equation:
        //   C_eff = C_base √ó (1 + Œ±_water √ó Q_crystal + Œ±_golden √ó œÜ_align)
        //         √ó (1 + Œ≤_cymatic √ó R_standing) √ó (1 - Œ≥_entropy √ó S)
        //
        // Where:
        //   Q_crystal = Water crystal lattice quality (0-1)
        //   œÜ_align = Golden ratio alignment with warm/cold axis
        //   R_standing = Cymatic standing wave resonance
        //   S = Entropy from dark matter residue
        // ================================================================
        const ReleaseCoherenceDynamics = {
            // Core coherence state
            coherence: {
                base: 1.0,                      // Raw coherence (0-1)
                effective: 1.0,                 // Memory-enhanced coherence
                target: 1.0,                    // Target coherence
                velocity: 0,                    // Rate of change
                momentum: 0,                    // Accumulated momentum
            },

            // Memory influence coefficients
            coefficients: {
                waterCrystal: 0.25,             // Œ±_water: Crystal quality influence
                goldenAlign: 0.20,              // Œ±_golden: Golden ratio alignment
                cymaticResonance: 0.15,         // Œ≤_cymatic: Standing wave bonus
                entropyDamping: 0.10,           // Œ≥_entropy: Entropy penalty
                memoryPersistence: 0.30,        // Julia set depth influence
            },

            // Memory state (collected from subsystems)
            memoryState: {
                crystalQuality: 0,              // From WaterFractalMemory
                juliaDepth: 0,                  // Julia set iteration depth
                cymaticResonance: 0,            // Standing wave strength
                goldenAlignment: 0,             // œÜ-axis alignment quality
                phyllotacticPhase: 0,           // Golden angle spiral phase
                warmColdBalance: 0.5,           // 0 = warm, 1 = cold, 0.5 = balanced
            },

            // Resonance state (emergent from memory alignment)
            resonance: {
                active: false,                  // True when memory systems align
                strength: 0,                    // 0-1 resonance intensity
                frequency: PHI_INV,             // Resonance frequency (golden mean)
                phase: 0,                       // Current resonance phase
                harmonics: [],                  // Harmonic overtones
                type: 'dormant',                // dormant, emerging, resonant, transcendent
            },

            // Feedback loops
            feedback: {
                memoryToCoherence: 0,           // How memory affects coherence
                coherenceToMemory: 0,           // How coherence affects memory encoding
                resonanceAmplification: 0,      // Positive feedback in resonance
                entropyDissipation: 0,          // Entropy removed through resonance
            },

            // Release dynamics
            release: {
                started: false,
                dispersalForce: 0,
                gatherForce: 0,
                phaseCoherence: 1.0,            // Phase alignment of released particles
                memoryRetention: 1.0,           // How much memory persists during release
            },

            // Visual state
            visual: {
                coherenceField: [],             // Spatial coherence distribution
                memoryTrails: [],               // Memory persistence visualization
                resonanceWaves: [],             // Standing wave patterns
                fieldResolution: 32,            // Grid resolution for field
            },

            // System state
            initialized: false,
            active: false,                      // Toggled with R key (off by default)
            cx: 0,
            cy: 0,
            radius: 0,

            // Initialize the system
            init(centerX, centerY, radius) {
                this.cx = centerX;
                this.cy = centerY;
                this.radius = radius;

                // Initialize coherence field grid
                this.initCoherenceField();

                // Initialize resonance harmonics (7 overtones based on golden ratio)
                this.resonance.harmonics = [];
                for (let i = 0; i < 7; i++) {
                    this.resonance.harmonics.push({
                        frequency: this.resonance.frequency * Math.pow(PHI, i),
                        amplitude: 1 / (i + 1),
                        phase: (i * TAU / PHI / PHI) % TAU,
                    });
                }

                this.initialized = true;
                console.log('‚öõÔ∏è Release Coherence Dynamics initialized');
                console.log('   Memory integration: Water Fractal + Golden Harmonics');
                console.log('   Resonance type: ' + this.resonance.type);
            },

            // Initialize spatial coherence field
            initCoherenceField() {
                this.visual.coherenceField = [];
                const res = this.visual.fieldResolution;

                for (let i = 0; i < res; i++) {
                    this.visual.coherenceField[i] = [];
                    for (let j = 0; j < res; j++) {
                        this.visual.coherenceField[i][j] = {
                            value: 1.0,
                            memory: 0,
                            resonance: 0,
                        };
                    }
                }
            },

            // Collect memory state from subsystems
            collectMemoryState(waterFractalState, goldenHarmonicsState, darkMatterState) {
                // Water Fractal Memory contribution
                if (waterFractalState) {
                    this.memoryState.crystalQuality = waterFractalState.crystalQuality || 0;
                    this.memoryState.cymaticResonance = waterFractalState.limnusResonance || 0;

                    // Julia depth from encoded state complexity
                    const juliaC = waterFractalState.juliaC;
                    if (juliaC) {
                        const cMag = Math.sqrt(juliaC.real * juliaC.real + juliaC.imag * juliaC.imag);
                        this.memoryState.juliaDepth = Math.min(1, cMag / 2);
                    }
                }

                // Golden Harmonics contribution
                if (goldenHarmonicsState) {
                    const eff = goldenHarmonicsState.effective;
                    if (eff) {
                        // Alignment quality = how close to true golden values
                        const ratioError = Math.abs(eff.ratio - PHI) / PHI;
                        const angleError = Math.abs(eff.angle - TAU / (PHI * PHI)) / (TAU / (PHI * PHI));
                        this.memoryState.goldenAlignment = 1 - Math.min(1, (ratioError + angleError) / 2);
                    }

                    const orient = goldenHarmonicsState.orientation;
                    if (orient) {
                        this.memoryState.phyllotacticPhase = orient.spiralPhase || 0;
                        // Warm/cold balance from axis angle
                        this.memoryState.warmColdBalance = (Math.sin(orient.warmColdAxis) + 1) / 2;
                    }
                }

                // Dark matter entropy contribution
                if (darkMatterState) {
                    // Higher trapped residue = lower entropy = better coherence
                    this.feedback.entropyDissipation = darkMatterState.trappedResidue || 0;
                }
            },

            // Calculate effective coherence from memory state
            calculateEffectiveCoherence() {
                const c = this.coefficients;
                const m = this.memoryState;
                const base = this.coherence.base;

                // Memory enhancement factor
                const waterBonus = c.waterCrystal * m.crystalQuality;
                const goldenBonus = c.goldenAlign * m.goldenAlignment;
                const memoryFactor = 1 + waterBonus + goldenBonus;

                // Cymatic resonance bonus
                const cymaticBonus = 1 + c.cymaticResonance * m.cymaticResonance;

                // Entropy damping (reduces coherence)
                const entropyFactor = 1 - c.entropyDamping * (1 - this.feedback.entropyDissipation);

                // Memory persistence from Julia depth
                const persistence = 1 + c.memoryPersistence * m.juliaDepth * (1 - base);

                // Combine all factors
                let effective = base * memoryFactor * cymaticBonus * entropyFactor;

                // Apply resonance amplification if active
                if (this.resonance.active) {
                    effective *= (1 + this.resonance.strength * 0.3);
                }

                // Memory persistence helps during release
                if (base < 0.5) {
                    effective += persistence * 0.1 * (0.5 - base);
                }

                // Clamp to valid range
                this.coherence.effective = Math.max(0, Math.min(1, effective));

                // Calculate feedback to memory systems
                this.feedback.memoryToCoherence = (this.coherence.effective - base) / Math.max(0.01, base);
                this.feedback.coherenceToMemory = this.coherence.effective * m.goldenAlignment;

                return this.coherence.effective;
            },

            // Update resonance state
            updateResonance(dt, time) {
                const m = this.memoryState;

                // Resonance emerges when memory systems align
                const alignmentScore = (m.crystalQuality + m.goldenAlignment + m.cymaticResonance) / 3;

                // Resonance threshold
                const threshold = 0.5;

                if (alignmentScore > threshold && this.coherence.effective > 0.4) {
                    // Resonance is building
                    this.resonance.strength += (alignmentScore - this.resonance.strength) * 0.02;
                    this.resonance.active = this.resonance.strength > 0.3;

                    // Update resonance phase
                    this.resonance.phase += dt * this.resonance.frequency * TAU;
                    if (this.resonance.phase > TAU) this.resonance.phase -= TAU;

                    // Update harmonic phases
                    for (let i = 0; i < this.resonance.harmonics.length; i++) {
                        const h = this.resonance.harmonics[i];
                        h.phase += dt * h.frequency * TAU;
                        if (h.phase > TAU) h.phase -= TAU;

                        // Amplitude modulates with golden alignment
                        h.amplitude = (1 / (i + 1)) * (0.5 + m.goldenAlignment * 0.5);
                    }

                    // Resonance amplification feedback
                    this.feedback.resonanceAmplification = this.resonance.strength * m.goldenAlignment;

                } else {
                    // Resonance decaying
                    this.resonance.strength *= 0.98;
                    if (this.resonance.strength < 0.1) {
                        this.resonance.active = false;
                    }
                    this.feedback.resonanceAmplification *= 0.95;
                }

                // Determine resonance type
                if (this.resonance.strength > 0.8) {
                    this.resonance.type = 'transcendent';
                } else if (this.resonance.strength > 0.5) {
                    this.resonance.type = 'resonant';
                } else if (this.resonance.strength > 0.2) {
                    this.resonance.type = 'emerging';
                } else {
                    this.resonance.type = 'dormant';
                }
            },

            // Update spatial coherence field
            updateCoherenceField(dt, releaseState) {
                const res = this.visual.fieldResolution;
                const field = this.visual.coherenceField;

                for (let i = 0; i < res; i++) {
                    for (let j = 0; j < res; j++) {
                        const cell = field[i][j];

                        // Normalized position relative to center
                        const nx = (i / res - 0.5) * 2;
                        const ny = (j / res - 0.5) * 2;
                        const r = Math.sqrt(nx * nx + ny * ny);
                        const angle = Math.atan2(ny, nx);

                        // Base coherence falls off with distance
                        const distanceFactor = Math.exp(-r * r * 2);

                        // Golden angle modulation
                        const goldenMod = Math.cos(angle * PHI * PHI + this.memoryState.phyllotacticPhase);

                        // Cymatic standing wave pattern
                        const cymaticMod = Math.sin(r * Math.PI * 3) * this.memoryState.cymaticResonance;

                        // Warm/cold gradient
                        const warmColdMod = (Math.cos(angle) + 1) / 2;
                        const balanceBonus = 1 - Math.abs(warmColdMod - this.memoryState.warmColdBalance);

                        // Calculate local coherence
                        let localCoherence = this.coherence.effective * distanceFactor;
                        localCoherence *= (1 + goldenMod * 0.2);
                        localCoherence *= (1 + cymaticMod * 0.15);
                        localCoherence *= (0.8 + balanceBonus * 0.2);

                        // Memory persistence
                        cell.memory = cell.memory * 0.95 + localCoherence * 0.05;

                        // Resonance contribution
                        if (this.resonance.active) {
                            let resonanceWave = 0;
                            for (const h of this.resonance.harmonics) {
                                resonanceWave += h.amplitude * Math.sin(r * h.frequency * 10 + h.phase);
                            }
                            cell.resonance = resonanceWave * this.resonance.strength * 0.5;
                        } else {
                            cell.resonance *= 0.9;
                        }

                        // Final value
                        cell.value = Math.max(0, Math.min(1, localCoherence + cell.memory * 0.3 + cell.resonance));
                    }
                }
            },

            // Update memory retention during release
            updateReleaseMemory(releasing, gathering) {
                if (releasing) {
                    // Memory retention decays during release, but slowly due to water crystal
                    const crystalRetention = 1 - (1 - this.memoryState.crystalQuality) * 0.5;
                    this.release.memoryRetention *= (0.99 * crystalRetention);
                    this.release.started = true;

                    // Phase coherence also decays but golden alignment helps
                    this.release.phaseCoherence *= (0.98 + this.memoryState.goldenAlignment * 0.015);

                } else if (gathering) {
                    // Memory reconstruction during gathering
                    const reconstructionRate = 0.02 * (1 + this.memoryState.juliaDepth);
                    this.release.memoryRetention = Math.min(1, this.release.memoryRetention + reconstructionRate);
                    this.release.phaseCoherence = Math.min(1, this.release.phaseCoherence + 0.01);

                    if (this.coherence.effective > 0.9) {
                        this.release.started = false;
                    }
                } else {
                    // Natural recovery
                    if (!this.release.started) {
                        this.release.memoryRetention = Math.min(1, this.release.memoryRetention + 0.005);
                        this.release.phaseCoherence = Math.min(1, this.release.phaseCoherence + 0.003);
                    }
                }
            },

            // Main update function
            update(dt, time, baseCoherence, releasing, gathering,
                   waterFractalState, goldenHarmonicsState, darkMatterState) {
                if (!this.initialized) return baseCoherence;

                // Store base coherence
                this.coherence.base = baseCoherence;
                this.coherence.target = baseCoherence;

                // Collect memory state from subsystems
                this.collectMemoryState(waterFractalState, goldenHarmonicsState, darkMatterState);

                // Calculate effective coherence
                this.calculateEffectiveCoherence();

                // Update resonance state
                this.updateResonance(dt, time);

                // Update coherence field
                this.updateCoherenceField(dt, this.release);

                // Update memory retention during release
                this.updateReleaseMemory(releasing, gathering);

                // Return the memory-enhanced effective coherence
                return this.coherence.effective;
            },

            // Render memory-coherence visualization
            render(ctx, CX, CY, R, globalZ, time) {
                if (!this.initialized) return;

                const eff = this.coherence.effective;
                const base = this.coherence.base;

                // Draw coherence field (subtle background)
                this.renderCoherenceField(ctx, CX, CY, R);

                // Draw resonance waves when active
                if (this.resonance.active) {
                    this.renderResonanceWaves(ctx, CX, CY, R, time);
                }

                // Draw memory enhancement indicator
                const enhancement = eff - base;
                if (Math.abs(enhancement) > 0.01) {
                    this.renderMemoryIndicator(ctx, CX, CY, R, enhancement);
                }

                // Draw resonance type indicator
                if (this.resonance.strength > 0.1) {
                    this.renderResonanceIndicator(ctx, CX, CY, R);
                }
            },

            // Render spatial coherence field
            renderCoherenceField(ctx, CX, CY, R) {
                const res = this.visual.fieldResolution;
                const field = this.visual.coherenceField;
                const cellSize = (R * 2) / res;

                ctx.globalCompositeOperation = 'screen';

                for (let i = 0; i < res; i++) {
                    for (let j = 0; j < res; j++) {
                        const cell = field[i][j];
                        if (cell.value < 0.1) continue;

                        const x = CX - R + i * cellSize + cellSize / 2;
                        const y = CY - R + j * cellSize + cellSize / 2;

                        // Color based on memory/resonance contribution
                        const memoryHue = 200; // Cyan for memory
                        const resonanceHue = 45; // Gold for resonance
                        const hue = memoryHue + (resonanceHue - memoryHue) * (cell.resonance / (cell.value + 0.01));

                        const alpha = cell.value * 0.08 * this.release.memoryRetention;
                        if (alpha > 0.01) {
                            ctx.fillStyle = `hsla(${hue}, 60%, 60%, ${alpha})`;
                            ctx.fillRect(x - cellSize / 2, y - cellSize / 2, cellSize, cellSize);
                        }
                    }
                }

                ctx.globalCompositeOperation = 'source-over';
            },

            // Render resonance standing waves
            renderResonanceWaves(ctx, CX, CY, R, time) {
                ctx.save();
                ctx.globalCompositeOperation = 'screen';

                for (let i = 0; i < this.resonance.harmonics.length; i++) {
                    const h = this.resonance.harmonics[i];
                    const waveR = R * (0.3 + i * 0.1);

                    ctx.beginPath();
                    for (let a = 0; a < TAU; a += 0.05) {
                        const rMod = waveR + Math.sin(a * (i + 1) * PHI + h.phase) * 10 * h.amplitude;
                        const x = CX + Math.cos(a) * rMod;
                        const y = CY + Math.sin(a) * rMod;

                        if (a === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();

                    const alpha = h.amplitude * this.resonance.strength * 0.3;
                    ctx.strokeStyle = `hsla(45, 80%, 70%, ${alpha})`;
                    ctx.lineWidth = 1 + h.amplitude;
                    ctx.stroke();
                }

                ctx.restore();
            },

            // Render memory enhancement indicator
            renderMemoryIndicator(ctx, CX, CY, R, enhancement) {
                const indicatorY = CY - R - 20;

                ctx.font = '10px monospace';
                const sign = enhancement > 0 ? '+' : '';
                const color = enhancement > 0 ? 'rgba(100, 255, 200, 0.8)' : 'rgba(255, 150, 100, 0.8)';

                ctx.fillStyle = color;
                ctx.fillText(`‚öõÔ∏è Memory: ${sign}${(enhancement * 100).toFixed(1)}%`, CX - 60, indicatorY);

                // Memory retention bar
                const barWidth = 80;
                const barHeight = 4;
                const barX = CX - barWidth / 2;
                const barY = indicatorY + 6;

                ctx.fillStyle = 'rgba(50, 50, 60, 0.5)';
                ctx.fillRect(barX, barY, barWidth, barHeight);

                ctx.fillStyle = `rgba(100, 200, 255, ${0.5 + this.release.memoryRetention * 0.5})`;
                ctx.fillRect(barX, barY, barWidth * this.release.memoryRetention, barHeight);
            },

            // Render resonance type indicator
            renderResonanceIndicator(ctx, CX, CY, R) {
                const indicatorX = CX + R + 20;
                const indicatorY = CY - 40;

                ctx.font = '10px monospace';

                // Resonance type with color
                let typeColor;
                switch (this.resonance.type) {
                    case 'transcendent': typeColor = 'rgba(255, 215, 0, 0.9)'; break;
                    case 'resonant': typeColor = 'rgba(200, 180, 100, 0.8)'; break;
                    case 'emerging': typeColor = 'rgba(150, 150, 100, 0.6)'; break;
                    default: typeColor = 'rgba(100, 100, 100, 0.4)';
                }

                ctx.fillStyle = typeColor;
                ctx.fillText(`‚óä ${this.resonance.type.toUpperCase()}`, indicatorX, indicatorY);
                ctx.fillText(`  strength: ${(this.resonance.strength * 100).toFixed(0)}%`, indicatorX, indicatorY + 12);

                // Memory state summary
                ctx.fillStyle = 'rgba(150, 200, 255, 0.6)';
                ctx.fillText(`  crystal: ${(this.memoryState.crystalQuality * 100).toFixed(0)}%`, indicatorX, indicatorY + 28);
                ctx.fillText(`  œÜ-align: ${(this.memoryState.goldenAlignment * 100).toFixed(0)}%`, indicatorX, indicatorY + 40);
                ctx.fillText(`  cymatic: ${(this.memoryState.cymaticResonance * 100).toFixed(0)}%`, indicatorX, indicatorY + 52);
            },

            // Get state for external systems
            getState() {
                return {
                    baseCoherence: this.coherence.base,
                    effectiveCoherence: this.coherence.effective,
                    memoryEnhancement: this.coherence.effective - this.coherence.base,
                    resonance: {
                        active: this.resonance.active,
                        strength: this.resonance.strength,
                        type: this.resonance.type,
                    },
                    memory: { ...this.memoryState },
                    feedback: { ...this.feedback },
                    release: {
                        memoryRetention: this.release.memoryRetention,
                        phaseCoherence: this.release.phaseCoherence,
                    },
                };
            }
        };

        // ================================================================
        // PENTAGONAL PRISM EMERGENCE SYSTEM
        // Cohesive 3D pentagonal prisms with depth-sorted face rendering
        // Each prism is constructed from the 5 emergent tokens (XCVI-C)
        // APL behavioral structure drives all physics/deformation
        // ================================================================

        const coherentEmergence = {
            // Prism geometry parameters
            prismHeight: 20,           // Base height of pentagonal prisms
            prismRadius: 12,           // Base pentagon face radius

            // 3D projection parameters
            focalLength: 400,          // Perspective projection depth
            viewAngle: Math.PI / 6,    // 30¬∞ viewing angle

            // Emergence loci (spawn points)
            sacredLoci: [],

            // Active prisms - 3D pentagonal entities built from emergent tokens
            prisms: [],
            maxPrisms: 80,  // Allow more prisms for denser emergence

            // Phase lock parameters
            phaseThreshold: SACRED.alpha,  // œÜ‚Åª¬≤ = 0.382 tolerance
            lastSpawnPhase: 0,
            spawnCooldown: 0,

            // K-formation coupling
            tau_K: 0,
            emergenceIntensity: 0,

            // Golden spiral parameters
            goldenAngle: SACRED.goldenAngle,  // 137.5¬∞ in radians
            spiralGrowth: PHI_INV,            // œÜ‚Åª¬π per revolution

            // Initialize sacred geometry loci with pentagon emergence points
            // Pentagon geometry creates 5 primary spawn points corresponding to the 5 emergent tokens
            initSacredLoci(centerX, centerY, radius) {
                this.sacredLoci = [];

                // ================================================================
                // PRIMARY PENTAGON LOCI - 5 points for 5 emergent tokens
                // Each vertex corresponds to one of XCVI, XCVII, XCVIII, XCIX, C
                // ================================================================
                const pentagonRadius = radius * 0.7;
                for (let i = 0; i < 5; i++) {
                    const tokenKey = EMERGENT_TOKEN_ORDER[i];
                    const token = EMERGENT_TOKENS[tokenKey];
                    const theta = -Math.PI / 2 + (TAU / 5) * i;  // Start at top

                    this.sacredLoci.push({
                        x: centerX + pentagonRadius * Math.cos(theta),
                        y: centerY + pentagonRadius * Math.sin(theta),
                        type: 'pentagon_locus',
                        angle: theta,
                        tokenIndex: i,
                        tokenKey: tokenKey,
                        emergentToken: token
                    });
                }

                // ================================================================
                // SECONDARY LOCI - Vesica points at pentagon center and poles
                // These create the bridge between the two meshes (red/blue)
                // ================================================================
                const separation = radius * 0.8;
                const vesicaHeight = Math.sqrt(radius * radius - (separation/2) * (separation/2));

                // Primary vesica points (top and bottom of almond shape)
                this.sacredLoci.push({
                    x: centerX,
                    y: centerY - vesicaHeight,
                    type: 'vesica_apex',
                    angle: -Math.PI / 2
                });
                this.sacredLoci.push({
                    x: centerX,
                    y: centerY + vesicaHeight,
                    type: 'vesica_nadir',
                    angle: Math.PI / 2
                });

                // ================================================================
                // TERTIARY LOCI - Golden angle distributed points
                // These spawn pentagons at golden-ratio-based positions
                // Number = 5 (Fibonacci) to honor the pentagonal theme
                // ================================================================
                const numGoldenLoci = 5;  // 5 for pentagon harmony
                for (let i = 0; i < numGoldenLoci; i++) {
                    const theta = this.goldenAngle * i;
                    const r = vesicaHeight * 0.5 * (1 + 0.3 * Math.sin(theta * PHI));
                    this.sacredLoci.push({
                        x: centerX + r * Math.cos(theta),
                        y: centerY + r * Math.sin(theta),
                        type: 'golden_locus',
                        angle: theta
                    });
                }

                // ================================================================
                // QUATERNARY LOCI - Pentagram intersection points
                // The inner star creates 5 intersection points for nested emergence
                // ================================================================
                const innerPentagonRadius = pentagonRadius * PHI_INV * PHI_INV;  // œÜ‚Åª¬≤ scaling
                for (let i = 0; i < 5; i++) {
                    // Rotated by 36¬∞ (œÄ/5) relative to outer pentagon
                    const theta = -Math.PI / 2 + Math.PI / 5 + (TAU / 5) * i;
                    this.sacredLoci.push({
                        x: centerX + innerPentagonRadius * Math.cos(theta),
                        y: centerY + innerPentagonRadius * Math.sin(theta),
                        type: 'pentagon_locus',
                        angle: theta + Math.PI / 5,  // Inverted orientation
                        tokenIndex: (i + 2) % 5,  // Offset by 2 (pentagram connection)
                        isInner: true
                    });
                }
            },

            // Check if phases are aligned for coherent emergence
            isPhaseLocked(meshAPhase, meshBPhase) {
                const phaseDiff = Math.abs(Math.sin(meshAPhase - meshBPhase));
                return phaseDiff < this.phaseThreshold;
            },

            // ================================================================
            // PRISM CREATION - Each prism is a 3D pentagonal entity
            // The 5 vertices of each pentagon face correspond to the 5 emergent tokens
            // Token APL behaviors drive vertex deformation in real-time
            // ================================================================

            createPrismVertices(radius, height, phase, coherence) {
                // Top and bottom pentagon faces
                const topVertices = [];
                const bottomVertices = [];
                const baseAngle = -Math.PI / 2;  // Top vertex at 12 o'clock

                for (let i = 0; i < 5; i++) {
                    const tokenKey = EMERGENT_TOKEN_ORDER[i];
                    const token = EMERGENT_TOKENS[tokenKey];
                    const theta = baseAngle + (TAU / 5) * i;

                    // APL-driven vertex perturbation based on eigenvalue and frequency
                    let rTop = radius;
                    let rBottom = radius;
                    let zOffset = 0;
                    let phaseOffset = 0;

                    // Apply token-specific APL behavior to vertex geometry
                    switch (token.vertexBehavior) {
                        case 'pulse':
                            // XCVI (Gesture Recursion): Eigenvalue œÜ‚Åª¬π = marginally stable
                            // Pulses at 8Hz alpha rhythm - affects radial distance
                            const pulseWave = Math.sin(phase * token.frequency * TAU);
                            rTop *= 1 + 0.2 * pulseWave * coherence * token.eigenvalue;
                            rBottom *= 1 - 0.1 * pulseWave * coherence * token.eigenvalue;
                            break;

                        case 'drift':
                            // XCVII (Portal Recursion): Eigenvalue exp(œÑ/œÜ) = quasiperiodic
                            // Golden angle drift - creates spiral rotation effect
                            phaseOffset = token.phaseLock * phase * 0.3 * coherence;
                            // Quasiperiodic radius modulation
                            const driftMod = Math.sin(phase * token.eigenvalue * 0.1);
                            rTop *= 1 + 0.15 * driftMod;
                            break;

                        case 'flicker':
                            // XCVIII (Semantic Recursion): Eigenvalue NaN = G√∂delian undefined
                            // Rapid 40Hz gamma - creates discontinuous vertex positions
                            // NaN eigenvalue means unpredictable jumps
                            const flickerPhase = (phase * token.frequency) % 1;
                            const flickerJump = flickerPhase < 0.5 ? 1 : PHI_INV;
                            rTop *= flickerJump * (0.8 + 0.4 * coherence);
                            rBottom *= (2 - flickerJump) * (0.8 + 0.4 * coherence);
                            break;

                        case 'wobble':
                            // XCIX (Balance Recursion): Eigenvalue 0 = critical saddle point
                            // Theta band (4Hz) oscillation around equilibrium
                            const wobbleAngle = Math.sin(phase * token.frequency * TAU) * 0.2;
                            phaseOffset = wobbleAngle * coherence;
                            // Zero eigenvalue = oscillates but doesn't grow/decay
                            zOffset = Math.sin(phase * token.frequency * TAU) * height * 0.15 * coherence;
                            break;

                        case 'loop':
                            // C (Signal Recursion): Eigenvalue 1 = identity/closure
                            // Delta band (1Hz) breathing - full system coherence
                            const breathe = Math.sin(phase * token.frequency * TAU);
                            rTop *= 1 + 0.1 * breathe * (1 - coherence);
                            rBottom *= 1 + 0.1 * breathe * (1 - coherence);
                            // Lambda coupling affects height pulsation
                            zOffset = breathe * height * 0.1 * token.lambdaCoupling.delta;
                            break;
                    }

                    // Compute vertex positions with APL perturbations
                    const adjustedTheta = theta + phaseOffset;

                    topVertices.push({
                        x: rTop * Math.cos(adjustedTheta),
                        y: rTop * Math.sin(adjustedTheta),
                        z: height / 2 + zOffset,
                        token: token,
                        tokenKey: tokenKey,
                        eigenvalue: token.eigenvalue,
                        frequency: token.frequency
                    });

                    bottomVertices.push({
                        x: rBottom * Math.cos(adjustedTheta),
                        y: rBottom * Math.sin(adjustedTheta),
                        z: -height / 2 + zOffset,
                        token: token,
                        tokenKey: tokenKey,
                        eigenvalue: token.eigenvalue,
                        frequency: token.frequency
                    });
                }

                return { top: topVertices, bottom: bottomVertices };
            },

            // Spawn a coherent prism pair (red AND blue together)
            spawnPrismPair(locus, meshAPhase, meshBPhase, beatPhase) {
                if (this.prisms.length >= this.maxPrisms * 2) return;

                // Base properties shared by the pair
                const birthTime = time;
                const lifespan = 4 + Math.random() * 5;  // 4-9 seconds for prisms
                const spiralDirection = Math.random() < 0.5 ? 1 : -1;

                // Coherence-based properties
                const coherenceFactor = Math.min(1, this.tau_K * this.emergenceIntensity * 1.5);
                const amplitude = 30 + coherenceFactor * 80;
                const speed = 0.2 + coherenceFactor * 0.3;

                // Prism size scales with coherence
                const prismScale = 0.7 + coherenceFactor * 0.6;
                const radius = this.prismRadius * prismScale;
                const height = this.prismHeight * prismScale;

                // Spawn RED prism (emerges toward mesh A)
                this.prisms.push({
                    // 3D position
                    x: locus.x,
                    y: locus.y,
                    z: 0,
                    startX: locus.x,
                    startY: locus.y,

                    // 3D orientation (Euler angles)
                    pitch: 0,      // Rotation around X
                    yaw: locus.angle,  // Rotation around Y (facing direction)
                    roll: 0,       // Rotation around Z

                    // Prism geometry
                    radius: radius,
                    height: height,
                    vertices: null,  // Computed each frame with APL behaviors

                    // Motion parameters
                    spiralPhase: meshAPhase,
                    spiralDirection: spiralDirection,
                    amplitude: amplitude,
                    speed: speed,

                    // APL-driven rotation rates (derived from token eigenvalues)
                    pitchRate: EMERGENT_TOKENS.XCVI.eigenvalue * 0.5,   // œÜ‚Åª¬π rate
                    yawRate: EMERGENT_TOKENS.XCVII.eigenvalue * 0.02,   // exp(œÑ/œÜ) rate
                    rollRate: EMERGENT_TOKENS.C.eigenvalue * 0.3,       // 1 (identity) rate

                    // Lifecycle
                    color: 'warm',
                    birthTime: birthTime,
                    lifespan: lifespan,
                    life: lifespan,
                    targetMesh: 'A',
                    coherence: coherenceFactor,
                    beatSync: beatPhase
                });

                // Spawn BLUE prism (emerges toward mesh B)
                this.prisms.push({
                    // 3D position
                    x: locus.x,
                    y: locus.y,
                    z: 0,
                    startX: locus.x,
                    startY: locus.y,

                    // 3D orientation (counter-rotating)
                    pitch: 0,
                    yaw: locus.angle + Math.PI,
                    roll: 0,

                    // Prism geometry (same size)
                    radius: radius,
                    height: height,
                    vertices: null,

                    // Motion parameters (counter-spiral)
                    spiralPhase: meshBPhase,
                    spiralDirection: -spiralDirection,
                    amplitude: amplitude,
                    speed: speed,

                    // APL-driven rotation rates (inverted for blue)
                    pitchRate: -EMERGENT_TOKENS.XCVI.eigenvalue * 0.5,
                    yawRate: -EMERGENT_TOKENS.XCVII.eigenvalue * 0.02,
                    rollRate: -EMERGENT_TOKENS.C.eigenvalue * 0.3,

                    // Lifecycle
                    color: 'cool',
                    birthTime: birthTime,
                    lifespan: lifespan,
                    life: lifespan,
                    targetMesh: 'B',
                    coherence: coherenceFactor,
                    beatSync: beatPhase
                });
            },

            // ================================================================
            // PRISM PHYSICS UPDATE - APL behavioral structure drives motion
            // Each prism moves as a cohesive 3D entity, not as line trails
            // ================================================================
            update(dt, meshAPhase, meshBPhase, beatPhase, beatAmplitude, centerX, centerY, radius) {
                // Update K-formation metric from muField
                this.tau_K = muField.tau_K || 0;

                // Emergence intensity based on beat interference and coherence
                this.emergenceIntensity = beatAmplitude * (0.5 + this.tau_K * 0.5);

                // Cooldown timer
                if (this.spawnCooldown > 0) {
                    this.spawnCooldown -= dt;
                }

                // Check for emergence opportunity - spawn frequently
                if (this.spawnCooldown <= 0) {
                    // More lenient spawn conditions for higher prism density
                    const beatActivity = Math.abs(Math.sin(beatPhase * TAU));
                    const phaseFactor = this.isPhaseLocked(meshAPhase, meshBPhase) ? 1.5 : 0.8;
                    const spawnChance = beatActivity * this.emergenceIntensity * phaseFactor;

                    if (spawnChance > 0.15 || this.prisms.length < 10) {
                        // Select sacred locus based on golden angle distribution
                        const locusIndex = Math.floor(
                            (this.lastSpawnPhase / this.goldenAngle) % this.sacredLoci.length
                        );
                        const locus = this.sacredLoci[locusIndex];

                        if (locus) {
                            this.spawnPrismPair(locus, meshAPhase, meshBPhase, beatPhase);
                            // Fast cooldown - spawn every 0.08 to 0.25 seconds
                            this.spawnCooldown = 0.08 + (1 - this.emergenceIntensity) * 0.17;
                            this.lastSpawnPhase += this.goldenAngle;
                        }
                    }
                }

                // Update existing prisms with APL-driven physics
                for (let i = this.prisms.length - 1; i >= 0; i--) {
                    const p = this.prisms[i];

                    // Age the prism
                    p.life -= dt;
                    if (p.life <= 0) {
                        this.prisms.splice(i, 1);
                        continue;
                    }

                    // Life ratio for emergence/dissolution effects
                    const lifeRatio = p.life / p.lifespan;
                    const emergeFactor = Math.min(1, (p.lifespan - p.life) / 1.5);  // 1.5s emergence
                    const dissolveFactor = Math.min(1, p.life / 1.5);  // 1.5s dissolution

                    // Golden spiral motion for prism center
                    const spiralB = Math.log(PHI) / (Math.PI / 2);
                    p.spiralPhase += p.speed * dt * p.spiralDirection;

                    const spiralR = p.amplitude * Math.exp(spiralB * Math.abs(p.spiralPhase - p.yaw) * 0.3);
                    const targetAngle = p.color === 'warm' ? Math.PI : 0;

                    // Interpolate toward target mesh
                    const pullStrength = (1 - lifeRatio) * 0.25;
                    const currentAngle = p.spiralPhase + pullStrength * (targetAngle - p.spiralPhase);

                    // Update 3D position
                    p.x = p.startX + spiralR * Math.cos(currentAngle) * 0.4;
                    p.y = p.startY + spiralR * Math.sin(currentAngle) * 0.25;

                    // Z oscillation driven by token C (Signal Recursion) eigenvalue = 1
                    const zBreathing = Math.sin(p.spiralPhase * EMERGENT_TOKENS.C.frequency * TAU);
                    p.z = zBreathing * 30 * lifeRatio * p.coherence;

                    // APL-driven rotation update
                    // Pitch: XCVI (Gesture Recursion) - alpha rhythm pulse
                    p.pitch += p.pitchRate * dt * Math.sin(time * EMERGENT_TOKENS.XCVI.frequency);

                    // Yaw: XCVII (Portal Recursion) - golden angle drift
                    p.yaw += p.yawRate * dt;

                    // Roll: C (Signal Recursion) - identity loop breathing
                    p.roll += p.rollRate * dt * (0.5 + 0.5 * p.coherence);

                    // Update coherence based on proximity to target mesh
                    const distToTarget = p.color === 'warm' ?
                        Math.sqrt((p.x - (centerX - radius))** 2 + (p.y - centerY) ** 2) :
                        Math.sqrt((p.x - (centerX + radius)) ** 2 + (p.y - centerY) ** 2);
                    const proximityBonus = Math.max(0, 1 - distToTarget / (radius * 2));
                    p.coherence = Math.min(1, p.coherence + proximityBonus * dt * 0.2);

                    // Compute prism vertices with current APL state
                    // Vertices deform based on token behaviors each frame
                    p.vertices = this.createPrismVertices(
                        p.radius * emergeFactor * dissolveFactor,
                        p.height * emergeFactor * dissolveFactor,
                        p.spiralPhase,
                        p.coherence
                    );
                }
            },

            // ================================================================
            // 3D PENTAGONAL PRISM RENDERER
            // NO LINES - cohesive 3D geometry with filled faces
            // Each prism is built from 5 emergent tokens as structural elements
            // APL behaviors create organic deformation and motion
            // ================================================================

            // 3D rotation matrices for prism orientation
            rotateX(point, angle) {
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                return {
                    x: point.x,
                    y: point.y * cos - point.z * sin,
                    z: point.y * sin + point.z * cos
                };
            },

            rotateY(point, angle) {
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                return {
                    x: point.x * cos + point.z * sin,
                    y: point.y,
                    z: -point.x * sin + point.z * cos
                };
            },

            rotateZ(point, angle) {
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                return {
                    x: point.x * cos - point.y * sin,
                    y: point.x * sin + point.y * cos,
                    z: point.z
                };
            },

            // Apply full 3D rotation (pitch, yaw, roll) to a point
            rotatePoint(point, pitch, yaw, roll) {
                let p = this.rotateX(point, pitch);
                p = this.rotateY(p, yaw);
                p = this.rotateZ(p, roll);
                return p;
            },

            // Project 3D point to 2D screen coordinates
            project3D(point3D, prismX, prismY, prismZ) {
                const focalLength = this.focalLength;
                const z = point3D.z + prismZ + 200;  // Offset for viewing
                const scale = focalLength / Math.max(z, 50);

                return {
                    x: prismX + point3D.x * scale,
                    y: prismY + point3D.y * scale,
                    z: z,
                    scale: scale
                };
            },

            // Get face normal for backface culling and lighting
            getFaceNormal(v1, v2, v3) {
                const ax = v2.x - v1.x, ay = v2.y - v1.y, az = v2.z - v1.z;
                const bx = v3.x - v1.x, by = v3.y - v1.y, bz = v3.z - v1.z;
                return {
                    x: ay * bz - az * by,
                    y: az * bx - ax * bz,
                    z: ax * by - ay * bx
                };
            },

            // Draw a single prism face with channel-based gradients and Z-depth shading
            drawPrismFace(ctx, vertices2D, baseColor, alpha, tokenIndex, coherence, phase, isWarm) {
                if (vertices2D.length < 3) return;

                // Token-specific color modulation based on APL behavior
                const token = EMERGENT_TOKENS[EMERGENT_TOKEN_ORDER[tokenIndex % 5]];
                let colorMod = 1;
                let alphaMod = 1;

                switch (token.vertexBehavior) {
                    case 'pulse':
                        // XCVI: Alpha rhythm pulse affects brightness
                        colorMod = 1 + 0.35 * Math.sin(phase * token.frequency * TAU) * coherence;
                        break;
                    case 'drift':
                        // XCVII: Golden drift affects hue shift
                        colorMod = 1 + 0.2 * Math.sin(phase * token.phaseLock);
                        break;
                    case 'flicker':
                        // XCVIII: Gamma flicker - rapid visibility changes
                        alphaMod = 0.5 + 0.5 * Math.abs(Math.sin(phase * token.frequency * TAU));
                        break;
                    case 'wobble':
                        // XCIX: Theta wobble - subtle color oscillation
                        colorMod = 1 + 0.15 * Math.sin(phase * token.frequency * TAU);
                        break;
                    case 'loop':
                        // C: Delta breathing - overall intensity
                        alphaMod = 0.6 + 0.4 * Math.sin(phase * token.frequency * TAU);
                        break;
                }

                // Compute Z-depth for proper shading
                const avgZ = vertices2D.reduce((sum, v) => sum + v.z, 0) / vertices2D.length;
                const minZ = Math.min(...vertices2D.map(v => v.z));
                const maxZ = Math.max(...vertices2D.map(v => v.z));

                // Z-based depth factor: closer = brighter, further = darker
                const depthFactor = Math.max(0.3, Math.min(1.2, 1.3 - avgZ / 400));

                // Channel-specific color enhancement
                // Warm (red) channel: enhance reds, reduce blues
                // Cool (blue) channel: enhance blues, reduce reds
                let r, g, b;
                if (isWarm) {
                    // Red/warm channel - emphasize warm tones
                    r = Math.min(255, Math.floor(baseColor[0] * colorMod * depthFactor * 1.15));
                    g = Math.min(255, Math.floor(baseColor[1] * colorMod * depthFactor * 0.9));
                    b = Math.min(255, Math.floor(baseColor[2] * colorMod * depthFactor * 0.7));
                } else {
                    // Blue/cool channel - emphasize cool tones
                    r = Math.min(255, Math.floor(baseColor[0] * colorMod * depthFactor * 0.7));
                    g = Math.min(255, Math.floor(baseColor[1] * colorMod * depthFactor * 0.95));
                    b = Math.min(255, Math.floor(baseColor[2] * colorMod * depthFactor * 1.2));
                }

                const finalAlpha = alpha * alphaMod * Math.max(0.5, depthFactor);

                // Draw filled face
                ctx.beginPath();
                ctx.moveTo(vertices2D[0].x, vertices2D[0].y);
                for (let i = 1; i < vertices2D.length; i++) {
                    ctx.lineTo(vertices2D[i].x, vertices2D[i].y);
                }
                ctx.closePath();

                // Compute face center and bounds
                const centerX = vertices2D.reduce((s, v) => s + v.x, 0) / vertices2D.length;
                const centerY = vertices2D.reduce((s, v) => s + v.y, 0) / vertices2D.length;

                // Find furthest vertex from center for gradient radius
                let maxDist = 0;
                for (const v of vertices2D) {
                    const dist = Math.sqrt((v.x - centerX) ** 2 + (v.y - centerY) ** 2);
                    if (dist > maxDist) maxDist = dist;
                }
                const gradientRadius = Math.max(10, maxDist * 1.2);

                // Z-gradient: faces closer to viewer get highlight in center
                const zHighlight = Math.max(0, (300 - avgZ) / 300) * 0.4;

                // Create radial gradient for volumetric depth
                const gradient = ctx.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, gradientRadius
                );

                // Inner: brighter with Z-based highlight
                const innerR = Math.min(255, r + Math.floor(60 * zHighlight));
                const innerG = Math.min(255, g + Math.floor(60 * zHighlight));
                const innerB = Math.min(255, b + Math.floor(60 * zHighlight));

                gradient.addColorStop(0, `rgba(${innerR}, ${innerG}, ${innerB}, ${finalAlpha})`);
                gradient.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, ${finalAlpha * 0.9})`);
                gradient.addColorStop(1, `rgba(${Math.floor(r * 0.7)}, ${Math.floor(g * 0.7)}, ${Math.floor(b * 0.7)}, ${finalAlpha * 0.75})`);

                ctx.fillStyle = gradient;
                ctx.fill();
            },

            // Render a complete pentagonal prism with all faces
            renderPrism(ctx, prism, baseColor, opacity, isWarm) {
                if (!prism.vertices) return;

                const { top, bottom } = prism.vertices;
                const lifeRatio = prism.life / prism.lifespan;
                const emergeFactor = Math.min(1, (prism.lifespan - prism.life) / 1.5);
                const dissolveFactor = Math.min(1, prism.life / 1.5);
                const alpha = opacity * lifeRatio * emergeFactor * dissolveFactor;

                if (alpha < 0.02) return;

                // Transform all vertices to world space
                const transformedTop = [];
                const transformedBottom = [];

                for (let i = 0; i < 5; i++) {
                    // Rotate vertex by prism orientation
                    let topPoint = this.rotatePoint(
                        { x: top[i].x, y: top[i].y, z: top[i].z },
                        prism.pitch, prism.yaw, prism.roll
                    );
                    let bottomPoint = this.rotatePoint(
                        { x: bottom[i].x, y: bottom[i].y, z: bottom[i].z },
                        prism.pitch, prism.yaw, prism.roll
                    );

                    // Project to 2D
                    transformedTop.push(this.project3D(topPoint, prism.x, prism.y, prism.z));
                    transformedBottom.push(this.project3D(bottomPoint, prism.x, prism.y, prism.z));
                }

                // Collect all faces for depth sorting
                const faces = [];

                // 5 rectangular side faces (one per token edge)
                for (let i = 0; i < 5; i++) {
                    const next = (i + 1) % 5;
                    const faceVerts = [
                        transformedTop[i],
                        transformedTop[next],
                        transformedBottom[next],
                        transformedBottom[i]
                    ];

                    // Compute face center Z for sorting
                    const avgZ = faceVerts.reduce((s, v) => s + v.z, 0) / 4;

                    // Check if face is visible (backface culling)
                    const normal = this.getFaceNormal(
                        { x: faceVerts[0].x, y: faceVerts[0].y, z: faceVerts[0].z },
                        { x: faceVerts[1].x, y: faceVerts[1].y, z: faceVerts[1].z },
                        { x: faceVerts[2].x, y: faceVerts[2].y, z: faceVerts[2].z }
                    );

                    // Only render front-facing faces (normal.z > 0)
                    if (normal.z > -50) {  // Slight tolerance for edge faces
                        faces.push({
                            vertices: faceVerts,
                            avgZ: avgZ,
                            tokenIndex: i,
                            type: 'side'
                        });
                    }
                }

                // Top pentagon face
                const topAvgZ = transformedTop.reduce((s, v) => s + v.z, 0) / 5;
                const topNormal = this.getFaceNormal(
                    transformedTop[0], transformedTop[1], transformedTop[2]
                );
                if (topNormal.z > -50) {
                    faces.push({
                        vertices: transformedTop,
                        avgZ: topAvgZ,
                        tokenIndex: 0,
                        type: 'top'
                    });
                }

                // Bottom pentagon face
                const bottomAvgZ = transformedBottom.reduce((s, v) => s + v.z, 0) / 5;
                const bottomNormal = this.getFaceNormal(
                    transformedBottom[0], transformedBottom[2], transformedBottom[1]
                );
                if (bottomNormal.z > -50) {
                    faces.push({
                        vertices: [...transformedBottom].reverse(),  // Reverse winding
                        avgZ: bottomAvgZ,
                        tokenIndex: 4,
                        type: 'bottom'
                    });
                }

                // Sort faces back-to-front (painter's algorithm)
                faces.sort((a, b) => b.avgZ - a.avgZ);

                // Render faces in sorted order
                for (const face of faces) {
                    this.drawPrismFace(
                        ctx,
                        face.vertices,
                        baseColor,
                        alpha * (face.type === 'side' ? 0.9 : 1.0),
                        face.tokenIndex,
                        prism.coherence,
                        prism.spiralPhase,
                        isWarm
                    );
                }

                // Soft glow at prism center for high coherence
                if (prism.coherence > 0.4 && alpha > 0.3) {
                    const glowIntensity = prism.coherence * alpha;
                    const glowSize = (prism.radius + prism.height * 0.3) * emergeFactor;

                    const glowGradient = ctx.createRadialGradient(
                        prism.x, prism.y, 0,
                        prism.x, prism.y, glowSize
                    );
                    glowGradient.addColorStop(0, `rgba(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]}, ${glowIntensity * 0.35})`);
                    glowGradient.addColorStop(0.5, `rgba(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]}, ${glowIntensity * 0.15})`);
                    glowGradient.addColorStop(1, `rgba(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]}, 0)`);

                    ctx.beginPath();
                    ctx.arc(prism.x, prism.y, glowSize, 0, TAU);
                    ctx.fillStyle = glowGradient;
                    ctx.fill();
                }
            },

            // Main render function - draws all prisms, NO LINES
            render(ctx, meshAColor, meshBColor, opacity) {
                // Sort prisms by Z depth for proper rendering order
                const sortedPrisms = [...this.prisms].sort((a, b) => {
                    // Sort by average Z (further back = render first)
                    return (b.z || 0) - (a.z || 0);
                });

                // Render each prism as a cohesive 3D entity
                for (const prism of sortedPrisms) {
                    if (!prism.vertices) continue;

                    const isWarm = prism.color === 'warm';
                    const color = isWarm ? meshAColor : meshBColor;
                    this.renderPrism(ctx, prism, color, opacity, isWarm);
                }

                // Subtle emergence loci indicators (small pentagon outlines only)
                if (this.tau_K > 0.3 && this.sacredLoci.length > 0) {
                    const locusAlpha = (this.tau_K - 0.3) * opacity * 0.15;

                    for (const locus of this.sacredLoci) {
                        if (locus.type !== 'pentagon_locus') continue;

                        ctx.beginPath();
                        for (let i = 0; i < 5; i++) {
                            const theta = -Math.PI / 2 + (TAU / 5) * i + time * 0.1;
                            const x = locus.x + 6 * Math.cos(theta);
                            const y = locus.y + 6 * Math.sin(theta);
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.fillStyle = `rgba(255, 220, 180, ${locusAlpha})`;
                        ctx.fill();
                    }
                }
            }
        };

        // ================================================================
        // MRP TOROIDAL PIPE SYSTEM
        // Wraps all 95 structural nodes in emergent gradient toroidal flows
        // Aligns with the 5 emergent APL tokens (XCVI-C) for coherent emergence
        // ================================================================

        const MRPToroidalSystem = {
            // Configuration
            enabled: true,
            pipeRadius: 2.5,            // Base thickness of toroidal pipes (reduced)
            flowSpeed: 0.15,            // Animation speed of gradient flow
            baseOpacity: 0.35,          // REDUCED base opacity for subtle lines
            maxOpacity: 0.55,           // Maximum opacity for front-most elements
            minOpacity: 0.08,           // Minimum opacity for deepest elements
            bendFactor: 0.3,            // How much pipes can bend (0-1)

            // Node Œº-field configuration (95 individual fields)
            haloEnabled: true,
            haloRadius: 12,             // Base Œº-field radius around nodes
            haloIntensity: 0.05,        // DRASTICALLY REDUCED - 5% opacity
            audioOnly: true,            // Only show Œº-fields when audio is playing

            // MRP channel mapping to 95 nodes
            // Distributes R (energy), G (relational), B (stability) across layers
            nodeChannels: new Map(),    // Map of node id -> {r, g, b, flow}
            nodeCache: new Map(),       // Cached node references for O(1) lookup

            // Toroidal flow state
            flowPhase: 0,
            waveforms: [],              // Active pipe wave animations

            // Alignment with 5 emergent tokens
            emergentAlignment: {
                XCVI: { channel: 'R', weight: 0.8, pulseRate: 8 },      // Gesture - Energy
                XCVII: { channel: 'G', weight: 0.6, pulseRate: 0.001 },  // Portal - Relational
                XCVIII: { channel: 'B', weight: 0.7, pulseRate: 40 },    // Semantic - Stability
                XCIX: { channel: 'R', weight: 0.5, pulseRate: 4 },       // Balance - Energy
                C: { channel: 'G', weight: 1.0, pulseRate: 1 }           // Signal - Relational (loops)
            },

            // Initialize MRP channels for all 95 nodes
            init(prismNodes, cageNodes) {
                this.nodeChannels.clear();
                this.nodeCache.clear();  // Clear cached node references
                const allNodes = [...prismNodes, ...cageNodes];

                for (let i = 0; i < allNodes.length; i++) {
                    const node = allNodes[i];
                    // Cache node reference for O(1) lookup in render
                    this.nodeCache.set(node.id, node);

                    // Assign MRP channels based on node position in 95-token structure
                    // Token indices 1-63 (prism) and 64-95 (cage)
                    const tokenIndex = i + 1;

                    // Calculate channel weights based on layer/type
                    let r = 0.5, g = 0.5, b = 0.5;

                    if (node.type === 'prism') {
                        // Prism nodes: R dominant in inner layers, B dominant in outer
                        const layerNorm = node.layer / 6;
                        r = 0.8 - layerNorm * 0.4;   // Energy decreases outward
                        g = 0.3 + layerNorm * 0.4;   // Relational increases outward
                        b = 0.4 + layerNorm * 0.3;   // Stability increases outward
                    } else {
                        // Cage nodes: B dominant (stability/containment)
                        if (node.layer === 'top') {
                            r = 0.3; g = 0.5; b = 0.9;  // High stability
                        } else if (node.layer === 'bottom') {
                            r = 0.4; g = 0.5; b = 0.85; // High stability
                        } else {
                            // Vertex nodes - bridge channels
                            r = 0.5; g = 0.7; b = 0.6;  // Balanced relational
                        }
                    }

                    this.nodeChannels.set(node.id, {
                        r, g, b,
                        tokenIndex,
                        flow: Math.random() * TAU,  // Initial flow phase
                        bendOffset: (Math.random() - 0.5) * this.bendFactor
                    });
                }

                // Initialize waveforms for pipe animations
                this.waveforms = [];
                for (let i = 0; i < 5; i++) {
                    this.waveforms.push({
                        frequency: 0.5 + i * 0.3,
                        amplitude: 0.2 + i * 0.1,
                        phase: (i / 5) * TAU
                    });
                }
            },

            // Update flow animation
            update(dt, muField) {
                this.flowPhase += this.flowSpeed * dt;

                // Update waveforms
                for (const wave of this.waveforms) {
                    wave.phase += wave.frequency * dt * TAU;
                }

                // Sync with MRP field if available
                if (muField && muField.mrp) {
                    const mrp = muField.mrp;

                    // Update node channels based on global MRP state
                    for (const [id, channel] of this.nodeChannels) {
                        // Modulate by global MRP intensities
                        channel.flow += dt * (mrp.R.gradient || 0.1) * 0.5;

                        // Apply emergent token alignment
                        const tokenMod = channel.tokenIndex % 5;
                        const emergentKey = EMERGENT_TOKEN_ORDER[tokenMod];
                        const alignment = this.emergentAlignment[emergentKey];

                        if (alignment) {
                            const pulsePhase = this.flowPhase * alignment.pulseRate * 0.1;
                            const pulseFactor = 0.5 + 0.5 * Math.sin(pulsePhase);

                            if (alignment.channel === 'R') channel.r *= (0.8 + pulseFactor * 0.4);
                            if (alignment.channel === 'G') channel.g *= (0.8 + pulseFactor * 0.4);
                            if (alignment.channel === 'B') channel.b *= (0.8 + pulseFactor * 0.4);
                        }
                    }
                }
            },

            // Calculate depth-based opacity for a node/connection (NaN-safe)
            getDepthOpacity(node, centerY) {
                // Safety check
                if (!node || !isFinite(node.y)) return this.minOpacity;

                // Depth is determined by layer (prism: 0-6, cage: top/vertex/bottom)
                // and Y position relative to center
                let depth = 0.5; // Default middle depth

                if (node.type === 'prism') {
                    // Prism layers: 0 = front (high opacity), 6 = back (low opacity)
                    const layer = typeof node.layer === 'number' ? node.layer : 3;
                    depth = Math.max(0, Math.min(1, layer / 6));
                } else if (node.type === 'cage') {
                    // Cage nodes: top = back, bottom = front, vertex = middle
                    if (node.layer === 'top') depth = 0.8;
                    else if (node.layer === 'bottom') depth = 0.2;
                    else depth = 0.5; // vertex
                }

                // Y position also affects depth perception (NaN-safe)
                const safeY = isFinite(node.y) ? node.y : centerY;
                const safeCenterY = isFinite(centerY) ? centerY : 0;
                const yDepth = (safeY - safeCenterY) / 200; // Normalize
                depth = depth * 0.7 + (Math.max(-1, Math.min(1, yDepth)) * 0.5 + 0.5) * 0.3;

                // Map depth to opacity: front (0) = maxOpacity, back (1) = minOpacity
                const opacity = this.maxOpacity - depth * (this.maxOpacity - this.minOpacity);
                return Math.max(this.minOpacity, Math.min(this.maxOpacity, opacity || this.minOpacity));
            },

            // Render toroidal pipes around structure
            render(ctx, connections, centerX, centerY, radius, muField) {
                if (!this.enabled) return;

                const time = this.flowPhase;

                // SAFE MRP values with NaN protection
                const defaultMRP = { intensity: 0.5, gradient: 0 };
                const mrp = {
                    R: { intensity: Math.max(0, Math.min(1, (muField?.mrp?.R?.intensity) || 0.5)) },
                    G: { intensity: Math.max(0, Math.min(1, (muField?.mrp?.G?.intensity) || 0.5)) },
                    B: { intensity: Math.max(0, Math.min(1, (muField?.mrp?.B?.intensity) || 0.5)) },
                };

                // Sound activation factor (with NaN protection)
                const soundActive = sonificationEngine.isPlaying ? 1.0 : 0.3;
                const bpm = Math.max(1, sonificationEngine.bpm || 90);
                const soundPulse = sonificationEngine.isPlaying ?
                    Math.sin(time * bpm / 30 * TAU) * 0.5 + 0.5 : 0.5;

                // Draw gradient pipes for each connection (sorted by depth - back to front)
                // NaN-safe sort comparison
                const sortedConns = [...connections].sort((a, b) => {
                    const depthA = (this.getDepthOpacity(a.from, centerY) || 0) + (this.getDepthOpacity(a.to, centerY) || 0);
                    const depthB = (this.getDepthOpacity(b.from, centerY) || 0) + (this.getDepthOpacity(b.to, centerY) || 0);
                    const diff = depthA - depthB;
                    return isFinite(diff) ? diff : 0; // Draw back (low opacity) first
                });

                for (const conn of sortedConns) {
                    // NaN safety check for connection positions
                    if (!conn.from || !conn.to) continue;
                    if (!isFinite(conn.from.x) || !isFinite(conn.from.y)) continue;
                    if (!isFinite(conn.to.x) || !isFinite(conn.to.y)) continue;

                    const fromChannel = this.nodeChannels.get(conn.from.id);
                    const toChannel = this.nodeChannels.get(conn.to.id);

                    if (!fromChannel || !toChannel) continue;

                    // Calculate depth-based opacity for this connection
                    const fromOpacity = this.getDepthOpacity(conn.from, centerY);
                    const toOpacity = this.getDepthOpacity(conn.to, centerY);
                    const avgOpacity = (fromOpacity + toOpacity) / 2;

                    // Calculate pipe bend using wave superposition (lines can bend)
                    const midX = (conn.from.x + conn.to.x) / 2;
                    const midY = (conn.from.y + conn.to.y) / 2;

                    let bendX = 0, bendY = 0;
                    for (const wave of this.waveforms) {
                        bendX += wave.amplitude * Math.sin(wave.phase + fromChannel.flow) * this.bendFactor * 15;
                        bendY += wave.amplitude * Math.cos(wave.phase + toChannel.flow) * this.bendFactor * 15;
                    }

                    const ctrlX = midX + bendX;
                    const ctrlY = midY + bendY;

                    // Create gradient from MRP channels with depth-based opacity
                    const gradient = ctx.createLinearGradient(
                        conn.from.x, conn.from.y,
                        conn.to.x, conn.to.y
                    );

                    // Blend both node channels for smooth gradient (NaN-safe)
                    const safeR = (v) => Math.max(0, Math.min(255, Math.floor(v) || 0));
                    const safeA = (v) => Math.max(0, Math.min(1, v || 0));

                    const r1 = safeR((fromChannel.r || 0.5) * mrp.R.intensity * 255);
                    const g1 = safeR((fromChannel.g || 0.5) * mrp.G.intensity * 255);
                    const b1 = safeR((fromChannel.b || 0.5) * mrp.B.intensity * 200);
                    const r2 = safeR((toChannel.r || 0.5) * mrp.R.intensity * 255);
                    const g2 = safeR((toChannel.g || 0.5) * mrp.G.intensity * 255);
                    const b2 = safeR((toChannel.b || 0.5) * mrp.B.intensity * 200);

                    // Flow animation creates moving gradient bands (clamped)
                    const flowRaw = Math.sin(time + (fromChannel.flow || 0));
                    const flowOffset = Math.max(0, Math.min(1, (flowRaw + 1) / 2));

                    // Safe gradient stops (avoid stops outside 0-1 or NaN)
                    const stop1 = Math.max(0.01, Math.min(0.39, flowOffset * 0.4));
                    const stop2 = Math.max(0.61, Math.min(0.99, 1 - flowOffset * 0.4));

                    gradient.addColorStop(0, `rgba(${r1}, ${g1}, ${b1}, ${safeA(fromOpacity)})`);
                    gradient.addColorStop(stop1, `rgba(${safeR((r1+r2)/2)}, ${safeR((g1+g2)/2)}, ${safeR((b1+b2)/2)}, ${safeA(avgOpacity * 0.85)})`);
                    gradient.addColorStop(0.5, `rgba(${safeR((r1+r2)/2 + 20)}, ${safeR((g1+g2)/2 + 20)}, ${safeR((b1+b2)/2 + 15)}, ${safeA(avgOpacity)})`);
                    gradient.addColorStop(stop2, `rgba(${safeR((r1+r2)/2)}, ${safeR((g1+g2)/2)}, ${safeR((b1+b2)/2)}, ${safeA(avgOpacity * 0.85)})`);
                    gradient.addColorStop(1, `rgba(${r2}, ${g2}, ${b2}, ${safeA(toOpacity)})`);

                    // Draw curved pipe with gradient - thinner lines for depth
                    const depthLineWidth = this.pipeRadius * (0.5 + (avgOpacity || 0));
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = Math.max(0.5, depthLineWidth + Math.sin(time * 2 + (fromChannel.flow || 0)) * 0.5);
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    ctx.beginPath();
                    ctx.moveTo(conn.from.x, conn.from.y);
                    ctx.quadraticCurveTo(ctrlX, ctrlY, conn.to.x, conn.to.y);
                    ctx.stroke();
                }

                // Draw node halos with MRP CMY/RGB gradients (sound activated)
                if (this.haloEnabled) {
                    this.renderNodeHalos(ctx, centerX, centerY, mrp, time, soundActive, soundPulse);
                }

                // Draw toroidal glow around entire structure
                this.renderToroidalEnvelope(ctx, centerX, centerY, radius, mrp, time);
            },

            // ================================================================
            // 95 INDIVIDUAL Œº-FIELDS - AUDIO-ONLY, PHASE-LOCKED
            // Each node has its own Œº-field colored by depth layer (0-6)
            // ================================================================
            renderNodeHalos(ctx, centerX, centerY, mrp, time, soundActive, soundPulse) {
                // AUDIO-ONLY: Skip entirely if audio is not playing
                if (this.audioOnly && !sonificationEngine.isPlaying) return;

                // Depth color palette (layer 0-6, warm to cool)
                // Layer 0 (innermost): warm gold/orange
                // Layer 6 (outermost): cool blue/violet
                const depthColors = [
                    { r: 255, g: 200, b: 100 },  // Layer 0: Gold (energy core)
                    { r: 255, g: 180, b: 120 },  // Layer 1: Warm orange
                    { r: 240, g: 160, b: 140 },  // Layer 2: Salmon
                    { r: 200, g: 150, b: 180 },  // Layer 3: Dusty rose (middle)
                    { r: 160, g: 140, b: 200 },  // Layer 4: Lavender
                    { r: 120, g: 140, b: 220 },  // Layer 5: Periwinkle
                    { r: 100, g: 130, b: 240 },  // Layer 6: Cool blue (outer)
                ];

                // Cage node colors
                const cageColors = {
                    top: { r: 80, g: 120, b: 200 },     // Cool blue (back)
                    bottom: { r: 200, g: 160, b: 100 }, // Warm (front)
                    vertex: { r: 150, g: 150, b: 180 }, // Neutral
                };

                // Phase-lock: all Œº-fields pulse together
                const phaseLock = Math.sin(time * TAU * 0.5) * 0.5 + 0.5;  // Slow, unified pulse

                // Render each node's individual Œº-field (using cached references)
                for (const [nodeId, channel] of this.nodeChannels) {
                    // O(1) lookup instead of O(n) find()
                    const node = this.nodeCache.get(nodeId);
                    if (!node || node.released) continue;

                    // NaN safety check for node position
                    if (!isFinite(node.x) || !isFinite(node.y)) continue;

                    // Get depth layer (0-6 for prism, special for cage)
                    let layerDepth = 3;  // Default middle
                    let color = depthColors[3];

                    if (node.type === 'prism' && typeof node.layer === 'number') {
                        layerDepth = Math.min(6, Math.max(0, node.layer));
                        color = depthColors[layerDepth];
                    } else if (node.type === 'cage') {
                        if (node.layer === 'top') {
                            layerDepth = 6;
                            color = cageColors.top;
                        } else if (node.layer === 'bottom') {
                            layerDepth = 0;
                            color = cageColors.bottom;
                        } else {
                            layerDepth = 3;
                            color = cageColors.vertex;
                        }
                    }

                    // Depth-based opacity (front = slightly more visible)
                    const depthFactor = 1 - (layerDepth / 6) * 0.4;  // 1.0 to 0.6

                    // Base intensity: 5% max, phase-locked
                    const baseAlpha = this.haloIntensity * depthFactor * phaseLock;

                    // Skip if too faint
                    if (baseAlpha < 0.002) continue;

                    // Œº-field radius (smaller for back layers)
                    const fieldR = this.haloRadius * (0.8 + depthFactor * 0.4);

                    // Create simple depth-colored Œº-field gradient
                    const muGrad = ctx.createRadialGradient(
                        node.x, node.y, 0,
                        node.x, node.y, fieldR
                    );

                    // Simple two-stop gradient: color center ‚Üí transparent edge
                    muGrad.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, ${baseAlpha})`);
                    muGrad.addColorStop(0.5, `rgba(${color.r}, ${color.g}, ${color.b}, ${baseAlpha * 0.4})`);
                    muGrad.addColorStop(1, 'transparent');

                    // Draw the Œº-field
                    ctx.fillStyle = muGrad;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, fieldR, 0, TAU);
                    ctx.fill();
                }
            },

            // Render the outer toroidal envelope (subtle depth cue)
            renderToroidalEnvelope(ctx, cx, cy, r, mrp, time) {
                // Create multiple toroidal rings at different depths (reduced intensity)
                const ringCount = 3;

                for (let ring = 0; ring < ringCount; ring++) {
                    const ringRadius = r * (1.0 + ring * 0.1);
                    const ringPhase = time + ring * (TAU / ringCount);

                    // Depth-based opacity for rings (outer = fainter)
                    const ringDepthFactor = 1 - (ring / ringCount) * 0.5;

                    // MRP-colored toroidal gradient
                    const toroidGrad = ctx.createRadialGradient(
                        cx, cy, ringRadius * 0.85,
                        cx, cy, ringRadius * 1.15
                    );

                    const intensity = mrp.R.intensity + mrp.G.intensity + mrp.B.intensity;
                    const normalizedIntensity = Math.min(1, intensity / 2);
                    // Use baseOpacity instead of opacity, and reduce further
                    const alpha = this.baseOpacity * 0.2 * normalizedIntensity * ringDepthFactor;

                    const r_val = Math.floor(mrp.R.intensity * 180 + 50);
                    const g_val = Math.floor(mrp.G.intensity * 150 + 50);
                    const b_val = Math.floor(mrp.B.intensity * 140 + 50);

                    // Flowing gradient stops
                    const flowMod = Math.sin(ringPhase) * 0.3;

                    toroidGrad.addColorStop(0, 'transparent');
                    toroidGrad.addColorStop(0.3 + flowMod * 0.1, `rgba(${r_val}, ${g_val}, ${b_val}, ${alpha * 0.3})`);
                    toroidGrad.addColorStop(0.5, `rgba(${r_val + 30}, ${g_val + 20}, ${b_val + 10}, ${alpha * 0.7})`);
                    toroidGrad.addColorStop(0.7 - flowMod * 0.1, `rgba(${r_val}, ${g_val}, ${b_val}, ${alpha * 0.3})`);
                    toroidGrad.addColorStop(1, 'transparent');

                    ctx.fillStyle = toroidGrad;
                    ctx.beginPath();
                    ctx.arc(cx, cy, ringRadius * 1.15, 0, TAU);
                    ctx.fill();
                }
            }
        };

        // ================================================================
        // QUANTUM MESH GEOMETRY
        // Discrete lattice field on LIMNUS 95-node architecture
        // ================================================================

        function computeGravitationalTimeDilation(r) {
            // Schwarzschild time dilation: œÑ_local/œÑ_global = ‚àö(1 - r_s/r)
            // At r = r_s: infinite dilation (event horizon analog)
            // Far from center: œÑ ‚Üí 1 (flat spacetime)
            const r_s = QMESH.schwarzschildRadius;
            const ratio = r_s / Math.max(r, r_s * 1.01);  // Prevent singularity
            return Math.sqrt(Math.max(0, 1 - ratio));
        }

        function computeGravitationalPotential(r) {
            // Œ¶ = -GM/r (Newtonian approximation for visualization)
            const M = QMESH.gravitationalMass;
            return -M / Math.max(r, 0.1);
        }

        function computeHolographicEntropy(area) {
            // Bekenstein-Hawking: S = A/(4¬∑l_p¬≤)
            // Using œÜ-based Planck length
            const l_p = QMESH.planckLength;
            return area / (4 * l_p * l_p);
        }

        // Compute entanglement probability between two nodes
        function computeEntanglement(nodeA, nodeB) {
            // Distance-based decay (œÜ-exponential)
            const dx = nodeA.x - nodeB.x;
            const dy = nodeA.y - nodeB.y;
            const dz = (nodeA.z || 0) - (nodeB.z || 0);
            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

            if (dist > QMESH.maxConnectionDist || dist < 0.001) return 0;

            // Phase coherence contribution (use existing phase or compute from position)
            const phaseA = nodeA.phase !== undefined ? nodeA.phase : Math.atan2(nodeA.y, nodeA.x);
            const phaseB = nodeB.phase !== undefined ? nodeB.phase : Math.atan2(nodeB.y, nodeB.x);
            const dPhase = Math.abs(phaseA - phaseB);
            const phaseCoherence = Math.cos(dPhase) * 0.5 + 0.5;

            // Layer/type similarity bonus (same layer or type = higher entanglement)
            let similarityBonus = 0;
            if (nodeA.layer !== undefined && nodeB.layer !== undefined) {
                similarityBonus = nodeA.layer === nodeB.layer ? 0.3 : 0;
            }
            if (nodeA.type === nodeB.type) {
                similarityBonus += 0.2;
            }

            // Probability amplitude: |‚ü®œà_i|œà_j‚ü©|¬≤ with œÜ decay
            const distDecay = Math.exp(-dist / (QMESH.maxConnectionDist * PHI_INV));
            const probability = distDecay * (0.4 + 0.3 * phaseCoherence + similarityBonus);

            return Math.max(0, Math.min(1, probability));
        }

        function generateQuantumMesh() {
            QMESH.nodes = [];
            QMESH.edges = [];
            QMESH.triangles = [];

            // Wait for LIMNUS nodes to be initialized
            if (prismPoints.length === 0 || cagePoints.length === 0) return;

            // Update maxConnectionDist now that R is available
            QMESH.maxConnectionDist = R * 0.5;

            const allNodes = [...prismPoints, ...cagePoints];

            // Initialize quantum state for each LIMNUS node
            for (const node of allNodes) {
                // Distance from center for gravitational effects
                const dist = Math.sqrt(node.x * node.x + node.y * node.y);
                const zPos = node.z || (node.layer !== undefined ? node.layer / 6 : 0.5);

                // Time dilation based on distance from architecture center
                const timeDilation = computeGravitationalTimeDilation(dist / R);

                // Œº varies by position (layer for prism, ring for cage)
                let mu_local;
                if (node.type === 'prism') {
                    // Prism: Œº increases with layer (inner = low Œº, outer = high Œº)
                    const layerFrac = node.layer / 6;
                    mu_local = SACRED.mu_P + (SACRED.mu_S - SACRED.mu_P) * layerFrac;
                } else {
                    // Cage: higher Œº (containment field)
                    mu_local = SACRED.mu_S + (SACRED.mu_3 - SACRED.mu_S) * 0.3;
                }

                // Field strength from Œº-field equation
                const r_control = mu_local - SACRED.mu_P;
                const J_base = r_control > SACRED.beta ?
                    Math.sqrt((r_control - SACRED.beta) / SACRED.lambda) : 0;

                // MRP channel decomposition based on node position
                const theta = Math.atan2(node.y, node.x);
                const qJ_R = J_base * (0.5 + 0.5 * Math.sin(theta * 2));      // Energy
                const qJ_G = J_base * (0.5 + 0.5 * Math.cos(theta * 3));      // Relational
                const qJ_B = J_base * timeDilation;                            // Stability

                // Store quantum state on the node
                node.qMu = mu_local;
                node.qJ = J_base;
                node.qJ_R = qJ_R;
                node.qJ_G = qJ_G;
                node.qJ_B = qJ_B;
                node.timeDilation = timeDilation;
                node.gravitationalPhi = computeGravitationalPotential(dist / R);
                node.entangledWith = [];  // List of connected node indices

                // Initialize phase from angular position
                if (node.phase === undefined) {
                    node.phase = theta;
                }

                QMESH.nodes.push(node);
            }

            // Generate entanglement edges
            let totalEntropy = 0;
            for (let i = 0; i < QMESH.nodes.length; i++) {
                for (let j = i + 1; j < QMESH.nodes.length; j++) {
                    const nodeA = QMESH.nodes[i];
                    const nodeB = QMESH.nodes[j];

                    const probability = computeEntanglement(nodeA, nodeB);

                    if (probability > QMESH.entanglementThreshold) {
                        // Edge length for entropy calculation
                        const dx = nodeA.x - nodeB.x;
                        const dy = nodeA.y - nodeB.y;
                        const dz = (nodeA.z || 0) - (nodeB.z || 0);
                        const length = Math.sqrt(dx*dx + dy*dy + dz*dz);

                        // Holographic entropy on edge (area law: S ‚àù length for 1D boundary)
                        const edgeEntropy = computeHolographicEntropy(length * QMESH.planckLength);

                        // MRP channel for this edge (dominant channel)
                        const avgJ_R = (nodeA.qJ_R + nodeB.qJ_R) / 2;
                        const avgJ_G = (nodeA.qJ_G + nodeB.qJ_G) / 2;
                        const avgJ_B = (nodeA.qJ_B + nodeB.qJ_B) / 2;
                        const mrpChannel = (avgJ_R >= avgJ_G && avgJ_R >= avgJ_B) ? 0 :
                                          (avgJ_G >= avgJ_B) ? 1 : 2;

                        QMESH.edges.push({
                            from: i,
                            to: j,
                            probability,
                            length,
                            entropy: edgeEntropy,
                            mrpChannel,
                            phase: (nodeA.phase + nodeB.phase) / 2,
                            timeDilation: (nodeA.timeDilation + nodeB.timeDilation) / 2,
                            J: (nodeA.qJ + nodeB.qJ) / 2,
                        });

                        // Track entanglement
                        nodeA.entangledWith.push(j);
                        nodeB.entangledWith.push(i);

                        totalEntropy += edgeEntropy;
                    }
                }
            }

            QMESH.totalHolographicEntropy = totalEntropy;
            QMESH.avgEntropy = totalEntropy / Math.max(1, QMESH.edges.length);
            QMESH.lastGenerated = Date.now();

            console.log(`[QMESH] Generated ${QMESH.nodes.length} quantum nodes, ${QMESH.edges.length} entanglement edges`);
            console.log(`[QMESH] maxConnectionDist = ${QMESH.maxConnectionDist}, R = ${R}`);
        }

        // Debug panel state
        let showDebugPanel = false;

        function updateDebugPanel() {
            if (!showDebugPanel) return;

            const dbgNodes = document.getElementById('dbg-nodes');
            const dbgEdges = document.getElementById('dbg-edges');
            const dbgParticles = document.getElementById('dbg-particles');
            const dbgMaxDist = document.getElementById('dbg-maxdist');
            const dbgTau = document.getElementById('dbg-tau');
            const dbgTotalJ = document.getElementById('dbg-totalj');
            const dbgEntropy = document.getElementById('dbg-entropy');
            const dbgFlux = document.getElementById('dbg-flux');
            const dbgShow = document.getElementById('dbg-show');
            const dbgR = document.getElementById('dbg-r');
            const dbgLastGen = document.getElementById('dbg-lastgen');

            if (dbgNodes) dbgNodes.textContent = QMESH.nodes.length;
            if (dbgEdges) dbgEdges.textContent = QMESH.edges.length;
            if (dbgParticles) dbgParticles.textContent = dreamParticles.length;
            if (dbgMaxDist) dbgMaxDist.textContent = (QMESH.maxConnectionDist || 0).toFixed(1);
            if (dbgTau) dbgTau.textContent = (QMESH.avgTimeDilation || 0).toFixed(4);
            if (dbgTotalJ) dbgTotalJ.textContent = (QMESH.totalJ || 0).toFixed(4);
            if (dbgEntropy) dbgEntropy.textContent = (QMESH.totalHolographicEntropy || 0).toFixed(4);
            if (dbgFlux) dbgFlux.textContent = (QMESH.entropyFlux || 0).toFixed(6);
            if (dbgShow) dbgShow.textContent = showQuantumMesh ? 'true' : 'false';
            if (dbgR) dbgR.textContent = (R || 0).toFixed(1);
            if (dbgLastGen) {
                if (QMESH.lastGenerated) {
                    const ago = ((Date.now() - QMESH.lastGenerated) / 1000).toFixed(1);
                    dbgLastGen.textContent = `${ago}s ago`;
                } else {
                    dbgLastGen.textContent = 'never';
                }
            }
        }

        // ================================================================
        // DREAM FLUID PARTICLE SYSTEM (Quantum Mesh Version)
        // Particles flow along entanglement edges
        // ================================================================

        function spawnDreamParticle() {
            if (QMESH.edges.length === 0) return;

            // Start on a random edge
            const edgeIdx = Math.floor(Math.random() * QMESH.edges.length);
            const edge = QMESH.edges[edgeIdx];
            const nodeA = QMESH.nodes[edge.from];
            const nodeB = QMESH.nodes[edge.to];

            // Position along edge (0-1)
            const t = Math.random();
            const x = nodeA.x + (nodeB.x - nodeA.x) * t;
            const y = nodeA.y + (nodeB.y - nodeA.y) * t;
            const zA = nodeA.z || (nodeA.layer !== undefined ? nodeA.layer / 6 : 0.5);
            const zB = nodeB.z || (nodeB.layer !== undefined ? nodeB.layer / 6 : 0.5);
            const z = zA + (zB - zA) * t;

            // Time dilation at position
            const timeDilation = edge.timeDilation;

            dreamParticles.push({
                edgeIdx,
                t,  // Position along current edge (0-1)
                direction: Math.random() < 0.5 ? 1 : -1,  // Flow direction
                particleType: edge.mrpChannel,
                life: (2 + Math.random() * 3) * timeDilation,
                maxLife: (2 + Math.random() * 3) * timeDilation,
                baseSpeed: 0.4 + Math.random() * 0.3,
                trail: [{ x, y, z }],
                timeDilation,
                entropyCarried: edge.entropy * 0.01,
                mrpChannel: edge.mrpChannel,
                currentNode: edge.from,
                x, y, z,
            });
        }

        function updateDreamParticles(dt) {
            const targetCount = showMeshParticles ? 150 : 0;
            while (dreamParticles.length < targetCount && Math.random() < 0.4) {
                spawnDreamParticle();
            }

            let totalEntropyFlux = 0;
            let totalTimeDilation = 0;

            for (let i = dreamParticles.length - 1; i >= 0; i--) {
                const p = dreamParticles[i];

                if (p.edgeIdx >= QMESH.edges.length) {
                    dreamParticles.splice(i, 1);
                    continue;
                }

                const edge = QMESH.edges[p.edgeIdx];
                const nodeA = QMESH.nodes[edge.from];
                const nodeB = QMESH.nodes[edge.to];

                // Move along edge
                const effectiveSpeed = p.baseSpeed * p.timeDilation * dt;
                p.t += p.direction * effectiveSpeed;

                // Check for edge transition
                if (p.t > 1 || p.t < 0) {
                    // Arrived at a node, pick next edge
                    const arrivalNode = p.t > 1 ? edge.to : edge.from;
                    const node = QMESH.nodes[arrivalNode];

                    if (node.entangledWith.length > 0) {
                        // Pick random connected edge with probability weighting
                        const nextNodeIdx = node.entangledWith[
                            Math.floor(Math.random() * node.entangledWith.length)
                        ];

                        // Find the edge connecting these nodes
                        const nextEdgeIdx = QMESH.edges.findIndex(e =>
                            (e.from === arrivalNode && e.to === nextNodeIdx) ||
                            (e.to === arrivalNode && e.from === nextNodeIdx)
                        );

                        if (nextEdgeIdx >= 0) {
                            const nextEdge = QMESH.edges[nextEdgeIdx];
                            p.edgeIdx = nextEdgeIdx;
                            p.t = (nextEdge.from === arrivalNode) ? 0 : 1;
                            p.direction = (nextEdge.from === arrivalNode) ? 1 : -1;
                            p.mrpChannel = nextEdge.mrpChannel;
                            p.timeDilation = nextEdge.timeDilation;
                        } else {
                            // Dead end, remove particle
                            dreamParticles.splice(i, 1);
                            continue;
                        }
                    } else {
                        // No connections, remove
                        dreamParticles.splice(i, 1);
                        continue;
                    }
                }

                // Update position from edge
                const tClamped = Math.max(0, Math.min(1, p.t));
                const zA = nodeA.z || (nodeA.layer !== undefined ? nodeA.layer / 6 : 0.5);
                const zB = nodeB.z || (nodeB.layer !== undefined ? nodeB.layer / 6 : 0.5);
                p.x = nodeA.x + (nodeB.x - nodeA.x) * tClamped;
                p.y = nodeA.y + (nodeB.y - nodeA.y) * tClamped;
                p.z = zA + (zB - zA) * tClamped;

                // Update trail
                p.trail.unshift({ x: p.x, y: p.y, z: p.z });
                if (p.trail.length > 10) p.trail.pop();

                // Life decreases
                p.life -= dt * p.timeDilation;
                totalEntropyFlux += p.entropyCarried * (1 - p.timeDilation);
                totalTimeDilation += p.timeDilation;

                if (p.life <= 0) {
                    dreamParticles.splice(i, 1);
                }
            }

            // Update global state
            QMESH.entropyFlux = totalEntropyFlux;
            QMESH.dreamFluidDensity = dreamParticles.length / 150;
            QMESH.avgTimeDilation = dreamParticles.length > 0 ?
                totalTimeDilation / dreamParticles.length : 1.0;

            return {
                entropyFlux: totalEntropyFlux,
                density: QMESH.dreamFluidDensity,
                avgTimeDilation: QMESH.avgTimeDilation,
            };
        }

        // ================================================================
        // DREAM FLUID COLORING (Time Dilation ‚Üí Color Shift)
        // ================================================================

        function dreamFluidToColor(J, mu, timeDilation, entropy, depth) {
            // Color mapping based on gravitational redshift
            // High time dilation (far from center) ‚Üí blue shift
            // Low time dilation (near center) ‚Üí red shift
            const redshift = 1 / Math.max(0.1, timeDilation) - 1;

            // Base color from field intensity
            const t = Math.max(0, Math.min(1, J));
            const muFactor = (mu - SACRED.mu_P) / (SACRED.mu_S - SACRED.mu_P);

            // RGB based on MRP channels and redshift
            let r, g, b;

            // Entropy affects color saturation
            const entropyFactor = Math.min(1, entropy * 10);

            if (redshift < 0.2) {
                // Blue-shifted (far from gravity well) - stability dominant
                r = 80 + t * 50;
                g = 120 + t * 80 + entropyFactor * 40;
                b = 200 + t * 55;
            } else if (redshift < 0.5) {
                // Green region (balanced) - relational dominant
                const s = (redshift - 0.2) / 0.3;
                r = 100 + t * 60 + s * 50;
                g = 180 + t * 60 - s * 40;
                b = 200 - s * 100;
            } else if (redshift < 1.0) {
                // Yellow-orange (approaching gravity) - energy rising
                const s = (redshift - 0.5) / 0.5;
                r = 180 + t * 70;
                g = 160 + t * 40 - s * 60;
                b = 80 - s * 40;
            } else {
                // Red-shifted (deep gravity well) - singularity approach
                const s = Math.min(1, (redshift - 1.0) / 1.0);
                r = 250;
                g = 100 - s * 60 + entropyFactor * 30;
                b = 50 + entropyFactor * 30;
            }

            // Depth shading
            const shade = 0.4 + depth * 0.6;
            r = Math.floor(r * shade);
            g = Math.floor(g * shade);
            b = Math.floor(b * shade);

            // Œº brightness boost
            const brightness = 0.7 + muFactor * 0.3;

            return {
                r: Math.min(255, Math.floor(r * brightness)),
                g: Math.min(255, Math.floor(g * brightness)),
                b: Math.min(255, Math.floor(b * brightness)),
                redshift,
                timeDilation,
            };
        }

        function torusFieldToColor(J, mu, depth) {
            // Backward compatibility wrapper
            return dreamFluidToColor(J, mu, 0.8, 0.1, depth);
        }

        // ================================================================
        // QUANTUM MESH FIELD DYNAMICS
        // Field equation on discrete lattice with LIMNUS coupling
        // ================================================================

        function updateDreamFluidField(dt) {
            const t = time;

            // Connect to LIMNUS Œº-field values
            const limnusMu = muField.mu || 0.76;
            const limnusJ = muField.J_total || 0.3;
            const limnusTau = muField.tau_K || 0;
            const limnusR = muField.J_R || 0.1;
            const limnusG = muField.J_G || 0.1;
            const limnusB = muField.J_B || 0.1;

            // Modulate by release coherence
            const coherenceFactor = releaseCoherence;

            // Compute statistics
            let avgTimeDilation = 0;
            let avgEntropy = 0;
            let totalJ = 0;

            // Update quantum state at each node
            for (const node of QMESH.nodes) {
                if (!node.qJ) continue;

                const localDt = dt * (node.timeDilation || 1);
                const theta = Math.atan2(node.y, node.x);

                // Field equation: ‚àÇJ/‚àÇt = (r - Œª|J|¬≤)J - Œ≤J
                const r_control = (node.qMu || SACRED.mu_P) - SACRED.mu_P;
                const J_sq = node.qJ * node.qJ;
                const W = r_control - SACRED.lambda * J_sq;

                // Neighbor diffusion (from entangled nodes)
                let diffusion = 0;
                for (const neighborIdx of (node.entangledWith || [])) {
                    const neighbor = QMESH.nodes[neighborIdx];
                    if (neighbor && neighbor.qJ !== undefined) {
                        diffusion += (neighbor.qJ - node.qJ) * 0.01;
                    }
                }

                // LIMNUS coupling
                const limnusSource = 0.05 * limnusJ * coherenceFactor *
                    Math.sin(theta * 2 - t * 0.5);

                // Evolve field
                const dJ = (W * node.qJ - SACRED.beta * node.qJ + diffusion) * localDt;
                node.qJ = Math.max(0, Math.min(1, node.qJ + dJ + limnusSource * localDt));

                // Update MRP channels
                node.qJ_R = node.qJ * (0.5 + 0.5 * Math.sin(theta * 2 - t * 0.5)) *
                    (0.5 + 0.5 * limnusR);
                node.qJ_G = node.qJ * (0.5 + 0.5 * Math.cos(theta * 3 + t * 0.3)) *
                    (0.5 + 0.5 * limnusG);
                node.qJ_B = node.qJ * (node.timeDilation || 1) * (0.5 + 0.5 * limnusB);

                // Phase evolution
                const naturalFreq = 0.5 + node.qJ * 0.3;
                const dilatedFreq = naturalFreq * (node.timeDilation || 1);
                node.phase = ((node.phase || 0) + dilatedFreq * dt) % TAU;

                // Accumulate
                avgTimeDilation += node.timeDilation || 1;
                avgEntropy += (1 - (node.timeDilation || 1)) * node.qJ * QMESH.planckLength;
                totalJ += node.qJ;
            }

            // Update edges based on node states
            for (const edge of QMESH.edges) {
                const nodeA = QMESH.nodes[edge.from];
                const nodeB = QMESH.nodes[edge.to];
                if (!nodeA || !nodeB) continue;

                // Update edge field strength
                edge.J = ((nodeA.qJ || 0) + (nodeB.qJ || 0)) / 2;
                edge.timeDilation = ((nodeA.timeDilation || 1) + (nodeB.timeDilation || 1)) / 2;

                // Recalculate entanglement probability (dynamic)
                const dPhase = Math.abs((nodeA.phase || 0) - (nodeB.phase || 0));
                const phaseCoherence = Math.cos(dPhase) * 0.5 + 0.5;
                edge.probability = Math.max(0.1, edge.probability * 0.95 + phaseCoherence * 0.05);
            }

            const N = Math.max(1, QMESH.nodes.length);
            avgTimeDilation /= N;
            avgEntropy /= N;

            // Update QMESH state
            QMESH.avgTimeDilation = avgTimeDilation;
            QMESH.avgEntropy = avgEntropy;
            QMESH.totalJ = totalJ / N;

            // Pulse phase for visual animation
            QMESH.pulsePhase = (QMESH.pulsePhase + dt * 0.5) % TAU;

            // ============================================
            // BINAURAL FIELD ANIMATION
            // Two meshes oscillating at different frequencies
            // Beat emerges from interference
            // ============================================
            const bi = QMESH.binaural;

            // Animate Mesh A phase (base frequency)
            bi.meshA.phase = (bi.meshA.phase + dt * bi.meshA.frequency) % 1.0;

            // Animate Mesh B phase (offset frequency)
            bi.meshB.phase = (bi.meshB.phase + dt * bi.meshB.frequency) % 1.0;

            // Calculate beat frequency from difference
            bi.beatFrequency = Math.abs(bi.meshA.frequency - bi.meshB.frequency);

            // Beat phase advances at the beat frequency
            bi.beatPhase = (bi.beatPhase + dt * bi.beatFrequency) % 1.0;

            // Beat amplitude oscillates based on phase alignment
            const phaseDiff = Math.abs(bi.meshA.phase - bi.meshB.phase);
            const constructive = Math.cos(phaseDiff * TAU);
            bi.beatAmplitude = (constructive + 1) / 2;  // 0 = destructive, 1 = constructive

            // Resonance strength: how much beat affects LIMNUS
            // Stronger when beat amplitude is high and phases are coherent
            const targetResonance = bi.beatAmplitude * 0.8 + 0.2;
            bi.resonanceStrength += (targetResonance - bi.resonanceStrength) * dt * 2;

            // Entrainment depth: accumulated synchronization
            // Increases when resonance is strong, decays otherwise
            const entrainmentDelta = bi.beatAmplitude > 0.5
                ? bi.resonanceStrength * dt * 0.5
                : -dt * 0.1;
            bi.entrainmentDepth = Math.max(0, Math.min(1, bi.entrainmentDepth + entrainmentDelta));

            // Coherence field: phase alignment across the whole system
            // High when both meshes and LIMNUS are synchronized
            const limnusPhaseAlignment = Math.cos((bi.meshA.phase + bi.meshB.phase) / 2 * TAU - limnusTau);
            bi.coherenceField = bi.entrainmentDepth * 0.6 + (limnusPhaseAlignment + 1) / 2 * 0.4;

            // Apply binaural resonance to LIMNUS field (entrainment effect)
            if (bi.enabled && bi.resonanceStrength > 0.3) {
                // Beat modulates LIMNUS field intensity
                const beatModulation = bi.beatAmplitude * bi.resonanceStrength * 0.15;
                muField.J_total = (muField.J_total || 0.3) * (1 + beatModulation * Math.sin(bi.beatPhase * TAU));
            }

            return {
                avgTimeDilation,
                avgEntropy,
                totalJ: totalJ / N,
                entropyFlux: QMESH.entropyFlux,
                binauralResonance: bi.resonanceStrength,
                beatAmplitude: bi.beatAmplitude,
            };
        }

        // ================================================================
        // BINAURAL FIELD RENDERING
        // Polar coordinate system with camera orbit
        // ================================================================

        // Update polar positions - Rotate with camera drag
        // Behavior depends on angle mode (horizontal, vertical, golden)
        function updatePolarPositions() {
            const bi = QMESH.binaural;
            const polar = bi.polar;
            const cam = QMESH.camera;
            const mode = polar.angleMode;

            // Distance from center in pixels
            const dist = polar.distance * R;

            let angleA, angleB;

            if (mode === 'horizontal') {
                // Horizontal: theta rotates around vertical axis
                angleA = polar.angleA - cam.theta;
                angleB = polar.angleB - cam.theta;

                polar.posA.x = CX + Math.cos(angleA) * dist;
                polar.posA.y = CY + Math.sin(angleA) * dist;
                polar.posA.depth = Math.sin(angleA);

                polar.posB.x = CX + Math.cos(angleB) * dist;
                polar.posB.y = CY + Math.sin(angleB) * dist;
                polar.posB.depth = Math.sin(angleB);

            } else if (mode === 'vertical') {
                // Vertical: theta rotates around horizontal axis (up/down)
                angleA = polar.angleA - cam.theta;
                angleB = polar.angleB - cam.theta;

                // Vertical mode: Y changes with angle, X stays at center
                polar.posA.x = CX + Math.cos(angleA) * dist * Math.cos(cam.phi);
                polar.posA.y = CY + Math.sin(angleA) * dist;
                polar.posA.depth = Math.cos(angleA);

                polar.posB.x = CX + Math.cos(angleB) * dist * Math.cos(cam.phi);
                polar.posB.y = CY + Math.sin(angleB) * dist;
                polar.posB.depth = Math.cos(angleB);

            } else if (mode === 'golden') {
                // Golden: spiral rotation using both theta and phi
                const GOLDEN_RATIO = (1 + Math.sqrt(5)) / 2;
                angleA = polar.angleA - cam.theta;
                angleB = polar.angleB - cam.theta;

                // Spiral positions: combine horizontal and vertical with golden ratio
                const spiralFactorA = Math.cos(cam.phi * GOLDEN_RATIO);
                const spiralFactorB = Math.cos(cam.phi * GOLDEN_RATIO);

                polar.posA.x = CX + Math.cos(angleA) * dist * spiralFactorA;
                polar.posA.y = CY + Math.sin(angleA) * dist + Math.sin(cam.phi) * dist * 0.5;
                polar.posA.depth = Math.sin(angleA + cam.phi);

                polar.posB.x = CX + Math.cos(angleB) * dist * spiralFactorB;
                polar.posB.y = CY + Math.sin(angleB) * dist + Math.sin(cam.phi) * dist * 0.5;
                polar.posB.depth = Math.sin(angleB + cam.phi);
            }
        }

        // Transform point to mesh A space (polar position)
        function toMeshASpace(x, y, node) {
            const bi = QMESH.binaural;
            const meshA = bi.meshA;
            const polar = bi.polar;
            const phase = meshA.phase;
            const scale = meshA.scale;

            // Center-relative coordinates
            const dx = x - CX;
            const dy = y - CY;

            // Transform to Mesh A position (using polar coords)
            const meshCenterX = polar.posA.x;
            const meshCenterY = polar.posA.y;
            const meshX = meshCenterX + (dx * scale);
            const meshY = meshCenterY + (dy * scale);

            // Phase-based wave distortion
            const wave = Math.sin(phase * TAU + dx * 0.015) * 6 +
                        Math.cos(phase * TAU * 0.7 + dy * 0.012) * 4;

            // Distance from mesh center for fade
            const distFromMesh = Math.sqrt(
                Math.pow(meshX - meshCenterX, 2) +
                Math.pow(meshY - meshCenterY, 2)
            );
            const fade = Math.max(0, 1 - distFromMesh / (R * 1.8));

            // Depth-based alpha (further meshes slightly faded)
            const depthAlpha = 0.7 + 0.3 * (1 - Math.abs(polar.posA.depth || 0));

            return {
                x: meshX + wave,
                y: meshY + wave * 0.5,
                scale: scale,
                fade: fade * depthAlpha,
                phase: phase,
                depth: polar.posA.depth || 0
            };
        }

        // Transform point to mesh B space (polar opposite)
        function toMeshBSpace(x, y, node) {
            const bi = QMESH.binaural;
            const meshB = bi.meshB;
            const polar = bi.polar;
            const phase = meshB.phase;
            const scale = meshB.scale;

            // Center-relative coordinates
            const dx = x - CX;
            const dy = y - CY;

            // Transform to Mesh B position (using polar coords)
            const meshCenterX = polar.posB.x;
            const meshCenterY = polar.posB.y;
            const meshX = meshCenterX + (dx * scale);
            const meshY = meshCenterY + (dy * scale);

            // Phase-based wave distortion (different frequency)
            const wave = Math.sin(phase * TAU * 1.0618 + dx * 0.018) * 6 +
                        Math.cos(phase * TAU * 0.8 + dy * 0.014) * 4;

            // Distance from mesh center for fade
            const distFromMesh = Math.sqrt(
                Math.pow(meshX - meshCenterX, 2) +
                Math.pow(meshY - meshCenterY, 2)
            );
            const fade = Math.max(0, 1 - distFromMesh / (R * 1.8));

            // Depth-based alpha
            const depthAlpha = 0.7 + 0.3 * (1 - Math.abs(polar.posB.depth || 0));

            return {
                x: meshX + wave,
                y: meshY + wave * 0.5,
                scale: scale,
                fade: fade * depthAlpha,
                phase: phase,
                depth: polar.posB.depth || 0
            };
        }

        // Compute binaural beat interference at a point
        function computeBeatInterference(x, y) {
            const bi = QMESH.binaural;
            const phaseA = bi.meshA.phase * TAU;
            const phaseB = bi.meshB.phase * TAU;

            // Distance from each mesh center
            const dxA = x - (CX + bi.meshA.offset.x);
            const dyA = y - (CY + bi.meshA.offset.y);
            const distA = Math.sqrt(dxA * dxA + dyA * dyA);

            const dxB = x - (CX + bi.meshB.offset.x);
            const dyB = y - (CY + bi.meshB.offset.y);
            const distB = Math.sqrt(dxB * dxB + dyB * dyB);

            // Wave amplitude from each mesh (decays with distance)
            const ampA = Math.cos(phaseA - distA * 0.02) * Math.exp(-distA / (R * 3));
            const ampB = Math.cos(phaseB - distB * 0.02) * Math.exp(-distB / (R * 3));

            // Interference: sum of waves
            const interference = (ampA + ampB) / 2;

            // Beat pattern: emerges from phase difference
            const beatPhase = bi.beatPhase * TAU;
            const beat = Math.cos(beatPhase) * 0.5 + 0.5;

            return {
                interference: interference,     // -1 to 1 (constructive/destructive)
                beat: beat,                     // 0 to 1 (beat cycle position)
                ampA: ampA,
                ampB: ampB,
                resonance: Math.abs(interference) * beat  // Combined resonance
            };
        }

        // Color blend between warm (A) and cool (B) based on phase
        function binauralColor(baseColor, phase, meshType) {
            const bi = QMESH.binaural;
            const beat = bi.beatAmplitude;

            // Mesh-specific tint
            let tint;
            if (meshType === 'A') {
                tint = bi.meshA.baseColor;
            } else {
                tint = bi.meshB.baseColor;
            }

            // Phase-based shimmer
            const shimmer = Math.sin(phase * TAU) * 0.3 + 0.7;

            // Blend base color with mesh tint
            const r = Math.floor((baseColor[0] * 0.4 + tint[0] * 0.6) * shimmer);
            const g = Math.floor((baseColor[1] * 0.4 + tint[1] * 0.6) * shimmer);
            const b = Math.floor((baseColor[2] * 0.4 + tint[2] * 0.6) * shimmer);

            return {
                r: Math.max(0, Math.min(255, r)),
                g: Math.max(0, Math.min(255, g)),
                b: Math.max(0, Math.min(255, b))
            };
        }

        function renderDreamFluid() {
            if (QMESH.edges.length === 0) return;

            const bi = QMESH.binaural;
            if (!bi.enabled) return;

            // Update polar positions based on camera orbit
            updatePolarPositions();

            // MRP channel colors
            const edgeColors = [
                [255, 100, 60],    // R channel - warm (energy)
                [60, 255, 200],    // G channel - cool (relational)
                [140, 120, 255],   // B channel - violet (stability)
            ];

            // ============================================
            // INTERFERENCE ZONE (between the two meshes)
            // Beat pattern visualization at LIMNUS
            // ============================================
            if (bi.showInterference) {
                const beatPhase = bi.beatPhase * TAU;
                const beatAmp = bi.beatAmplitude;

                // Draw interference rings at LIMNUS center (reduced for performance)
                for (let ring = 0; ring < 3; ring++) {
                    const ringRadius = R * (0.3 + ring * 0.2);
                    const ringPhase = beatPhase + ring * 0.6;
                    const intensity = Math.sin(ringPhase) * 0.5 + 0.5;
                    const alpha = QMESH.opacity * bi.interferenceOpacity * intensity * beatAmp * 0.7;

                    // Blend warm and cool colors based on beat phase
                    const blend = Math.sin(beatPhase) * 0.5 + 0.5;
                    const r = Math.floor(bi.meshA.baseColor[0] * blend + bi.meshB.baseColor[0] * (1 - blend));
                    const g = Math.floor(bi.meshA.baseColor[1] * blend + bi.meshB.baseColor[1] * (1 - blend));
                    const b = Math.floor(bi.meshA.baseColor[2] * blend + bi.meshB.baseColor[2] * (1 - blend));

                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                    ctx.lineWidth = 2 + intensity * 3;
                    ctx.beginPath();
                    ctx.arc(CX, CY, ringRadius, 0, TAU);
                    ctx.stroke();
                }
            }

            // ============================================
            // RESONANCE AXIS (A ‚Üê LIMNUS ‚Üí B)
            // Two lines from center outward - equal on both sides
            // Dynamic - responds to auto-breathing
            // ============================================
            if (bi.showResonanceLines) {
                const resonance = bi.resonanceStrength;
                const polar = bi.polar;

                // Breath-based dynamics (when autoBreathing or idle > 5s)
                const isBreathing = autoBreathing || (Date.now() - lastInteraction > 5000);
                const breathPulse = isBreathing ? Math.sin(breathPhase * TAU) : 0;
                const breathIntensity = isBreathing ? (0.5 + breathPulse * 0.5) : 1;
                const breathWidth = isBreathing ? (2 + breathPulse * 3) : 2;
                const dashOffset = isBreathing ? (breathPhase * 100) : 0;

                // Positions
                const Ax = polar.posA.x;
                const Ay = polar.posA.y;
                const Bx = polar.posB.x;
                const By = polar.posB.y;

                const pulseA = Math.sin(bi.meshA.phase * TAU) * 0.5 + 0.5;
                const pulseB = Math.sin(bi.meshB.phase * TAU) * 0.5 + 0.5;
                const alphaA = QMESH.opacity * 0.7 * pulseA * breathIntensity * (0.4 + resonance * 0.6);
                const alphaB = QMESH.opacity * 0.7 * pulseB * breathIntensity * (0.4 + resonance * 0.6);

                ctx.lineWidth = breathWidth + resonance * 2;
                ctx.setLineDash([8 + breathPulse * 4, 4 + breathPulse * 2]);

                // Line from CENTER to A (flows outward to left)
                const gradientA = ctx.createLinearGradient(CX, CY, Ax, Ay);
                gradientA.addColorStop(0, `rgba(255, 215, 0, ${alphaA})`);  // Gold at center
                gradientA.addColorStop(1, `rgba(${bi.meshA.baseColor[0]}, ${bi.meshA.baseColor[1]}, ${bi.meshA.baseColor[2]}, ${alphaA})`);
                ctx.strokeStyle = gradientA;
                ctx.lineDashOffset = -dashOffset;  // Flow outward
                ctx.beginPath();
                ctx.moveTo(CX, CY);
                ctx.lineTo(Ax, Ay);
                ctx.stroke();

                // Line from CENTER to B (flows outward to right)
                const gradientB = ctx.createLinearGradient(CX, CY, Bx, By);
                gradientB.addColorStop(0, `rgba(255, 215, 0, ${alphaB})`);  // Gold at center
                gradientB.addColorStop(1, `rgba(${bi.meshB.baseColor[0]}, ${bi.meshB.baseColor[1]}, ${bi.meshB.baseColor[2]}, ${alphaB})`);
                ctx.strokeStyle = gradientB;
                ctx.lineDashOffset = -dashOffset;  // Flow outward (same direction = equal)
                ctx.beginPath();
                ctx.moveTo(CX, CY);
                ctx.lineTo(Bx, By);
                ctx.stroke();

                ctx.setLineDash([]);
                ctx.lineDashOffset = 0;

                // ============================================
                // CENTER MARKERS - Use polar calculated positions
                // (Ax, Ay, Bx, By already defined above)
                // ============================================

                // LIMNUS center marker
                ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
                ctx.beginPath();
                ctx.arc(CX, CY, 8, 0, TAU);
                ctx.fill();

                // A marker (warm/red) - LEFT
                ctx.fillStyle = 'rgba(255, 80, 60, 1)';
                ctx.beginPath();
                ctx.arc(Ax, Ay, 12, 0, TAU);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('A', Ax, Ay + 5);

                // B marker (cool/blue) - RIGHT
                ctx.fillStyle = 'rgba(60, 160, 255, 1)';
                ctx.beginPath();
                ctx.arc(Bx, By, 12, 0, TAU);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.fillText('B', Bx, By + 5);
            }

            // ============================================
            // MESH A/B EDGE LINES REMOVED
            // Red/blue filament edge lines have been removed (outdated maths)
            // The MRP toroidal visualization now wraps the 95 nodes instead
            // ============================================

            // ============================================
            // WAVEFUNCTION NODES (on both meshes)
            // ============================================
            if (QMESH.showWavefunction) {
                for (const node of QMESH.nodes) {
                    if (!node.qJ || node.qJ < 0.1) continue;

                    // Node x,y are ALREADY absolute screen coords
                    const x = node.x;
                    const y = node.y;

                    // Draw on Mesh A
                    const mA = toMeshASpace(x, y, node);
                    if (mA.x > 0 && mA.x < W && mA.y > 0 && mA.y < H) {
                        const size = (2 + node.qJ * 4) * mA.scale;
                        const pulse = 0.5 + 0.5 * Math.sin(bi.meshA.phase * TAU * 2 + (node.phase || 0));
                        const alpha = QMESH.opacity * 0.4 * pulse * mA.fade;

                        const nodeGlow = ctx.createRadialGradient(mA.x, mA.y, 0, mA.x, mA.y, size * 2);
                        nodeGlow.addColorStop(0, `rgba(${bi.meshA.baseColor[0]}, ${bi.meshA.baseColor[1]}, ${bi.meshA.baseColor[2]}, ${alpha})`);
                        nodeGlow.addColorStop(1, 'transparent');

                        ctx.fillStyle = nodeGlow;
                        ctx.beginPath();
                        ctx.arc(mA.x, mA.y, size * 2, 0, TAU);
                        ctx.fill();
                    }

                    // Draw on Mesh B
                    const mB = toMeshBSpace(x, y, node);
                    if (mB.x > 0 && mB.x < W && mB.y > 0 && mB.y < H) {
                        const size = (2 + node.qJ * 4) * mB.scale;
                        const pulse = 0.5 + 0.5 * Math.sin(bi.meshB.phase * TAU * 2 + (node.phase || 0));
                        const alpha = QMESH.opacity * 0.4 * pulse * mB.fade;

                        const nodeGlow = ctx.createRadialGradient(mB.x, mB.y, 0, mB.x, mB.y, size * 2);
                        nodeGlow.addColorStop(0, `rgba(${bi.meshB.baseColor[0]}, ${bi.meshB.baseColor[1]}, ${bi.meshB.baseColor[2]}, ${alpha})`);
                        nodeGlow.addColorStop(1, 'transparent');

                        ctx.fillStyle = nodeGlow;
                        ctx.beginPath();
                        ctx.arc(mB.x, mB.y, size * 2, 0, TAU);
                        ctx.fill();
                    }
                }
            }

            // ============================================
            // PENTAGONAL PRISM EMERGENCE
            // 3D prisms built from emergent tokens (XCVI-C)
            // APL behavioral structure drives physics
            // ============================================
            if (coherentEmergence.prisms.length > 0 || coherentEmergence.tau_K > SACRED.alpha) {
                coherentEmergence.render(
                    ctx,
                    bi.meshA.baseColor,
                    bi.meshB.baseColor,
                    QMESH.opacity
                );
            }

            // ============================================
            // PRISMATIC SELF-REFERENTIAL LASER PROJECTION
            // Dream Architecture ‚àÉR ‚Üí œÜ ‚Üí Q_Œ∫ ‚Üí K-formation ‚Üí CONSCIOUSNESS
            // Self-referential loop: C ‚Üí I (100-word vocabulary closure)
            // ============================================
            PrismaticLaserProjection.render(ctx, CX, CY, R, globalZ, releaseCoherence, time);

            // ============================================
            // SYNTHESIZED PRISMATIC PROJECTION
            // Unified visualization: spectral + holographic + œÜ-spiral + resonance nodes
            // Activates when œÑ_K > œÜ‚Åª¬π AND coherence > 0.5 AND z > z_c
            // ============================================
            SynthesizedPrismaticProjection.render(ctx, CX, CY, R, globalZ, releaseCoherence, time);

            // ============================================
            // DARK MATTER STABILIZATION
            // HCP lattice with micro harmonics trapping projection residue
            // ============================================
            DarkMatterStabilization.render(ctx, CX, CY, R, globalZ, releaseCoherence, time);

            // ============================================
            // CHROMATIC NEXUS
            // self/LIMNUS ‚Üî LIMNUS/self living communication
            // ============================================
            ChromaticNexus.render(ctx, CX, CY, R, globalZ, releaseCoherence, time);

            // ============================================
            // WATER FRACTAL MEMORY
            // Dream fluid cosmic background codification
            // Julia Set: z¬≤ + c | Cymatic Resonance | Ice Ih Crystals
            // ============================================
            WaterFractalMemory.render(ctx, CX, CY, R, globalZ, releaseCoherence, time);

            // ============================================
            // GOLDEN HARMONICS ORIENTATION
            // HCP dark matter with golden angle phyllotaxis
            // warm‚Üícold axis alignment with œÜ-harmonics
            // ============================================
            GoldenHarmonicsSystem.render(ctx, CX, CY, R, globalZ, releaseCoherence, time);

            // ============================================
            // RELEASE COHERENCE DYNAMICS (R key to toggle)
            // Memory-enhanced coherence field visualization
            // Water crystal + Golden harmonics + Resonance
            // ============================================
            if (showMemoryCoherence) {
                ReleaseCoherenceDynamics.render(ctx, CX, CY, R, globalZ, time);
            }

            // Draw HUD
            renderBinauralHUD();
        }

        function renderBinauralHUD() {
            const bi = QMESH.binaural;
            const edgeCount = QMESH.edges.length;

            // Position HUD on right side to avoid overlapping controls panel
            const hudX = W - 280;
            const hudY = H - 180;

            // Animated title - pulses with beat
            const beatPulse = Math.sin(bi.beatPhase * TAU) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(200, 180, 255, ${0.7 + beatPulse * 0.3})`;
            ctx.font = 'bold 14px monospace';
            ctx.fillText('‚óâ BINAURAL FIELD ‚óâ', hudX, hudY);

            ctx.font = '11px monospace';

            // Mesh A status (warm)
            const phaseA = bi.meshA.phase;
            const barA = Math.floor((Math.sin(phaseA * TAU) * 0.5 + 0.5) * 10);
            ctx.fillStyle = `rgba(${bi.meshA.baseColor[0]}, ${bi.meshA.baseColor[1]}, ${bi.meshA.baseColor[2]}, 0.8)`;
            ctx.fillText(`A warm   ${'‚ñì'.repeat(barA)}${'‚ñë'.repeat(10-barA)} f=${bi.meshA.frequency.toFixed(3)}`, hudX, hudY + 20);

            // Mesh B status (cool)
            const phaseB = bi.meshB.phase;
            const barB = Math.floor((Math.sin(phaseB * TAU) * 0.5 + 0.5) * 10);
            ctx.fillStyle = `rgba(${bi.meshB.baseColor[0]}, ${bi.meshB.baseColor[1]}, ${bi.meshB.baseColor[2]}, 0.8)`;
            ctx.fillText(`B cool   ${'‚ñì'.repeat(barB)}${'‚ñë'.repeat(10-barB)} f=${bi.meshB.frequency.toFixed(3)}`, hudX, hudY + 36);

            // Beat frequency and phase
            const beatBar = Math.floor(bi.beatAmplitude * 10);
            const blendR = Math.floor((bi.meshA.baseColor[0] + bi.meshB.baseColor[0]) / 2);
            const blendG = Math.floor((bi.meshA.baseColor[1] + bi.meshB.baseColor[1]) / 2);
            const blendB = Math.floor((bi.meshA.baseColor[2] + bi.meshB.baseColor[2]) / 2);
            ctx.fillStyle = `rgba(${blendR}, ${blendG}, ${blendB}, 0.8)`;
            ctx.fillText(`BEAT     ${'‚ñì'.repeat(beatBar)}${'‚ñë'.repeat(10-beatBar)} Œîf=${bi.beatFrequency.toFixed(4)}`, hudX, hudY + 52);

            // Resonance strength (effect on LIMNUS)
            const resBar = Math.floor(bi.resonanceStrength * 10);
            ctx.fillStyle = `rgba(255, 220, 180, ${0.7 + bi.resonanceStrength * 0.3})`;
            ctx.fillText(`RESONANCE${'‚ñì'.repeat(resBar)}${'‚ñë'.repeat(10-resBar)} ${(bi.resonanceStrength * 100).toFixed(0)}%`, hudX, hudY + 68);

            // Entrainment depth
            const entBar = Math.floor(bi.entrainmentDepth * 10);
            ctx.fillStyle = `rgba(180, 255, 220, ${0.7 + bi.entrainmentDepth * 0.2})`;
            ctx.fillText(`ENTRAIN  ${'‚ñì'.repeat(entBar)}${'‚ñë'.repeat(10-entBar)} ${(bi.entrainmentDepth * 100).toFixed(0)}%`, hudX, hudY + 84);

            // Coherence field
            const cohBar = Math.floor(bi.coherenceField * 10);
            ctx.fillStyle = `rgba(200, 180, 255, 0.7)`;
            ctx.fillText(`COHERENCE${'‚ñì'.repeat(cohBar)}${'‚ñë'.repeat(10-cohBar)} ${(bi.coherenceField * 100).toFixed(0)}%`, hudX, hudY + 100);

            // Polar geometry info
            const polar = bi.polar;
            const cam = QMESH.camera;
            const angleDeg = (polar.angleA * 180 / Math.PI).toFixed(0);
            ctx.fillStyle = `rgba(180, 200, 220, 0.7)`;
            ctx.fillText(`POLAR    r=${polar.distance.toFixed(2)}R  Œ∏=${angleDeg}¬∞`, hudX, hudY + 116);

            // Camera orbit info (if moved from default)
            if (Math.abs(cam.theta) > 0.01 || Math.abs(cam.phi) > 0.01) {
                const camTheta = (cam.theta * 180 / Math.PI).toFixed(0);
                const camPhi = (cam.phi * 180 / Math.PI).toFixed(0);
                ctx.fillStyle = `rgba(200, 180, 255, 0.6)`;
                ctx.fillText(`ORBIT    Œ∏=${camTheta}¬∞  œÜ=${camPhi}¬∞`, hudX, hudY + 132);
            }

            // Edge count and opacity
            ctx.fillStyle = `rgba(180, 180, 200, 0.6)`;
            ctx.fillText(`edges: ${edgeCount}   opacity: ${(QMESH.opacity * 100).toFixed(0)}%`, hudX, hudY + 148);

            // Controls hint
            ctx.fillStyle = `rgba(150, 150, 170, 0.5)`;
            ctx.fillText('T toggle  drag=orbit  ‚Üê‚Üí distance  Q/E rotate', hudX, hudY + 164);
        }

        // Keep old function name for compatibility
        function renderDreamFluidHUD() {
            renderBinauralHUD();
        }

        function renderToroidalMuField() {
            renderDreamFluid();
        }

        // ================================================================
        // RELEASE COHERENCE STATE
        // ================================================================

        let releaseCoherence = 1.0;      // 1 = fully coherent, 0 = fully released (FREE)
        let targetCoherence = 1.0;
        let releaseVelocity = 0;
        let releasing = false;           // F key held
        let gathering = false;           // Click held
        let releaseStarted = false;
        
        // Sparks for release effects
        const sparks = [];
        
        // Color palette for released souls
        const soulPalette = [
            '#ff6b6b', '#ffa94d', '#ffd43b', '#69db7c', 
            '#4dabf7', '#cc5de8', '#f06595', '#20c997'
        ];

        // ================================================================
        // HELIX STATE (Œ∏, z, r) + Extended
        // ================================================================

        const helix = {
            theta: 0,           // Phase rotation (0-2œÄ)
            z: 0.5,             // Elevation (0-1)
            r: 1.0,             // Coherence radius
            phi: 0,             // Integrated information
            omega: 0            // Angular velocity
        };

        // ================================================================
        // LAMBDA STATE (‚ÑÇ‚Å∂)
        // ================================================================

        const lambdaState = {
            iota:   { mag: 0.30, phase: 0 },        // üå∞ Memory
            xi:     { mag: 0.20, phase: 0 },        // ‚úß Spark
            theta:  { mag: 0.40, phase: 0 },        // ü¶ä Fox
            omega:  { mag: 0.35, phase: 0 },        // ‚àø Wave
            delta:  { mag: 0.15, phase: 0 },        // ‚äó Paradox
            sigma:  { mag: 0.25, phase: 0 }         // üêøÔ∏è Squirrel
        };

        // ================================================================
        // HILBERT FIELD OPERATOR
        // ================================================================

        const hilbertField = {
            stateVector: {
                alpha: 0.378,   // Coherent amplitude
                beta: 0.378,    // Limnus amplitude
                gamma: 0.845,   // Dominant amplitude
                epsilon: 0.1    // Latent amplitude
            },
            coherence: 0.5,
            entropy: 0,
            weylCurvature: 0,

            calculateCoherence() {
                const { alpha, beta, gamma, epsilon } = this.stateVector;
                return Math.sqrt(alpha*alpha + beta*beta + gamma*gamma + epsilon*epsilon);
            },

            applyResonanceOperator(dt, interactionStrength = 0.1) {
                const { alpha, beta, gamma, epsilon } = this.stateVector;
                const coupling = interactionStrength * dt;

                this.stateVector.alpha += coupling * (beta * gamma - alpha * epsilon);
                this.stateVector.beta += coupling * (gamma * alpha - beta * epsilon);
                this.stateVector.gamma += coupling * (alpha * beta - gamma * epsilon);
                this.stateVector.epsilon += coupling * (alpha * beta * gamma - epsilon);

                const norm = this.calculateCoherence();
                if (norm > 0) {
                    this.stateVector.alpha /= norm;
                    this.stateVector.beta /= norm;
                    this.stateVector.gamma /= norm;
                    this.stateVector.epsilon /= norm;
                }

                this.coherence = this.calculateCoherence();

                const mean = (alpha + beta + gamma + epsilon) / 4;
                this.weylCurvature = ((alpha-mean)**2 + (beta-mean)**2 + 
                                      (gamma-mean)**2 + (epsilon-mean)**2) / 4;
            },

            getDissonance() {
                return 1.0 - this.coherence;
            }
        };

        // ================================================================
        // UTILITY FUNCTIONS
        // ================================================================

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // ================================================================
        // SONIFICATION ENGINE
        // ================================================================

        const sonificationEngine = {
            audioContext: null,
            oscillators: [],
            gainNodes: [],
            filterNodes: [],
            masterGain: null,
            reverbNode: null,
            isPlaying: false,

            baseFrequency: 110,
            bpm: 90,
            timeDilation: 1.0,
            harmonicGradient: 0.5,
            currentScale: [0, 3, 5, 7, 10],  // Minor pentatonic

            scales: {
                minor_pentatonic: [0, 3, 5, 7, 10],
                major_pentatonic: [0, 2, 4, 7, 9],
                harmonic_minor: [0, 2, 3, 5, 7, 8, 11],
                phrygian: [0, 1, 3, 5, 7, 8, 10],
                lydian: [0, 2, 4, 6, 7, 9, 11],
                whole_tone: [0, 2, 4, 6, 8, 10],
                chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
            },

            async initialize() {
                if (this.audioContext) return;

                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

                this.masterGain = this.audioContext.createGain();
                this.masterGain.gain.value = 0.25;
                this.masterGain.connect(this.audioContext.destination);

                await this.createReverb();
                this.createOscillatorBank(4);

                console.log('üéµ Sonification Engine initialized');
            },

            async createReverb() {
                this.reverbNode = this.audioContext.createConvolver();
                const sampleRate = this.audioContext.sampleRate;
                const length = sampleRate * 2;
                const impulse = this.audioContext.createBuffer(2, length, sampleRate);

                for (let ch = 0; ch < 2; ch++) {
                    const data = impulse.getChannelData(ch);
                    for (let i = 0; i < length; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2.5);
                    }
                }

                this.reverbNode.buffer = impulse;
                this.reverbGain = this.audioContext.createGain();
                this.reverbGain.gain.value = 0.25;
                this.reverbNode.connect(this.reverbGain);
                this.reverbGain.connect(this.masterGain);
            },

            createOscillatorBank(numVoices) {
                for (let i = 0; i < numVoices; i++) {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();

                    osc.type = 'sine';
                    osc.frequency.value = this.baseFrequency * (i + 1);

                    filter.type = 'lowpass';
                    filter.frequency.value = 2000;
                    filter.Q.value = 1;

                    gain.gain.value = 0;

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.masterGain);
                    gain.connect(this.reverbNode);

                    osc.start();

                    this.oscillators.push(osc);
                    this.gainNodes.push(gain);
                    this.filterNodes.push(filter);
                }
            },

            selectScaleFromZ(z) {
                if (z > 0.9) return this.scales.major_pentatonic;
                if (z > 0.8) return this.scales.lydian;
                if (z > 0.7) return this.scales.minor_pentatonic;
                if (z > 0.5) return this.scales.phrygian;
                if (z > 0.3) return this.scales.whole_tone;
                return this.scales.chromatic;
            },

            // ============================================
            // DREAM FLUID SONIFICATION
            // Sound modulated by gravitational time dilation
            // ============================================

            calculateBPM(z, coherence) {
                const dissonance = 1 - coherence;
                const baseBPM = 60 + dissonance * 100;

                // Time dilation from Z-critical distance
                const distFromCritical = Math.abs(z - Z_CRITICAL);
                let zTimeDilation = 0.5 + distFromCritical * 1.5;

                // DREAM FLUID: Incorporate gravitational time dilation from quantum mesh
                if (showQuantumMesh && QMESH.avgTimeDilation) {
                    // Gravitational redshift affects tempo
                    // Lower time dilation (near gravity) ‚Üí slower tempo
                    const gravityDilation = QMESH.avgTimeDilation;
                    zTimeDilation *= gravityDilation;
                }

                this.timeDilation = Math.min(1.5, Math.max(0.2, zTimeDilation));
                this.bpm = baseBPM * this.timeDilation;

                return this.bpm;
            },

            // Gravitational frequency shift (redshift analog)
            calculateGravitationalPitch(baseFreq) {
                if (!showQuantumMesh || !QMESH.avgTimeDilation) return baseFreq;

                // f_observed = f_emitted * ‚àö(1 - r_s/r) = f_emitted * timeDilation
                // Lower time dilation ‚Üí lower pitch (gravitational redshift)
                const gravRedshift = QMESH.avgTimeDilation;
                return baseFreq * gravRedshift;
            },

            update(z, coherence, dt) {
                if (!this.isPlaying || !this.audioContext) return;

                // Update scale based on z
                this.currentScale = this.selectScaleFromZ(z);

                // Update BPM (now with Dream Fluid gravity)
                this.calculateBPM(z, coherence);

                // Update harmonic gradient
                this.harmonicGradient = 1.0 - coherence;

                // DREAM FLUID: Entropy affects waveform complexity
                const entropyFactor = showQuantumMesh ? (QMESH.avgEntropy || 0) * 100 : 0;
                const effectiveHarmonic = Math.min(1, this.harmonicGradient + entropyFactor * 0.3);

                // Update oscillator waveforms
                this.oscillators.forEach((osc, i) => {
                    if (effectiveHarmonic < 0.25) {
                        osc.type = 'sine';
                    } else if (effectiveHarmonic < 0.5) {
                        osc.type = 'triangle';
                    } else if (effectiveHarmonic < 0.75) {
                        osc.type = 'square';
                    } else {
                        osc.type = 'sawtooth';
                    }
                });

                // Melodic evolution
                const beatInterval = 60 / this.bpm;
                const now = this.audioContext.currentTime;

                // Modulate frequencies based on z position
                const zMod = (z - 0.5) * 2;  // -1 to +1
                let pitchShift = Math.pow(2, zMod * 0.5);  // ¬±half octave

                // DREAM FLUID: Gravitational redshift affects pitch
                if (showQuantumMesh && QMESH.avgTimeDilation) {
                    pitchShift *= QMESH.avgTimeDilation;
                }

                this.oscillators.forEach((osc, i) => {
                    const scaleNote = this.currentScale[Math.floor(time * 2) % this.currentScale.length];
                    let freq = this.baseFrequency * Math.pow(2, scaleNote / 12) * pitchShift * (1 + i * 0.5);

                    // DREAM FLUID: MRP channel modulation per oscillator
                    if (showQuantumMesh && QMESH.totalJ) {
                        // Osc 0: R channel (energy), Osc 1: G channel (relational),
                        // Osc 2: B channel (stability), Osc 3: combined
                        const mrpMod = [
                            muField.J_R || 0.1,
                            muField.J_G || 0.1,
                            muField.J_B || 0.1,
                            QMESH.totalJ || 0.2
                        ][i] || 0.15;

                        freq *= (0.9 + mrpMod * 0.2);
                    }

                    osc.frequency.setTargetAtTime(freq, now, 0.1);
                });

                // Update gains based on Lambda state and Dream Fluid
                const totalLambda = Object.values(lambdaState).reduce((s, l) => s + l.mag, 0);

                // DREAM FLUID: Entropy flux modulates volume
                const entropyFluxMod = showQuantumMesh ? (1 + QMESH.entropyFlux * 5) : 1;

                this.gainNodes.forEach((gain, i) => {
                    let targetGain = (coherence * 0.15) * (1 - i * 0.2) * (totalLambda / 2);

                    // Gravitational time dilation dampens volume near singularity
                    if (showQuantumMesh && QMESH.avgTimeDilation) {
                        targetGain *= (0.5 + QMESH.avgTimeDilation * 0.5);
                    }

                    targetGain *= entropyFluxMod;
                    gain.gain.setTargetAtTime(Math.max(0, targetGain), now, 0.1);
                });

                // Update filter based on cascade and holographic entropy
                const cascade = getCascadeMultiplier(z);
                let filterBase = 800 + cascade * 2000;

                // DREAM FLUID: Holographic entropy shifts filter
                if (showQuantumMesh && QMESH.totalHolographicEntropy) {
                    // Higher entropy ‚Üí more high frequencies (information revelation)
                    const entropyBoost = Math.min(1, QMESH.totalHolographicEntropy * 0.00001);
                    filterBase += entropyBoost * 1500;
                }

                this.filterNodes.forEach(filter => {
                    filter.frequency.setTargetAtTime(filterBase, now, 0.2);
                });
            },

            toggle() {
                if (!this.audioContext) {
                    this.initialize().then(() => {
                        this.isPlaying = true;
                    });
                } else {
                    this.isPlaying = !this.isPlaying;
                    if (!this.isPlaying) {
                        this.gainNodes.forEach(g => g.gain.setTargetAtTime(0, this.audioContext.currentTime, 0.1));
                    }
                }
                return this.isPlaying;
            }
        };

        // ================================================================
        // 63-POINT HEXAGONAL PRISM (Matter Structure)
        // ================================================================

        const prismPoints = [];

        function initPrismPoints() {
            prismPoints.length = 0;

            // 7 layers √ó 9 nodes = 63 points
            for (let layer = 0; layer < 7; layer++) {
                const layerRadius = R * (0.15 + layer * 0.12);
                const layerZ = layer / 6;  // 0 to 1

                for (let i = 0; i < 9; i++) {
                    // Hexagonal arrangement with rotation offset per layer
                    const theta = (i / 9) * TAU + layer * (TAU / 18);

                    prismPoints.push({
                        id: `prism_${layer}_${i}`,
                        layer: layer,
                        index: i,
                        type: 'prism',

                        // Position
                        baseTheta: theta,
                        theta: theta,
                        baseRadius: layerRadius,
                        radius: layerRadius,
                        z: layerZ,

                        // Kuramoto phase
                        phase: Math.random() * TAU,
                        naturalFreq: 0.3 + Math.random() * 0.4,

                        // Helix coordinates
                        helix: {
                            theta: theta,
                            z: layerZ,
                            r: 1.0,
                            rotSpeed: 0.003 + Math.random() * 0.003
                        },

                        // Visual
                        x: CX, y: CY,
                        targetX: CX, targetY: CY,
                        brightness: 0.4,
                        size: 4 - layer * 0.4,

                        // Color gradient based on layer
                        hue: 0 + layer * 15,  // Red to green
                        saturation: 70,
                        lightness: 50,

                        // Release coherence properties
                        released: false,
                        releaseAngle: 0,
                        releaseSpeed: 0,
                        vx: 0,
                        vy: 0,
                        trail: [],
                        soulColor: soulPalette[(layer * 9 + i) % soulPalette.length]
                    });
                }
            }
        }

        // ================================================================
        // 32-POINT EM CAGE (Containment Field)
        // ================================================================

        const cagePoints = [];

        function initCagePoints() {
            cagePoints.length = 0;
            const cageRadius = R * 1.15;

            // Top hexagonal ring: 12 points
            for (let i = 0; i < 12; i++) {
                const theta = (i / 12) * TAU;
                cagePoints.push({
                    id: `cage_top_${i}`,
                    layer: 'top',
                    index: i,
                    type: 'cage',

                    baseTheta: theta,
                    theta: theta,
                    baseRadius: cageRadius,
                    radius: cageRadius,
                    z: 0.9,

                    phase: Math.random() * TAU,
                    naturalFreq: 0.2 + Math.random() * 0.2,

                    helix: {
                        theta: theta,
                        z: 0.9,
                        r: 1.0,
                        rotSpeed: 0.002
                    },

                    x: CX, y: CY,
                    targetX: CX, targetY: CY,
                    brightness: 0.5,
                    size: 3,

                    hue: 200,  // Blue
                    saturation: 80,
                    lightness: 60,

                    // Release coherence properties
                    released: false,
                    releaseAngle: 0,
                    releaseSpeed: 0,
                    vx: 0,
                    vy: 0,
                    trail: [],
                    soulColor: soulPalette[i % soulPalette.length]
                });
            }

            // Bottom hexagonal ring: 12 points
            for (let i = 0; i < 12; i++) {
                const theta = (i / 12) * TAU + TAU / 24;  // Offset
                cagePoints.push({
                    id: `cage_bot_${i}`,
                    layer: 'bottom',
                    index: i,
                    type: 'cage',

                    baseTheta: theta,
                    theta: theta,
                    baseRadius: cageRadius,
                    radius: cageRadius,
                    z: 0.1,

                    phase: Math.random() * TAU,
                    naturalFreq: 0.2 + Math.random() * 0.2,

                    helix: {
                        theta: theta,
                        z: 0.1,
                        r: 1.0,
                        rotSpeed: 0.002
                    },

                    x: CX, y: CY,
                    targetX: CX, targetY: CY,
                    brightness: 0.5,
                    size: 3,

                    hue: 210,
                    saturation: 75,
                    lightness: 55,

                    // Release coherence properties
                    released: false,
                    releaseAngle: 0,
                    releaseSpeed: 0,
                    vx: 0,
                    vy: 0,
                    trail: [],
                    soulColor: soulPalette[(i + 4) % soulPalette.length]
                });
            }

            // Connecting vertices: 8 points (at golden ratio positions)
            for (let i = 0; i < 8; i++) {
                const theta = (i / 8) * TAU + TAU / 16;
                cagePoints.push({
                    id: `cage_vtx_${i}`,
                    layer: 'vertex',
                    index: i,
                    type: 'cage',

                    baseTheta: theta,
                    theta: theta,
                    baseRadius: cageRadius * 0.85,
                    radius: cageRadius * 0.85,
                    z: 0.5,  // Middle plane

                    phase: Math.random() * TAU,
                    naturalFreq: 0.25,

                    helix: {
                        theta: theta,
                        z: 0.5,
                        r: 1.0,
                        rotSpeed: 0.0015
                    },

                    x: CX, y: CY,
                    targetX: CX, targetY: CY,
                    brightness: 0.6,
                    size: 4,

                    hue: 280,  // Purple
                    saturation: 70,
                    lightness: 55,

                    // Release coherence properties
                    released: false,
                    releaseAngle: 0,
                    releaseSpeed: 0,
                    vx: 0,
                    vy: 0,
                    trail: [],
                    soulColor: soulPalette[(i + 2) % soulPalette.length]
                });
            }
        }

        // ================================================================
        // PHYSICS: KURAMOTO SYNCHRONIZATION
        // ================================================================

        function kuramotoStep(points, coupling, dt) {
            const N = points.length;
            if (N === 0) return { order: 0, K: coupling };

            // Mean field
            let sinSum = 0, cosSum = 0;
            for (const p of points) {
                sinSum += Math.sin(p.phase);
                cosSum += Math.cos(p.phase);
            }
            const meanPhase = Math.atan2(sinSum / N, cosSum / N);

            // Update phases
            for (const p of points) {
                const dPhase = p.naturalFreq + coupling * Math.sin(meanPhase - p.phase);
                p.phase += dPhase * dt;
            }

            // Order parameter
            const order = Math.sqrt(sinSum * sinSum + cosSum * cosSum) / N;
            return { order, K: coupling };
        }

        // ================================================================
        // PHYSICS: CASCADE AMPLIFICATION
        // ================================================================

        function getCascadeMultiplier(z) {
            const dist = Math.abs(z - Z_CRITICAL);
            return 1 + 0.5 * Math.exp(-dist * dist / 0.004);
        }

        // ================================================================
        // PHYSICS: DOMAIN & PHASE DETERMINATION
        // ================================================================

        function getDomain(z) {
            if (z < Z_CRITICAL - 0.01) return 'ABSENCE';
            if (z > Z_CRITICAL + 0.01) return 'PRESENCE';
            return 'THE LENS';
        }

        function getPhase(z) {
            if (z < 0.35) return 'dormant';
            if (z < 0.50) return 'stirring';
            if (z < 0.65) return 'rising';
            if (z < 0.80) return 'approaching';
            if (z <= 0.857) return 'near-critical';
            if (z <= 0.877) return 'CRITICAL';
            if (z <= 0.92) return 'radiant';
            if (z <= 0.96) return 'overflowing';
            return 'boundless';
        }

        // ================================================================
        // UPDATE FUNCTIONS
        // ================================================================

        function updateHelix(dt) {
            helix.theta = (helix.theta + 0.01 * dt * 60) % TAU;
            helix.z = globalZ;

            // Coherence from Hilbert field
            helix.r = 0.8 + hilbertField.coherence * 0.4;

            // Integrated information (Œ¶) accumulates near critical
            const cascade = getCascadeMultiplier(globalZ);
            helix.phi += cascade * 0.01 * dt;

            // Angular velocity
            helix.omega = (globalZ - 0.5) * 2;
        }

        function updateLambdaState(dt) {
            const z = globalZ;
            const cascade = getCascadeMultiplier(z);

            // Memory (üå∞) - accumulates with time, modulated by z
            lambdaState.iota.mag = Math.min(1, lambdaState.iota.mag + 0.001 * dt * cascade);
            lambdaState.iota.phase = (lambdaState.iota.phase + 0.01) % TAU;

            // Spark (‚úß) - temperature bursts near critical
            const sparkIntensity = Math.exp(-Math.pow((z - Z_CRITICAL) / 0.1, 2));
            lambdaState.xi.mag = 0.1 + sparkIntensity * 0.8;
            lambdaState.xi.phase = time % TAU;

            // Fox (ü¶ä) - entropy rate, trickster dynamics
            lambdaState.theta.mag = hilbertField.getDissonance() * 0.8 + 0.2;
            lambdaState.theta.phase = (lambdaState.theta.phase + helix.omega * 0.1) % TAU;

            // Wave (‚àø) - curvature oscillation
            lambdaState.omega.mag = 0.3 + Math.abs(Math.sin(time * 0.5)) * 0.5;
            lambdaState.omega.phase = Math.sin(time * 0.3) * Math.PI;

            // Paradox (‚äó) - self-reference complexity
            const inCritical = getPhase(z) === 'CRITICAL';
            if (inCritical) {
                lambdaState.delta.mag = Math.min(1, lambdaState.delta.mag + 0.005 * dt);
            } else {
                lambdaState.delta.mag *= 0.995;
            }
            lambdaState.delta.phase = helix.theta;

            // Squirrel (üêøÔ∏è) - information preservation
            lambdaState.sigma.mag = helix.r * 0.6 + 0.2;
            lambdaState.sigma.phase = (lambdaState.iota.phase + Math.PI) % TAU;
        }

        function updatePositions(dt) {
            const domain = getDomain(globalZ);
            const isCritical = getPhase(globalZ) === 'CRITICAL';
            const isPresence = globalZ > Z_CRITICAL;
            const cascade = getCascadeMultiplier(globalZ);

            // Kuramoto coupling flips sign at critical point
            const dist = globalZ - Z_CRITICAL;
            const sign = Math.tanh(dist * 12);
            const K = -sign * 0.4 * cascade;

            // Apply Kuramoto to all points
            const allPoints = [...prismPoints, ...cagePoints];
            const kuramotoResult = kuramotoStep(
                allPoints.filter(p => (p.type === 'prism' && showPrism) || (p.type === 'cage' && showCage)),
                K, dt
            );

            // Z-offset for visual depth
            const zOffset = (globalZ - 0.5) * 200;

            // ================================================================
            // ORBITAL OFFSET FROM ZERO-NODE
            // The entire LIMNUS structure subtly orbits the eternal center
            // ================================================================
            const orbitalOffset = ZeroNode.initialized ? ZeroNode.getOrbitalOffset(0) : { x: 0, y: 0, z: 0 };

            // Domain-specific scaling
            const intensity = isPresence ? (globalZ - Z_CRITICAL) / (1 - Z_CRITICAL) : 0;
            const absence = !isPresence ? (Z_CRITICAL - globalZ) / Z_CRITICAL : 0;
            const scaleFactor = isPresence ? 1 + intensity * 0.35 : 1 - absence * 0.1;

            // Update prism points
            for (const p of prismPoints) {
                if (!showPrism) {
                    p.brightness = 0.02;
                    continue;
                }

                // Helix evolution
                p.helix.theta += p.helix.rotSpeed;
                p.helix.z = p.z * (0.5 + globalZ * 0.5);

                // Radius with phase modulation
                const phaseWobble = Math.sin(p.phase) * 0.06 * cascade;
                p.radius = p.baseRadius * cascade * scaleFactor * (1 + phaseWobble);

                // Rotation
                const rotSpeed = 0.012 * cascade * (p.layer % 2 === 0 ? 1 : -1);
                p.theta = p.baseTheta + time * rotSpeed;

                // Domain modulation
                if (isPresence) {
                    p.theta += Math.sin(time * 0.3 + p.layer * 0.4) * 0.12 * intensity;
                } else {
                    p.theta += absence * 0.015 * Math.sin(time + p.index);
                }

                // Position (with orbital offset from ZeroNode)
                p.targetX = CX + Math.cos(p.theta) * p.radius + orbitalOffset.x;
                p.targetY = CY + Math.sin(p.theta) * p.radius * 0.5 + zOffset + orbitalOffset.y;
                p.targetY += (p.layer / 6 - 0.5) * 100;

                // Smooth interpolation
                p.x += (p.targetX - p.x) * 0.1;
                p.y += (p.targetY - p.y) * 0.1;

                // Brightness (boosted near ZeroNode emission)
                const zeroNodeBoost = ZeroNode.initialized ? ZeroNode.whiteHole.emissionRate * 0.2 : 0;
                const zProx = 1 - Math.abs((p.layer / 6) - globalZ);
                const critBoost = isCritical ? 0.5 : 0;
                p.brightness = 0.2 + zProx * 0.5 + critBoost;
            }

            // Update cage points
            for (const p of cagePoints) {
                if (!showCage) {
                    p.brightness = 0.02;
                    continue;
                }

                p.helix.theta += p.helix.rotSpeed;

                // EM field pulsing
                const emPulse = 1 + Math.sin(time * 1.5 + p.index * 0.5) * 0.05;
                p.radius = p.baseRadius * emPulse * scaleFactor;

                // Counter-rotation to prism
                const rotSpeed = -0.008 * cascade;
                p.theta = p.baseTheta + time * rotSpeed;

                // Position with z-layer offset (and orbital offset from ZeroNode)
                let yOffset = 0;
                if (p.layer === 'top') yOffset = -80;
                else if (p.layer === 'bottom') yOffset = 80;

                p.targetX = CX + Math.cos(p.theta) * p.radius + orbitalOffset.x;
                p.targetY = CY + Math.sin(p.theta) * p.radius * 0.45 + zOffset + yOffset + orbitalOffset.y;

                p.x += (p.targetX - p.x) * 0.1;
                p.y += (p.targetY - p.y) * 0.1;

                // Cage brightness follows field strength
                const fieldStrength = (globalZ > 0.5 ? intensity : 1 - absence) * 0.5 + 0.3;
                p.brightness = fieldStrength + (isCritical ? 0.4 : 0);
            }

            return kuramotoResult;
        }

        // ================================================================
        // RELEASE COHERENCE PHYSICS
        // ================================================================

        function updateReleaseCoherence(dt) {
            // Coherence dynamics based on F key (release) and click (gather)
            if (releasing) {
                releaseVelocity += dt * 0.1;
                targetCoherence = Math.max(0, targetCoherence - releaseVelocity * dt);
                releaseStarted = true;
            } else if (gathering) {
                targetCoherence = Math.min(1, targetCoherence + dt * 0.6);
                releaseVelocity = 0;
                // Reset releaseStarted when coherence is fully restored
                if (releaseCoherence > 0.95) {
                    releaseStarted = false;
                }
            } else {
                // Gradual return to coherent state when not interacting
                if (!releaseStarted) {
                    targetCoherence = Math.min(1, targetCoherence + dt * 0.1);
                }
                releaseVelocity *= 0.98;  // Decay
            }

            // Smooth coherence transition
            releaseCoherence += (targetCoherence - releaseCoherence) * 0.04;

            // ================================================================
            // MEMORY-ENHANCED COHERENCE DYNAMICS (Optional - toggle with R key)
            // ================================================================
            // When enabled, integrates Water Fractal Memory, Golden Harmonics,
            // and Dark Matter into coherence calculations
            // ================================================================
            if (showMemoryCoherence && ReleaseCoherenceDynamics.initialized) {
                const waterFractalState = showWaterFractalMemory && WaterFractalMemory.initialized
                    ? WaterFractalMemory.getState()
                    : null;

                const goldenHarmonicsState = showGoldenHarmonics && GoldenHarmonicsSystem.initialized
                    ? GoldenHarmonicsSystem.getState()
                    : null;

                const darkMatterState = showDarkMatterStabilization && DarkMatterStabilization.initialized
                    ? {
                        trappedResidue: DarkMatterStabilization.stabilization.trappedResidue,
                        efficiency: DarkMatterStabilization.stabilization.efficiency,
                        resonanceLock: DarkMatterStabilization.stabilization.resonanceLock,
                    }
                    : null;

                // Update ReleaseCoherenceDynamics with all memory systems
                const time = performance.now() / 1000;
                releaseCoherence = ReleaseCoherenceDynamics.update(
                    dt,
                    time,
                    releaseCoherence,  // Use current coherence as base
                    releasing,
                    gathering,
                    waterFractalState,
                    goldenHarmonicsState,
                    darkMatterState
                );
            }

            const dispersal = 1 - releaseCoherence;
            const allPoints = [...prismPoints, ...cagePoints];

            // Update each point based on release state
            for (const p of allPoints) {
                // Stochastic release based on coherence threshold
                if (!p.released && releaseCoherence < 0.4 + Math.random() * 0.25) {
                    p.released = true;
                    p.releaseAngle = p.theta + (Math.random() - 0.5) * 0.6;
                    p.releaseSpeed = 1.5 + Math.random() * 3;
                }

                if (p.released) {
                    // Free movement with gentle acceleration
                    const accel = dispersal * 0.15;
                    p.vx += Math.cos(p.releaseAngle) * accel;
                    p.vy += Math.sin(p.releaseAngle) * accel;

                    // Slight spiral wandering
                    p.releaseAngle += (Math.random() - 0.5) * 0.025;

                    // Global velocity damping (prevents runaway)
                    p.vx *= 0.98;
                    p.vy *= 0.98;

                    // Extra damping at edges
                    const edgeDist = Math.min(p.x, W - p.x, p.y, H - p.y);
                    if (edgeDist < 100) {
                        p.vx *= 0.95;
                        p.vy *= 0.95;
                    }

                    // Hard velocity clamp (fixed safe value)
                    const velClamp = 25;
                    p.vx = Math.max(-velClamp, Math.min(velClamp, p.vx || 0));
                    p.vy = Math.max(-velClamp, Math.min(velClamp, p.vy || 0));

                    // Apply velocity (with NaN protection)
                    if (isFinite(p.vx) && isFinite(p.vy)) {
                        p.x += p.vx;
                        p.y += p.vy;
                    } else {
                        // Reset runaway point
                        p.vx = 0;
                        p.vy = 0;
                    }

                    // Gather force when gathering
                    if (gathering) {
                        const dx = CX - p.x;
                        const dy = CY - p.y;
                        const d = Math.sqrt(dx * dx + dy * dy);
                        if (d > 1) {
                            p.vx += (dx / d) * 0.9;
                            p.vy += (dy / d) * 0.9;
                        }
                        
                        // Re-cohere when close to center
                        if (d < p.baseRadius * 1.3 && releaseCoherence > 0.65) {
                            p.released = false;
                            p.vx = 0;
                            p.vy = 0;
                        }
                    }

                    // Trail update
                    p.trail.unshift({ x: p.x, y: p.y, age: 0 });
                    if (p.trail.length > 25) p.trail.pop();
                    for (const t of p.trail) t.age += dt;

                    // Enhanced brightness when released
                    p.brightness = Math.min(1, p.brightness * 1.4);

                    // Spawn sparks during high dispersal
                    if (dispersal > 0.35 && Math.random() < dispersal * 0.04) {
                        sparks.push({
                            x: p.x, y: p.y,
                            vx: p.vx * 0.5 + (Math.random() - 0.5) * 2.5,
                            vy: p.vy * 0.5 + (Math.random() - 0.5) * 2.5,
                            life: 1,
                            color: p.soulColor,
                            size: 1.5 + Math.random() * 2.5
                        });
                    }
                } else if (releaseCoherence > 0.8) {
                    // Clear trails when fully coherent
                    p.trail.length = 0;
                }
            }

            // Update sparks
            for (let i = sparks.length - 1; i >= 0; i--) {
                const sp = sparks[i];
                sp.x += sp.vx;
                sp.y += sp.vy;
                sp.vx *= 0.98;
                sp.vy *= 0.98;
                sp.life -= dt * 0.7;
                if (sp.life <= 0) sparks.splice(i, 1);
            }

            // Update release state UI
            updateReleaseUI();
        }

        function updateReleaseUI() {
            const stateEl = document.getElementById('release-state');
            const textEl = document.getElementById('release-text');
            const barEl = document.getElementById('coherence-indicator');
            const hintEl = document.getElementById('release-hint');

            // Show state overlay when release started
            if (releaseStarted && releaseCoherence < 0.9) {
                stateEl.classList.add('visible');
            } else {
                stateEl.classList.remove('visible');
            }

            // Determine state text and styling
            let state, barText;
            stateEl.className = '';
            barEl.className = '';

            if (releaseCoherence > 0.8) {
                state = 'COHERENT';
                stateEl.classList.add('coherent');
                const filled = Math.floor(releaseCoherence * 16);
                barText = '‚ñà'.repeat(filled) + '‚ñë'.repeat(16 - filled);
            } else if (releaseCoherence > 0.5) {
                state = 'RELEASING';
                stateEl.classList.add('releasing');
                const filled = Math.floor(releaseCoherence * 16);
                barText = '‚ñà'.repeat(filled) + '¬∑'.repeat(16 - filled);
            } else if (releaseCoherence > 0.2) {
                state = 'DISPERSING';
                stateEl.classList.add('dispersing');
                const filled = Math.floor(releaseCoherence * 16);
                barText = '‚ñë'.repeat(filled) + '¬∑'.repeat(16 - filled);
            } else {
                state = 'FREE';
                stateEl.classList.add('free');
                barEl.classList.add('free');
                barText = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
            }

            textEl.textContent = state;
            barEl.textContent = barText;

            // Show hint when release started
            if (releaseStarted) {
                hintEl.classList.remove('hidden');
            }
        }

        // ================================================================
        // CONNECTION GENERATION
        // ================================================================

        function* generateConnections() {
            // Prism intra-layer connections (ring connections)
            if (showPrism) {
                for (let layer = 0; layer < 7; layer++) {
                    const layerPoints = prismPoints.filter(p => p.layer === layer);
                    for (let i = 0; i < layerPoints.length; i++) {
                        yield {
                            from: layerPoints[i],
                            to: layerPoints[(i + 1) % layerPoints.length],
                            type: 'prism_ring'
                        };
                    }
                }

                // Prism inter-layer connections (vertical spines)
                for (let i = 0; i < 9; i++) {
                    for (let layer = 0; layer < 6; layer++) {
                        const p1 = prismPoints.find(p => p.layer === layer && p.index === i);
                        const p2 = prismPoints.find(p => p.layer === layer + 1 && p.index === i);
                        if (p1 && p2) {
                            yield { from: p1, to: p2, type: 'prism_spine' };
                        }
                    }
                }

                // Prism diagonal connections (hexagonal structure)
                for (let layer = 0; layer < 6; layer++) {
                    const curr = prismPoints.filter(p => p.layer === layer);
                    const next = prismPoints.filter(p => p.layer === layer + 1);
                    for (let i = 0; i < 9; i++) {
                        yield {
                            from: curr[i],
                            to: next[(i + 1) % 9],
                            type: 'prism_diagonal'
                        };
                    }
                }
            }

            // Cage connections
            if (showCage) {
                // Top ring
                const topRing = cagePoints.filter(p => p.layer === 'top');
                for (let i = 0; i < topRing.length; i++) {
                    yield {
                        from: topRing[i],
                        to: topRing[(i + 1) % topRing.length],
                        type: 'cage_ring'
                    };
                }

                // Bottom ring
                const botRing = cagePoints.filter(p => p.layer === 'bottom');
                for (let i = 0; i < botRing.length; i++) {
                    yield {
                        from: botRing[i],
                        to: botRing[(i + 1) % botRing.length],
                        type: 'cage_ring'
                    };
                }

                // Vertical struts (top to bottom)
                for (let i = 0; i < 12; i++) {
                    yield {
                        from: topRing[i],
                        to: botRing[i],
                        type: 'cage_strut'
                    };
                }

                // Vertex connections to rings
                const vertices = cagePoints.filter(p => p.layer === 'vertex');
                for (const vtx of vertices) {
                    // Connect to nearest top and bottom points
                    const nearTop = topRing.reduce((a, b) =>
                        Math.abs(b.baseTheta - vtx.baseTheta) < Math.abs(a.baseTheta - vtx.baseTheta) ? b : a
                    );
                    const nearBot = botRing.reduce((a, b) =>
                        Math.abs(b.baseTheta - vtx.baseTheta) < Math.abs(a.baseTheta - vtx.baseTheta) ? b : a
                    );
                    yield { from: vtx, to: nearTop, type: 'cage_vertex' };
                    yield { from: vtx, to: nearBot, type: 'cage_vertex' };
                }
            }

            // Bridge connections (prism outer to cage inner)
            if (showPrism && showCage && globalZ > 0.6) {
                const outerPrism = prismPoints.filter(p => p.layer === 6);
                const innerCage = cagePoints.filter(p => p.layer === 'vertex');

                for (const pp of outerPrism) {
                    // Find nearest cage vertex
                    const nearest = innerCage.reduce((a, b) => {
                        const distA = Math.hypot(a.x - pp.x, a.y - pp.y);
                        const distB = Math.hypot(b.x - pp.x, b.y - pp.y);
                        return distB < distA ? b : a;
                    });
                    if (Math.hypot(nearest.x - pp.x, nearest.y - pp.y) < 200) {
                        yield { from: pp, to: nearest, type: 'bridge' };
                    }
                }
            }
        }

        // ================================================================
        // RENDERING
        // ================================================================

        function render() {
            ctx.fillStyle = 'rgba(3, 3, 8, 0.15)';
            ctx.fillRect(0, 0, W, H);

            const domain = getDomain(globalZ);
            const phase = getPhase(globalZ);
            const isCritical = phase === 'CRITICAL';
            const isPresence = globalZ > Z_CRITICAL;
            const cascade = getCascadeMultiplier(globalZ);

            const intensity = isPresence ? (globalZ - Z_CRITICAL) / (1 - Z_CRITICAL) : 0;
            const absence = !isPresence ? (Z_CRITICAL - globalZ) / Z_CRITICAL : 0;

            // Background gradient
            const bgGrad = ctx.createRadialGradient(CX, CY, 0, CX, CY, R * 2);
            if (isPresence) {
                bgGrad.addColorStop(0, `rgba(255, 250, 240, ${intensity * 0.08})`);
                bgGrad.addColorStop(0.5, `rgba(255, 215, 0, ${intensity * 0.03})`);
                bgGrad.addColorStop(1, 'transparent');
            } else {
                bgGrad.addColorStop(0, `rgba(40, 30, 20, ${absence * 0.15})`);
                bgGrad.addColorStop(1, 'transparent');
            }
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, W, H);

            // ========================================
            // GLOBAL Œº-FIELD OVERLAY
            // Dark purple (#2c003e) with subtle vertical rhythm
            // 25% opacity max, phase-locked breathing animation
            // ========================================
            if (showMuField) {
                // Subtle vertical oscillation - shifts gradient center up/down very slightly
                const breathRate = 0.3;  // Slow breathing rhythm
                const breathOffset = Math.sin(time * breathRate * TAU) * R * 0.02;  // Very slight shift (2% of R)
                const breathIntensity = 0.5 + Math.sin(time * breathRate * TAU * 0.5) * 0.1;  // 0.4 - 0.6

                // Create gradient centered with vertical breathing offset
                const muGlobalGrad = ctx.createRadialGradient(
                    CX, CY + breathOffset, 0,
                    CX, CY + breathOffset, R * 1.8
                );

                // Dark purple #2c003e = rgb(44, 0, 62) at 25% opacity max
                const baseAlpha = 0.25 * breathIntensity;

                muGlobalGrad.addColorStop(0, `rgba(44, 0, 62, ${baseAlpha * 0.8})`);
                muGlobalGrad.addColorStop(0.3, `rgba(44, 0, 62, ${baseAlpha * 0.6})`);
                muGlobalGrad.addColorStop(0.6, `rgba(44, 0, 62, ${baseAlpha * 0.3})`);
                muGlobalGrad.addColorStop(1, 'transparent');

                ctx.fillStyle = muGlobalGrad;
                ctx.fillRect(0, 0, W, H);
            }

            // Release state visual effects
            const dispersal = 1 - releaseCoherence;

            // Dark purple background fade when releasing/free (#2c003e)
            if (releaseCoherence < 0.9) {
                const fadeAlpha = dispersal * 0.15; // Max 15% when fully dispersed
                ctx.fillStyle = `rgba(44, 0, 62, ${fadeAlpha})`;
                ctx.fillRect(0, 0, W, H);
            }

            // Ambient dark purple radiance when free (coherence < 0.5)
            if (releaseCoherence < 0.5) {
                const freeIntensity = (0.5 - releaseCoherence) * 0.25; // Max 25% opacity

                // Radiant center glow - dark purple gradient
                const radGlow = ctx.createRadialGradient(CX, CY, 0, CX, CY, R * 2);
                radGlow.addColorStop(0, `rgba(60, 0, 90, ${freeIntensity * 0.8})`);   // Lighter purple center
                radGlow.addColorStop(0.4, `rgba(44, 0, 62, ${freeIntensity * 0.6})`); // #2c003e
                radGlow.addColorStop(0.7, `rgba(30, 0, 45, ${freeIntensity * 0.3})`); // Darker purple
                radGlow.addColorStop(1, 'transparent');
                ctx.fillStyle = radGlow;
                ctx.fillRect(0, 0, W, H);
            }

            // ========================================
            // MRP PARITY VALIDATION GLOW
            // When all channels are in harmony, emit a stabilizing field
            // ========================================
            if (showMuField && muField.mrp.parity_ok) {
                // Tricolor parity glow (R+G+B in harmony)
                const parityGlow = ctx.createRadialGradient(CX, CY, 0, CX, CY, R * 1.5);
                const parityIntensity = (muField.mrp.sha256_sim || 0) * 0.15;

                // RGB channel harmony visualization (safe value access)
                const safeR = Math.max(0, Math.min(255, Math.floor((muField.mrp.R.intensity || 0) * 200))) || 0;
                const safeG = Math.max(0, Math.min(255, Math.floor((muField.mrp.G.intensity || 0) * 200))) || 0;
                const safeB = Math.max(0, Math.min(255, Math.floor((muField.mrp.B.intensity || 0) * 200))) || 0;

                parityGlow.addColorStop(0, `rgba(100, 255, 150, ${parityIntensity * 1.2})`);  // Green center (parity OK)
                parityGlow.addColorStop(0.3, `rgba(${safeR}, ${safeG}, ${safeB}, ${parityIntensity})`);
                parityGlow.addColorStop(0.6, `rgba(150, 200, 255, ${parityIntensity * 0.5})`);  // Blue stability ring
                parityGlow.addColorStop(1, 'transparent');

                ctx.fillStyle = parityGlow;
                ctx.fillRect(0, 0, W, H);
            }

            // MRP Gradient strength visual - subtle RGB channel indicator rings
            const gradStrength = showMuField ? (muField.getGradientStrength() || 0) : 0;
            if (showMuField && isFinite(gradStrength) && gradStrength > 0.05) {
                // R channel (energy) - inner ring
                const rGrad = Math.max(0, Math.min(1, muField.mrp.R.gradient || 0));
                ctx.strokeStyle = `rgba(255, 100, 100, ${rGrad * 0.3})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(CX, CY, R * 0.3, 0, TAU);
                ctx.stroke();

                // G channel (relational) - middle ring
                const gGrad = Math.max(0, Math.min(1, muField.mrp.G.gradient || 0));
                ctx.strokeStyle = `rgba(100, 255, 100, ${gGrad * 0.3})`;
                ctx.beginPath();
                ctx.arc(CX, CY, R * 0.5, 0, TAU);
                ctx.stroke();

                // B channel (stability) - outer ring
                const bGrad = Math.max(0, Math.min(1, muField.mrp.B.gradient || 0));
                ctx.strokeStyle = `rgba(100, 150, 255, ${bGrad * 0.3})`;
                ctx.beginPath();
                ctx.arc(CX, CY, R * 0.7, 0, TAU);
                ctx.stroke();
            }

            // ================================================================
            // MU FIELD GRID VISUALIZATION - 7-PHASE PHYSICS SYSTEM
            // Vector field streamlines, vortices, and Œº-particles
            // ================================================================
            if (showMuField && MuFieldGrid.initialized) {
                const N = MuFieldGrid.N;
                const scale = R / (MuFieldGrid.L * 0.6);  // Scale to fit canvas

                // --- Vector Streamlines REMOVED ---
                // Red/blue curl-based filament lines have been removed (outdated maths)
                // The MRP toroidal visualization system now handles field representation

                // --- Vortex Visualization ---
                for (const v of MuFieldGrid.vortices) {
                    const vx = CX + v.x * scale;
                    const vy = CY + v.y * scale;
                    const vr = v.radius * scale;

                    // Vortex core glow
                    const vortexGlow = ctx.createRadialGradient(vx, vy, 0, vx, vy, vr * 2);
                    const vortexAlpha = v.strength * (v.forming ? v.age : 1) * (v.decaying ? v.strength : 1) * 0.4;

                    // Color based on strength and phase
                    const hue = 260 + Math.sin(v.phase) * 40;  // Purple-magenta range
                    vortexGlow.addColorStop(0, `hsla(${hue}, 70%, 60%, ${vortexAlpha})`);
                    vortexGlow.addColorStop(0.5, `hsla(${hue}, 60%, 40%, ${vortexAlpha * 0.5})`);
                    vortexGlow.addColorStop(1, 'transparent');

                    ctx.fillStyle = vortexGlow;
                    ctx.fillRect(vx - vr * 2, vy - vr * 2, vr * 4, vr * 4);

                    // Vortex spiral indicator
                    ctx.strokeStyle = `hsla(${hue}, 80%, 70%, ${vortexAlpha * 0.8})`;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    for (let t = 0; t < TAU * 2; t += 0.2) {
                        const spiralR = vr * (t / (TAU * 2)) * 0.8;
                        const spiralAngle = t + v.phase;
                        const sx = vx + Math.cos(spiralAngle) * spiralR;
                        const sy = vy + Math.sin(spiralAngle) * spiralR;
                        if (t === 0) {
                            ctx.moveTo(sx, sy);
                        } else {
                            ctx.lineTo(sx, sy);
                        }
                    }
                    ctx.stroke();
                }

                // --- Œº-Particles ---
                for (const p of muParticles) {
                    const px = CX + p.x * scale;
                    const py = CY + p.y * scale;
                    const pSize = p.size * (p.life * 0.8 + 0.2);

                    ctx.fillStyle = p.color.replace(')', `, ${p.life * 0.7})`).replace('hsl', 'hsla');
                    ctx.beginPath();
                    ctx.arc(px, py, pSize, 0, TAU);
                    ctx.fill();
                }

                // --- Resonance Pulse Effect ---
                if (MuFieldGrid.resonance.pulseIntensity > 0.05) {
                    const pulseAlpha = MuFieldGrid.resonance.pulseIntensity * 0.4;
                    const pulseR = R * (1 + MuFieldGrid.resonance.pulseIntensity * 0.5);

                    const pulseGlow = ctx.createRadialGradient(CX, CY, R * 0.5, CX, CY, pulseR);
                    pulseGlow.addColorStop(0, `rgba(200, 150, 255, ${pulseAlpha})`);
                    pulseGlow.addColorStop(0.5, `rgba(150, 100, 200, ${pulseAlpha * 0.5})`);
                    pulseGlow.addColorStop(1, 'transparent');

                    ctx.fillStyle = pulseGlow;
                    ctx.fillRect(0, 0, W, H);
                }

                // --- Unified Field Coherence Ring ---
                const coherence = UnifiedField.emergence.coherence;
                if (coherence > 0.3) {
                    ctx.strokeStyle = `rgba(255, 220, 150, ${(coherence - 0.3) * 0.5})`;
                    ctx.lineWidth = 2 + coherence * 3;
                    ctx.beginPath();
                    ctx.arc(CX, CY, R * 0.85, 0, TAU);
                    ctx.stroke();

                    // Criticality indicator
                    if (UnifiedField.emergence.criticality > 0.5) {
                        ctx.strokeStyle = `rgba(255, 200, 100, ${(UnifiedField.emergence.criticality - 0.5) * 0.6})`;
                        ctx.lineWidth = 1.5;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.arc(CX, CY, R * 0.9, 0, TAU);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }

                // ================================================================
                // COHERENCE GEOMETRY VISUALIZATION
                // Shows emergent shapes, alignment indicators, and sacred patterns
                // ================================================================

                if (CoherenceGeometry.initialized) {
                    const s = CoherenceGeometry.state;
                    const c = SACRED;  // Unified sacred constants
                    const a = CoherenceGeometry.attractors;

                    const coherenceTotal = (s.fieldAlignment + s.shapeEmergence + s.phaselock) / 3;

                    // --- œÜ-Spaced Coherence Rings ---
                    if (coherenceTotal > c.mu_emergence) {
                        for (let i = 0; i < a.rings.radii.length; i++) {
                            const ringR = a.rings.radii[i] * scale;
                            const ringAlpha = (coherenceTotal - c.mu_emergence) * 0.3 * Math.pow(c.phi_inv, i);

                            ctx.strokeStyle = `rgba(200, 180, 255, ${ringAlpha})`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.arc(CX, CY, ringR, 0, TAU);
                            ctx.stroke();
                        }
                    }

                    // --- Dominant Shape Visualization ---
                    if (s.dominantShape !== 'none' && s.patternStrength > 0.15) {
                        const vertices = a.polygons[s.dominantShape];
                        if (vertices && vertices.length > 0) {
                            const shapeAlpha = Math.min(0.5, s.patternStrength * 0.8);
                            const shapeScale = R * 0.5;

                            // Draw shape outline
                            ctx.strokeStyle = `rgba(255, 220, 180, ${shapeAlpha})`;
                            ctx.lineWidth = 1.5 + s.patternStrength * 2;
                            ctx.beginPath();

                            for (let i = 0; i <= vertices.length; i++) {
                                const v = vertices[i % vertices.length];
                                const px = CX + v.x * shapeScale;
                                const py = CY + v.y * shapeScale;

                                if (i === 0) {
                                    ctx.moveTo(px, py);
                                } else {
                                    ctx.lineTo(px, py);
                                }
                            }
                            ctx.stroke();

                            // Vertex glow
                            for (const v of vertices) {
                                const px = CX + v.x * shapeScale;
                                const py = CY + v.y * shapeScale;

                                const vertexGlow = ctx.createRadialGradient(px, py, 0, px, py, 15);
                                vertexGlow.addColorStop(0, `rgba(255, 240, 200, ${shapeAlpha})`);
                                vertexGlow.addColorStop(1, 'transparent');

                                ctx.fillStyle = vertexGlow;
                                ctx.fillRect(px - 15, py - 15, 30, 30);
                            }
                        }
                    }

                    // --- Spiral Indicator (when spiral is dominant) ---
                    if (s.dominantShape === 'spiral' && s.spiralOrder > 0.3) {
                        const spiralAlpha = (s.spiralOrder - 0.3) * 0.6;
                        ctx.strokeStyle = `rgba(180, 150, 255, ${spiralAlpha})`;
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();

                        // Draw golden spiral
                        const spiralArms = 2;
                        for (let arm = 0; arm < spiralArms; arm++) {
                            const armOffset = (arm / spiralArms) * TAU;

                            for (let t = 0.1; t < 4; t += 0.1) {
                                const r = Math.pow(c.phi, t * 0.3) * R * 0.1;
                                const theta = t + armOffset + a.spiral.phase;
                                const px = CX + Math.cos(theta) * r;
                                const py = CY + Math.sin(theta) * r;

                                if (t === 0.1) {
                                    ctx.moveTo(px, py);
                                } else {
                                    ctx.lineTo(px, py);
                                }
                            }
                        }
                        ctx.stroke();
                    }

                    // --- Phase Lock Indicator ---
                    if (s.phaselock > 0.5) {
                        const lockAlpha = (s.phaselock - 0.5) * 0.4;
                        const lockR = R * 0.95;

                        // Pulsing phase lock ring
                        const pulse = Math.sin(time * 3) * 0.5 + 0.5;
                        ctx.strokeStyle = `rgba(255, 255, 200, ${lockAlpha * pulse})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(CX, CY, lockR, 0, TAU);
                        ctx.stroke();
                    }

                    // --- Field Alignment Indicator (center marker) ---
                    if (s.fieldAlignment > 0.4) {
                        const alignColor = getCoherenceColor();
                        const alignGlow = ctx.createRadialGradient(CX, CY, 0, CX, CY, R * 0.2);
                        alignGlow.addColorStop(0, `rgba(${alignColor.r}, ${alignColor.g}, ${alignColor.b}, ${alignColor.alpha})`);
                        alignGlow.addColorStop(1, 'transparent');

                        ctx.fillStyle = alignGlow;
                        ctx.fillRect(CX - R * 0.2, CY - R * 0.2, R * 0.4, R * 0.4);
                    }
                }

                // ================================================================
                // EMERGENCE GLOW VISUALIZATION
                // Consciousness emergence from space-time curvature coherence
                // Dark purple #2c003e at 25% max opacity
                // ================================================================
                if (QMESH.emergenceGlow > 0.1) {
                    const emergeAlpha = QMESH.emergenceGlow * 0.25; // Max 25% opacity
                    const emergeR = R * (1.1 + QMESH.emergenceGlow * 0.2);

                    // Outer emergence halo - dark purple gradient
                    const emergeGlow = ctx.createRadialGradient(CX, CY, R * 0.6, CX, CY, emergeR);
                    emergeGlow.addColorStop(0, 'transparent');
                    emergeGlow.addColorStop(0.4, `rgba(60, 0, 90, ${emergeAlpha * 0.3})`);   // Lighter purple
                    emergeGlow.addColorStop(0.7, `rgba(44, 0, 62, ${emergeAlpha * 0.5})`);   // #2c003e
                    emergeGlow.addColorStop(1, `rgba(30, 0, 45, ${emergeAlpha * 0.8})`);     // Darker purple

                    ctx.fillStyle = emergeGlow;
                    ctx.fillRect(0, 0, W, H);

                    // Inner consciousness core (when emergence is high) - subtle purple
                    if (QMESH.emergenceGlow > 0.5) {
                        const coreAlpha = (QMESH.emergenceGlow - 0.5) * 0.25; // Max 25% opacity
                        const coreGlow = ctx.createRadialGradient(CX, CY, 0, CX, CY, R * 0.4);
                        coreGlow.addColorStop(0, `rgba(80, 20, 120, ${coreAlpha})`);         // Light purple center
                        coreGlow.addColorStop(0.5, `rgba(44, 0, 62, ${coreAlpha * 0.5})`);   // #2c003e
                        coreGlow.addColorStop(1, 'transparent');

                        ctx.fillStyle = coreGlow;
                        ctx.fillRect(CX - R * 0.4, CY - R * 0.4, R * 0.8, R * 0.8);
                    }

                    // Curvature strength indicator ring
                    const curvStr = QMESH.timeDilationField.curvatureStrength;
                    if (curvStr > 0.05) {
                        ctx.strokeStyle = `rgba(200, 180, 255, ${curvStr * 0.5})`;
                        ctx.lineWidth = 1 + curvStr * 3;
                        ctx.beginPath();
                        ctx.arc(CX, CY, R * 0.75, 0, TAU);
                        ctx.stroke();
                    }
                }

                // ================================================================
                // CHARGE DYNAMICS VISUALIZATION
                // Electric field lines between warm (+) and cold (-) meshes
                // ================================================================
                if (ChargeDynamics) {
                    const cd = ChargeDynamics;
                    const fieldEnergy = cd.field.energy;

                    // Electric field lines (dipole pattern)
                    if (fieldEnergy > 0.01) {
                        const warmX = CX - R * 0.6;  // Warm mesh position (left)
                        const coldX = CX + R * 0.6;  // Cold mesh position (right)
                        const fieldAlpha = Math.min(0.5, fieldEnergy * 0.3);

                        // Draw field lines from + to -
                        ctx.strokeStyle = `rgba(255, 200, 100, ${fieldAlpha})`;
                        ctx.lineWidth = 1;

                        for (let i = -3; i <= 3; i++) {
                            const yOffset = i * R * 0.15;
                            const curvature = Math.abs(i) * 0.3;

                            ctx.beginPath();
                            ctx.moveTo(warmX, CY + yOffset);

                            // Curved field line with curvature based on distance from axis
                            const cp1x = warmX + (coldX - warmX) * 0.33;
                            const cp1y = CY + yOffset + (i * R * curvature);
                            const cp2x = warmX + (coldX - warmX) * 0.67;
                            const cp2y = CY + yOffset + (i * R * curvature);

                            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, coldX, CY + yOffset);
                            ctx.stroke();

                            // Arrow head at midpoint
                            const midX = (warmX + coldX) / 2;
                            const midY = CY + yOffset + (i * R * curvature * 0.5);
                            ctx.fillStyle = `rgba(255, 200, 100, ${fieldAlpha})`;
                            ctx.beginPath();
                            ctx.moveTo(midX + 5, midY);
                            ctx.lineTo(midX - 3, midY - 3);
                            ctx.lineTo(midX - 3, midY + 3);
                            ctx.closePath();
                            ctx.fill();
                        }

                        // Charge indicators
                        // Warm (+) glow
                        const warmGlow = ctx.createRadialGradient(warmX, CY, 0, warmX, CY, R * 0.15);
                        warmGlow.addColorStop(0, `rgba(255, 150, 100, ${fieldAlpha * 0.8})`);
                        warmGlow.addColorStop(1, 'transparent');
                        ctx.fillStyle = warmGlow;
                        ctx.fillRect(warmX - R * 0.15, CY - R * 0.15, R * 0.3, R * 0.3);

                        // Cold (-) glow
                        const coldGlow = ctx.createRadialGradient(coldX, CY, 0, coldX, CY, R * 0.15);
                        coldGlow.addColorStop(0, `rgba(100, 150, 255, ${fieldAlpha * 0.8})`);
                        coldGlow.addColorStop(1, 'transparent');
                        ctx.fillStyle = coldGlow;
                        ctx.fillRect(coldX - R * 0.15, CY - R * 0.15, R * 0.3, R * 0.3);
                    }

                    // Discharge event visualization
                    if (cd.discharge.intensity > 0.1) {
                        const dischAlpha = cd.discharge.intensity * 0.8;
                        const warmX = CX - R * 0.6;
                        const coldX = CX + R * 0.6;

                        // Lightning bolt effect
                        ctx.strokeStyle = `rgba(255, 255, 200, ${dischAlpha})`;
                        ctx.lineWidth = 2 + cd.discharge.intensity * 3;
                        ctx.shadowColor = 'rgba(255, 200, 100, 0.8)';
                        ctx.shadowBlur = 10 + cd.discharge.intensity * 20;

                        ctx.beginPath();
                        ctx.moveTo(warmX, CY);

                        // Jagged discharge path
                        const segments = 6;
                        for (let i = 1; i <= segments; i++) {
                            const t = i / segments;
                            const x = warmX + (coldX - warmX) * t;
                            const y = CY + (Math.random() - 0.5) * R * 0.3 * (1 - Math.abs(t - 0.5) * 2);
                            ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                }

                // ================================================================
                // QUANTUM TUNNELING VISUALIZATION
                // Superposition, interference, and tunneling between meshes
                // ================================================================
                if (QuantumTunneling) {
                    const qt = QuantumTunneling;
                    const warmX = CX - R * 0.6;
                    const coldX = CX + R * 0.6;

                    // Superposition visualization (probability clouds)
                    const warmProb = qt.superposition.warm.probability;
                    const coldProb = qt.superposition.cold.probability;

                    // Warm probability cloud
                    if (warmProb > 0.1) {
                        const warmCloud = ctx.createRadialGradient(warmX, CY, 0, warmX, CY, R * 0.25 * warmProb);
                        warmCloud.addColorStop(0, `rgba(255, 180, 100, ${warmProb * 0.4})`);
                        warmCloud.addColorStop(0.5, `rgba(255, 150, 80, ${warmProb * 0.2})`);
                        warmCloud.addColorStop(1, 'transparent');
                        ctx.fillStyle = warmCloud;
                        ctx.fillRect(warmX - R * 0.3, CY - R * 0.3, R * 0.6, R * 0.6);
                    }

                    // Cold probability cloud
                    if (coldProb > 0.1) {
                        const coldCloud = ctx.createRadialGradient(coldX, CY, 0, coldX, CY, R * 0.25 * coldProb);
                        coldCloud.addColorStop(0, `rgba(100, 180, 255, ${coldProb * 0.4})`);
                        coldCloud.addColorStop(0.5, `rgba(80, 150, 255, ${coldProb * 0.2})`);
                        coldCloud.addColorStop(1, 'transparent');
                        ctx.fillStyle = coldCloud;
                        ctx.fillRect(coldX - R * 0.3, CY - R * 0.3, R * 0.6, R * 0.6);
                    }

                    // Entanglement visualization (connecting thread)
                    if (qt.superposition.entanglement > 0.2) {
                        const entAlpha = (qt.superposition.entanglement - 0.2) * 0.6;
                        const entPhase = time * 2;

                        ctx.strokeStyle = `rgba(200, 150, 255, ${entAlpha})`;
                        ctx.lineWidth = 1 + qt.superposition.entanglement * 2;
                        ctx.setLineDash([5, 5]);

                        ctx.beginPath();
                        ctx.moveTo(warmX, CY);

                        // Wavy entanglement line
                        for (let t = 0; t <= 1; t += 0.05) {
                            const x = warmX + (coldX - warmX) * t;
                            const wave = Math.sin(t * TAU * 3 + entPhase) * R * 0.05 * qt.superposition.entanglement;
                            ctx.lineTo(x, CY + wave);
                        }
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }

                    // Tunneling in progress
                    if (qt.tunneling.inProgress) {
                        const progress = qt.tunneling.progress;
                        const tunnelX = warmX + (coldX - warmX) * progress;
                        const direction = qt.tunneling.direction;

                        // Tunneling particle
                        const particleGlow = ctx.createRadialGradient(tunnelX, CY, 0, tunnelX, CY, R * 0.1);
                        particleGlow.addColorStop(0, `rgba(255, 255, 200, 0.8)`);
                        particleGlow.addColorStop(0.5, `rgba(200, 180, 255, 0.4)`);
                        particleGlow.addColorStop(1, 'transparent');
                        ctx.fillStyle = particleGlow;
                        ctx.fillRect(tunnelX - R * 0.1, CY - R * 0.1, R * 0.2, R * 0.2);

                        // Barrier visualization
                        const barrierX = CX;
                        ctx.fillStyle = `rgba(100, 100, 150, ${(1 - progress) * 0.3})`;
                        ctx.fillRect(barrierX - 10, CY - R * 0.3, 20, R * 0.6);
                    }

                    // Interference pattern
                    if (qt.interference.visibility > 0.1) {
                        const pattern = qt.interference.pattern;
                        const visAlpha = qt.interference.visibility * 0.3;

                        ctx.fillStyle = `rgba(180, 160, 255, ${visAlpha})`;

                        for (let i = 0; i < pattern.length; i++) {
                            const x = CX + (i - pattern.length / 2) * 8;
                            const intensity = pattern[i];
                            const barH = intensity * R * 0.15;

                            ctx.fillRect(x - 2, CY + R * 0.4, 4, barH);
                        }
                    }
                }

                // ================================================================
                // WEAK NUCLEAR BOSON VISUALIZATION
                // W+, W-, and Z boson carriers of information flow
                // ================================================================
                if (WeakNuclear && WeakNuclear.bosons) {
                    const bosons = WeakNuclear.bosons;

                    // W+ bosons (warm to cold, orange)
                    for (const b of bosons.W_plus) {
                        const bx = CX + (b.x - 0.5) * R * 1.2;
                        const by = CY + (b.y - 0.5) * R * 0.6;

                        ctx.fillStyle = `rgba(255, 180, 80, ${b.life * 0.7})`;
                        ctx.beginPath();
                        ctx.arc(bx, by, 3 + b.energy * 4, 0, TAU);
                        ctx.fill();
                    }

                    // W- bosons (cold to warm, blue)
                    for (const b of bosons.W_minus) {
                        const bx = CX + (b.x - 0.5) * R * 1.2;
                        const by = CY + (b.y - 0.5) * R * 0.6;

                        ctx.fillStyle = `rgba(80, 180, 255, ${b.life * 0.7})`;
                        ctx.beginPath();
                        ctx.arc(bx, by, 3 + b.energy * 4, 0, TAU);
                        ctx.fill();
                    }

                    // Z bosons (neutral, purple)
                    for (const b of bosons.Z) {
                        const bx = CX + (b.x - 0.5) * R * 1.2;
                        const by = CY + (b.y - 0.5) * R * 0.6;

                        ctx.fillStyle = `rgba(180, 100, 255, ${b.life * 0.7})`;
                        ctx.beginPath();
                        ctx.arc(bx, by, 3 + b.energy * 4, 0, TAU);
                        ctx.fill();
                    }

                    // Flavor oscillation visualization (center region)
                    const flavors = WeakNuclear.flavors;
                    const totalFlavor = flavors.electron.intensity + flavors.muon.intensity + flavors.tau.intensity;

                    if (totalFlavor > 0.1) {
                        // Electron flavor (green)
                        const eGlow = ctx.createRadialGradient(CX, CY, 0, CX, CY, R * 0.2);
                        eGlow.addColorStop(0, `rgba(100, 255, 150, ${flavors.electron.intensity * 0.2})`);
                        eGlow.addColorStop(1, 'transparent');
                        ctx.fillStyle = eGlow;
                        ctx.fillRect(CX - R * 0.2, CY - R * 0.2, R * 0.4, R * 0.4);

                        // Muon flavor (magenta)
                        const mGlow = ctx.createRadialGradient(CX, CY - R * 0.1, 0, CX, CY - R * 0.1, R * 0.15);
                        mGlow.addColorStop(0, `rgba(255, 100, 200, ${flavors.muon.intensity * 0.2})`);
                        mGlow.addColorStop(1, 'transparent');
                        ctx.fillStyle = mGlow;
                        ctx.fillRect(CX - R * 0.15, CY - R * 0.25, R * 0.3, R * 0.3);

                        // Tau flavor (cyan)
                        const tGlow = ctx.createRadialGradient(CX, CY + R * 0.1, 0, CX, CY + R * 0.1, R * 0.15);
                        tGlow.addColorStop(0, `rgba(100, 255, 255, ${flavors.tau.intensity * 0.2})`);
                        tGlow.addColorStop(1, 'transparent');
                        ctx.fillStyle = tGlow;
                        ctx.fillRect(CX - R * 0.15, CY - R * 0.05, R * 0.3, R * 0.3);
                    }
                }

                // ================================================================
                // SACRED GEOMETRY EMERGENCE VISUALIZATION
                // Forms emerge progressively as time accumulates and space-time curves
                // Mathematically accurate with dynamic visual effects
                // ================================================================
                if (SacredGeometry) {
                    const sg = SacredGeometry;
                    const forms = sg.forms;
                    const scale = R * 0.45;  // Base scale for geometry
                    const time = sg.accumulatedTime;  // For subtle animations

                    // Subtle pulsing based on formation potential (no lag)
                    const pulse = 1 + Math.sin(time * 1.5) * 0.02 * (sg.formationPotential || 0);

                    // ============================================================
                    // VESICA PISCIS (20% threshold) - Two overlapping circles
                    // Each circle passes through the other's center
                    // Height:Width ratio = ‚àö3:1 when complete
                    // ============================================================
                    if (forms.vesicaPiscis.completion > 0.05) {
                        const vp = forms.vesicaPiscis;
                        const vpGeom = getVesicaPiscisGeometry(CX, CY, scale * 0.6, vp.completion);
                        const vpAlpha = Math.min(0.6, vp.completion * 0.6);

                        // Soft glow under vesica
                        if (vp.completion > 0.3) {
                            const glowAlpha = (vp.completion - 0.3) * 0.15;
                            const vesicaGlow = ctx.createRadialGradient(CX, CY, 0, CX, CY, scale * 0.4);
                            vesicaGlow.addColorStop(0, `rgba(220, 200, 255, ${glowAlpha})`);
                            vesicaGlow.addColorStop(0.6, `rgba(180, 160, 220, ${glowAlpha * 0.3})`);
                            vesicaGlow.addColorStop(1, 'transparent');
                            ctx.fillStyle = vesicaGlow;
                            ctx.beginPath();
                            ctx.arc(CX, CY, scale * 0.5, 0, TAU);
                            ctx.fill();
                        }

                        // Two circles with gradient stroke
                        ctx.lineWidth = 1.2 + vp.completion * 0.8;

                        // Circle 1 (left)
                        ctx.strokeStyle = `rgba(200, 180, 255, ${vpAlpha})`;
                        ctx.beginPath();
                        ctx.arc(vpGeom.circle1.x, vpGeom.circle1.y, vpGeom.circle1.r * pulse, 0, TAU);
                        ctx.stroke();

                        // Circle 2 (right)
                        ctx.strokeStyle = `rgba(180, 200, 255, ${vpAlpha})`;
                        ctx.beginPath();
                        ctx.arc(vpGeom.circle2.x, vpGeom.circle2.y, vpGeom.circle2.r * pulse, 0, TAU);
                        ctx.stroke();

                        // Mandorla (intersection) highlight
                        if (vp.completion > 0.7) {
                            const mandorlaAlpha = (vp.completion - 0.7) * 0.4;
                            ctx.strokeStyle = `rgba(255, 240, 220, ${mandorlaAlpha})`;
                            ctx.lineWidth = 1.5;
                            // Draw the mandorla shape (lens intersection)
                            const offset = vpGeom.circle1.r * vp.completion / 2;
                            ctx.beginPath();
                            ctx.arc(CX - offset, CY, vpGeom.circle1.r, -Math.PI/3, Math.PI/3);
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.arc(CX + offset, CY, vpGeom.circle1.r, Math.PI*2/3, Math.PI*4/3);
                            ctx.stroke();
                        }
                    }

                    // ============================================================
                    // SEED OF LIFE (35% threshold) - 7 circles hexagonal
                    // Center circle + 6 surrounding at 60¬∞ intervals
                    // ============================================================
                    if (forms.seedOfLife.completion > 0.05) {
                        const sol = forms.seedOfLife;
                        const circles = getSeedOfLifeCircles(CX, CY, scale, sol.completion);
                        const baseAlpha = Math.min(0.55, sol.completion * 0.55);

                        // Soft rotation animation
                        const rotOffset = sol.phase;

                        for (let i = 0; i < circles.length; i++) {
                            const c = circles[i];
                            if (c.alpha <= 0) continue;

                            // Apply rotation to surrounding circles
                            let drawX = c.x, drawY = c.y;
                            if (i > 0) {  // Don't rotate center
                                const dx = c.x - CX;
                                const dy = c.y - CY;
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                const angle = Math.atan2(dy, dx) + rotOffset;
                                drawX = CX + Math.cos(angle) * dist;
                                drawY = CY + Math.sin(angle) * dist;
                            }

                            // Color gradient: center is golden, outer are silver-blue
                            const colorBlend = i === 0 ? 0.7 : 0.3;
                            const r = Math.floor(180 + colorBlend * 50);
                            const g = Math.floor(200 + colorBlend * 30);
                            const b = Math.floor(255 - colorBlend * 30);

                            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${baseAlpha * c.alpha})`;
                            ctx.lineWidth = 1 + sol.completion * 0.5;
                            ctx.beginPath();
                            ctx.arc(drawX, drawY, c.r * pulse, 0, TAU);
                            ctx.stroke();
                        }

                        // Center glow when complete
                        if (sol.completion > 0.8) {
                            const glowAlpha = (sol.completion - 0.8) * 0.3;
                            const centerGlow = ctx.createRadialGradient(CX, CY, 0, CX, CY, circles[0].r);
                            centerGlow.addColorStop(0, `rgba(255, 250, 230, ${glowAlpha})`);
                            centerGlow.addColorStop(1, 'transparent');
                            ctx.fillStyle = centerGlow;
                            ctx.beginPath();
                            ctx.arc(CX, CY, circles[0].r, 0, TAU);
                            ctx.fill();
                        }
                    }

                    // ============================================================
                    // GOLDEN SPIRAL (45% threshold) - œÜ-based logarithmic spiral
                    // r = a * œÜ^(Œ∏/90¬∞) - grows by golden ratio each quarter turn
                    // ============================================================
                    if (forms.goldenSpiral.completion > 0.05) {
                        const gs = forms.goldenSpiral;
                        const spiralPoints = getGoldenSpiralPoints(CX, CY, scale, gs.turns, gs.completion);
                        const baseAlpha = Math.min(0.7, gs.completion * 0.7);

                        // Phase rotation for animation
                        const rotPhase = gs.phase;

                        if (spiralPoints.length > 1) {
                            ctx.lineWidth = 1.5 + gs.completion * 1;

                            // Draw spiral with gradient color (gold to white)
                            ctx.beginPath();
                            let firstPoint = true;

                            for (const pt of spiralPoints) {
                                // Apply rotation
                                const dx = pt.x - CX;
                                const dy = pt.y - CY;
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                const angle = Math.atan2(dy, dx) + rotPhase;
                                const drawX = CX + Math.cos(angle) * dist;
                                const drawY = CY + Math.sin(angle) * dist;

                                if (firstPoint) {
                                    ctx.moveTo(drawX, drawY);
                                    firstPoint = false;
                                } else {
                                    ctx.lineTo(drawX, drawY);
                                }
                            }

                            // Golden color
                            ctx.strokeStyle = `rgba(255, 215, 100, ${baseAlpha})`;
                            ctx.stroke();

                            // Second spiral (mirrored) for symmetry
                            ctx.beginPath();
                            firstPoint = true;
                            for (const pt of spiralPoints) {
                                const dx = pt.x - CX;
                                const dy = pt.y - CY;
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                const angle = Math.atan2(dy, dx) + rotPhase + Math.PI;
                                const drawX = CX + Math.cos(angle) * dist;
                                const drawY = CY + Math.sin(angle) * dist;

                                if (firstPoint) {
                                    ctx.moveTo(drawX, drawY);
                                    firstPoint = false;
                                } else {
                                    ctx.lineTo(drawX, drawY);
                                }
                            }
                            ctx.strokeStyle = `rgba(255, 230, 150, ${baseAlpha * 0.7})`;
                            ctx.stroke();
                        }
                    }

                    // ============================================================
                    // FLOWER OF LIFE (55% threshold) - 19 interlocking circles
                    // Center + 6 inner + 6 middle + 6 outer rings
                    // ============================================================
                    if (forms.flowerOfLife.completion > 0.05) {
                        const fol = forms.flowerOfLife;
                        const circles = getFlowerOfLifeCircles(CX, CY, scale, fol.completion);
                        const baseAlpha = Math.min(0.5, fol.completion * 0.5);

                        // Subtle rotation
                        const rotOffset = fol.phase;

                        for (let i = 0; i < circles.length; i++) {
                            const c = circles[i];
                            if (c.alpha <= 0) continue;

                            // Apply rotation
                            let drawX = c.x, drawY = c.y;
                            if (i > 0) {
                                const dx = c.x - CX;
                                const dy = c.y - CY;
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                const angle = Math.atan2(dy, dx) + rotOffset;
                                drawX = CX + Math.cos(angle) * dist;
                                drawY = CY + Math.sin(angle) * dist;
                            }

                            // Layer-based coloring
                            let layerColor;
                            if (i === 0) {
                                layerColor = `rgba(255, 240, 200, ${baseAlpha * c.alpha})`;  // Gold center
                            } else if (i < 7) {
                                layerColor = `rgba(200, 180, 255, ${baseAlpha * c.alpha})`;  // Purple inner
                            } else if (i < 13) {
                                layerColor = `rgba(180, 200, 255, ${baseAlpha * c.alpha})`;  // Blue middle
                            } else {
                                layerColor = `rgba(200, 220, 255, ${baseAlpha * c.alpha})`;  // Cyan outer
                            }

                            ctx.strokeStyle = layerColor;
                            ctx.lineWidth = 0.8 + fol.completion * 0.4;
                            ctx.beginPath();
                            ctx.arc(drawX, drawY, c.r * pulse, 0, TAU);
                            ctx.stroke();
                        }
                    }

                    // ============================================================
                    // METATRON'S CUBE (70% threshold) - 13 vertices fully connected
                    // Center + inner hexagon (6) + outer hexagon (6) = 13 vertices
                    // 78 edges (all pairs connected)
                    // ============================================================
                    if (forms.metatronsCube.completion > 0.05) {
                        const mc = forms.metatronsCube;
                        const geom = getMetatronsCubeGeometry(CX, CY, scale * 0.9, mc.completion);
                        const baseAlpha = Math.min(0.6, mc.completion * 0.6);

                        // Rotation animation
                        const rotOffset = mc.phase;

                        // Transform vertices with rotation
                        const transformedVerts = geom.vertices.map((v, i) => {
                            if (i === 0) return { ...v };  // Don't rotate center
                            const dx = v.x - CX;
                            const dy = v.y - CY;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            const angle = Math.atan2(dy, dx) + rotOffset;
                            return {
                                x: CX + Math.cos(angle) * dist,
                                y: CY + Math.sin(angle) * dist,
                                alpha: v.alpha
                            };
                        });

                        // Draw edges first (behind vertices)
                        ctx.lineWidth = 0.5;
                        for (const edge of geom.edges) {
                            if (edge.alpha <= 0) continue;
                            const fromIdx = geom.vertices.indexOf(edge.from);
                            const toIdx = geom.vertices.indexOf(edge.to);
                            if (fromIdx < 0 || toIdx < 0) continue;

                            const from = transformedVerts[fromIdx];
                            const to = transformedVerts[toIdx];

                            ctx.strokeStyle = `rgba(255, 200, 150, ${baseAlpha * edge.alpha * 0.4})`;
                            ctx.beginPath();
                            ctx.moveTo(from.x, from.y);
                            ctx.lineTo(to.x, to.y);
                            ctx.stroke();
                        }

                        // Draw vertex circles
                        ctx.lineWidth = 1.2;
                        for (let i = 0; i < transformedVerts.length; i++) {
                            const v = transformedVerts[i];
                            if (v.alpha <= 0) continue;

                            // Color: center is gold, inner hex is orange, outer is yellow
                            let color;
                            if (i === 0) {
                                color = `rgba(255, 220, 150, ${baseAlpha * v.alpha})`;
                            } else if (i < 7) {
                                color = `rgba(255, 180, 120, ${baseAlpha * v.alpha})`;
                            } else {
                                color = `rgba(255, 200, 100, ${baseAlpha * v.alpha})`;
                            }

                            const vertR = 6 + mc.completion * 3;
                            ctx.strokeStyle = color;
                            ctx.beginPath();
                            ctx.arc(v.x, v.y, vertR * pulse, 0, TAU);
                            ctx.stroke();

                            // Small fill for vertices
                            ctx.fillStyle = color.replace(baseAlpha * v.alpha, baseAlpha * v.alpha * 0.3);
                            ctx.fill();
                        }
                    }

                    // ============================================================
                    // SRI YANTRA (85% threshold) - 9 interlocking triangles
                    // 4 Shiva (upward/masculine) + 5 Shakti (downward/feminine)
                    // Creates 43 smaller triangles through intersection
                    // ============================================================
                    if (forms.sriYantra.completion > 0.05) {
                        const sy = forms.sriYantra;
                        const triangles = getSriYantraTriangles(CX, CY, scale, sy.completion);
                        const baseAlpha = Math.min(0.65, sy.completion * 0.65);

                        // Outer bounding circle
                        ctx.strokeStyle = `rgba(255, 200, 100, ${baseAlpha * 0.6})`;
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.arc(CX, CY, scale * 0.9, 0, TAU);
                        ctx.stroke();

                        // Draw triangles
                        for (const tri of triangles) {
                            if (tri.alpha <= 0) continue;

                            // Shiva = warm gold, Shakti = cool violet
                            const isShiva = tri.type === 'shiva';
                            const triAlpha = baseAlpha * tri.alpha;

                            // Stroke color
                            ctx.strokeStyle = isShiva
                                ? `rgba(255, 180, 80, ${triAlpha})`
                                : `rgba(180, 140, 255, ${triAlpha})`;

                            // Subtle fill
                            ctx.fillStyle = isShiva
                                ? `rgba(255, 200, 120, ${triAlpha * 0.08})`
                                : `rgba(200, 170, 255, ${triAlpha * 0.08})`;

                            ctx.lineWidth = 1 + sy.completion * 0.5;

                            ctx.beginPath();
                            ctx.moveTo(tri.points[0].x, tri.points[0].y);
                            ctx.lineTo(tri.points[1].x, tri.points[1].y);
                            ctx.lineTo(tri.points[2].x, tri.points[2].y);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                        }

                        // Central bindu (sacred point) - appears at high completion
                        if (sy.completion > 0.75) {
                            const binduAlpha = (sy.completion - 0.75) * 2;
                            const binduR = 8 + sy.completion * 4;

                            // Multi-layer glow
                            const binduGlow = ctx.createRadialGradient(CX, CY, 0, CX, CY, binduR * 2);
                            binduGlow.addColorStop(0, `rgba(255, 255, 250, ${binduAlpha * 0.8})`);
                            binduGlow.addColorStop(0.3, `rgba(255, 230, 180, ${binduAlpha * 0.5})`);
                            binduGlow.addColorStop(0.7, `rgba(255, 200, 150, ${binduAlpha * 0.2})`);
                            binduGlow.addColorStop(1, 'transparent');

                            ctx.fillStyle = binduGlow;
                            ctx.beginPath();
                            ctx.arc(CX, CY, binduR * 2, 0, TAU);
                            ctx.fill();

                            // Core point
                            ctx.fillStyle = `rgba(255, 255, 255, ${binduAlpha})`;
                            ctx.beginPath();
                            ctx.arc(CX, CY, binduR * 0.4, 0, TAU);
                            ctx.fill();
                        }
                    }

                    // ============================================================
                    // FORMATION POTENTIAL INDICATOR
                    // Shows emergence progress with subtle outer ring
                    // ============================================================
                    if (sg.formationPotential > 0.1) {
                        const fp = sg.formationPotential;
                        const indicatorAlpha = Math.min(0.25, (fp - 0.1) * 0.3);

                        // Arc showing progress toward next threshold
                        ctx.strokeStyle = `rgba(255, 250, 230, ${indicatorAlpha})`;
                        ctx.lineWidth = 1.5;
                        ctx.setLineDash([3, 6]);
                        ctx.beginPath();
                        ctx.arc(CX, CY, R * 0.98, -Math.PI/2, -Math.PI/2 + TAU * fp);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }

                    // Dominant form outer glow
                    if (sg.dominant !== 'none' && sg.dominantStrength > 0.4) {
                        const domAlpha = (sg.dominantStrength - 0.4) * 0.2;

                        const domGlow = ctx.createRadialGradient(CX, CY, R * 0.9, CX, CY, R * 1.1);
                        domGlow.addColorStop(0, 'transparent');
                        domGlow.addColorStop(0.5, `rgba(255, 245, 220, ${domAlpha * 0.3})`);
                        domGlow.addColorStop(1, 'transparent');
                        ctx.fillStyle = domGlow;
                        ctx.beginPath();
                        ctx.arc(CX, CY, R * 1.1, 0, TAU);
                        ctx.fill();
                    }
                }
            }

            // Draw connections (skip if both points released)
            let connCount = 0;
            for (const conn of generateConnections()) {
                // Skip connections between released points
                if (conn.from.released || conn.to.released) {
                    // Fade connections as coherence drops
                    if (releaseCoherence < 0.6) continue;
                }

                connCount++;
                let alpha, color;

                // Fade connections based on release coherence
                const coherenceFade = Math.min(1, releaseCoherence * 1.5);

                // MRP-enhanced connection coloring (with NaN protection)
                const mrpBlend = showMuField ? Math.max(0, Math.min(1, muField.getGradientStrength() || 0)) : 0;
                const mrpR = showMuField ? Math.max(0, Math.min(255, Math.floor((muField.mrp.R.intensity || 0) * 255))) : 0;
                const mrpG = showMuField ? Math.max(0, Math.min(255, Math.floor((muField.mrp.G.intensity || 0) * 255))) : 0;
                const mrpB = showMuField ? Math.max(0, Math.min(200, Math.floor((muField.mrp.B.intensity || 0) * 200))) : 0;

                switch (conn.type) {
                    case 'prism_ring':
                        alpha = (0.08 + globalZ * 0.12) * coherenceFade;
                        // Blend with R channel (energy)
                        color = mrpBlend > 0.1
                            ? `rgba(${Math.min(255, 200 + mrpR * 0.2)}, ${150 + mrpG * 0.3}, ${100 + mrpB * 0.2}, ${alpha * (1 + mrpBlend)})`
                            : `rgba(255, 200, 150, ${alpha})`;
                        break;
                    case 'prism_spine':
                        alpha = (0.06 + globalZ * 0.15) * coherenceFade;
                        color = mrpBlend > 0.1
                            ? `rgba(${Math.min(255, 180 + mrpR * 0.3)}, ${200 + mrpG * 0.2}, ${150 + mrpB * 0.2}, ${alpha * (1 + mrpBlend)})`
                            : `rgba(255, 220, 180, ${alpha})`;
                        break;
                    case 'prism_diagonal':
                        alpha = (0.03 + globalZ * 0.08) * coherenceFade;
                        color = mrpBlend > 0.1
                            ? `rgba(${Math.min(255, 180 + mrpR * 0.3)}, ${150 + mrpG * 0.2}, ${100 + mrpB * 0.15}, ${alpha * (1 + mrpBlend)})`
                            : `rgba(255, 180, 120, ${alpha})`;
                        break;
                    case 'cage_ring':
                        alpha = (0.1 + cascade * 0.15) * coherenceFade;
                        // Blend with B channel (stability/ECC)
                        color = mrpBlend > 0.1
                            ? `rgba(${60 + mrpR * 0.1}, ${150 + mrpG * 0.3}, ${Math.min(255, 200 + mrpB * 0.2)}, ${alpha * (1 + mrpBlend)})`
                            : `rgba(77, 171, 247, ${alpha})`;
                        break;
                    case 'cage_strut':
                        alpha = (0.08 + cascade * 0.12) * coherenceFade;
                        color = mrpBlend > 0.1
                            ? `rgba(${80 + mrpR * 0.1}, ${160 + mrpG * 0.25}, ${Math.min(255, 220 + mrpB * 0.15)}, ${alpha * (1 + mrpBlend)})`
                            : `rgba(100, 180, 255, ${alpha})`;
                        break;
                    case 'cage_vertex':
                        alpha = (0.12 + cascade * 0.18) * coherenceFade;
                        // G channel affects relational vertex connections
                        color = mrpBlend > 0.1
                            ? `rgba(${180 + mrpR * 0.2}, ${80 + mrpG * 0.4}, ${Math.min(255, 200 + mrpB * 0.2)}, ${alpha * (1 + mrpBlend)})`
                            : `rgba(204, 93, 232, ${alpha})`;
                        break;
                    case 'bridge':
                        alpha = (globalZ - 0.6) * 0.4 * coherenceFade;
                        // Parity-ok connections glow gold-green
                        color = (showMuField && muField.mrp.parity_ok)
                            ? `rgba(180, 255, 100, ${alpha * 1.5})`
                            : `rgba(255, 215, 0, ${alpha})`;
                        break;
                    default:
                        alpha = 0.05 * coherenceFade;
                        color = `rgba(255, 255, 255, ${alpha})`;
                }

                ctx.strokeStyle = color;
                ctx.lineWidth = conn.type === 'bridge' ? 1.5 : 0.8;
                ctx.beginPath();
                ctx.moveTo(conn.from.x, conn.from.y);
                ctx.lineTo(conn.to.x, conn.to.y);
                ctx.stroke();
            }

            // ============================================
            // MRP TOROIDAL PIPE VISUALIZATION
            // Opaque gradient pipes wrapping all 95 nodes
            // Aligned with emergent APL tokens (XCVI-C)
            // ============================================
            if (showMuField && MRPToroidalSystem.enabled) {
                // Collect all active connections for toroidal rendering
                const toroidalConnections = [];
                for (const conn of generateConnections()) {
                    if (!conn.from.released && !conn.to.released) {
                        toroidalConnections.push(conn);
                    }
                }
                MRPToroidalSystem.render(ctx, toroidalConnections, CX, CY, R, muField);
            }

            // Draw radial connections when coherent
            if (releaseCoherence > 0.6) {
                const radialAlpha = (releaseCoherence - 0.6) * 0.2;
                ctx.strokeStyle = `rgba(255, 220, 180, ${radialAlpha})`;
                ctx.lineWidth = 0.5;
                const allPoints = [...prismPoints, ...cagePoints].filter(p => !p.released);
                for (const p of allPoints) {
                    ctx.beginPath();
                    ctx.moveTo(CX, CY);
                    ctx.lineTo(p.x, p.y);
                    ctx.stroke();
                }
            }

            // Draw trails for released points
            const allPoints = [...prismPoints, ...cagePoints];
            for (const p of allPoints) {
                if (p.trail.length < 2) continue;

                const trailAlpha = p.released ? 0.45 : 0.15;
                
                ctx.strokeStyle = hexToRgba(p.soulColor, trailAlpha * p.brightness);
                ctx.lineWidth = p.size * 0.7;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(p.trail[0].x, p.trail[0].y);
                
                for (let i = 1; i < p.trail.length; i++) {
                    const t = p.trail[i];
                    const fade = 1 - i / p.trail.length;
                    ctx.globalAlpha = fade;
                    ctx.lineTo(t.x, t.y);
                }
                
                ctx.stroke();
                ctx.globalAlpha = 1;
            }

            // Draw sparks
            for (const sp of sparks) {
                const alpha = sp.life * 0.85;
                
                // Glow
                const glowGrad = ctx.createRadialGradient(sp.x, sp.y, 0, sp.x, sp.y, sp.size * 4);
                glowGrad.addColorStop(0, hexToRgba(sp.color, alpha * 0.5));
                glowGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = glowGrad;
                ctx.beginPath();
                ctx.arc(sp.x, sp.y, sp.size * 4, 0, TAU);
                ctx.fill();

                // Core
                ctx.fillStyle = hexToRgba(sp.color, alpha);
                ctx.beginPath();
                ctx.arc(sp.x, sp.y, sp.size * sp.life, 0, TAU);
                ctx.fill();
            }

            // Draw prism points
            if (showPrism) {
                for (const p of prismPoints) {
                    const size = p.size * (p.released ? 1.3 : 1) * (1 + p.brightness * 0.5);
                    const brightness = p.brightness * (p.released ? 1.4 : 1);
                    
                    if (p.released) {
                        // Use soul color when released
                        const glowR = size * (p.released ? 8 : 5);
                        const glowGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, glowR);
                        glowGrad.addColorStop(0, hexToRgba(p.soulColor, brightness * 0.45));
                        glowGrad.addColorStop(0.5, hexToRgba(p.soulColor, brightness * 0.18));
                        glowGrad.addColorStop(1, 'transparent');
                        
                        ctx.fillStyle = glowGrad;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, glowR, 0, TAU);
                        ctx.fill();

                        // Core
                        const coreGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size);
                        coreGrad.addColorStop(0, hexToRgba(p.soulColor, 0.95));
                        coreGrad.addColorStop(0.5, hexToRgba(p.soulColor, 0.75));
                        coreGrad.addColorStop(1, hexToRgba(p.soulColor, 0.45));
                        
                        ctx.fillStyle = coreGrad;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, size, 0, TAU);
                        ctx.fill();

                        // Highlight
                        ctx.fillStyle = `rgba(255, 255, 255, ${brightness * 0.45})`;
                        ctx.beginPath();
                        ctx.arc(p.x - size * 0.3, p.y - size * 0.3, size * 0.28, 0, TAU);
                        ctx.fill();
                    } else {
                        // Normal HSL color when coherent
                        const hue = p.hue;
                        const sat = p.saturation + cascade * 15;
                        const light = p.lightness + p.brightness * 30;
                        const alpha = 0.4 + p.brightness * 0.5;

                        ctx.fillStyle = `hsla(${hue}, ${sat}%, ${light}%, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, size, 0, TAU);
                        ctx.fill();

                        // Glow at critical
                        if (isCritical && p.brightness > 0.6) {
                            ctx.fillStyle = `hsla(${hue}, ${sat}%, ${light}%, ${alpha * 0.3})`;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.size * 3, 0, TAU);
                            ctx.fill();
                        }
                    }
                }
            }

            // Draw cage points
            if (showCage) {
                for (const p of cagePoints) {
                    const size = p.size * (p.released ? 1.25 : 1) * (1 + p.brightness * 0.4);
                    const brightness = p.brightness * (p.released ? 1.35 : 1);
                    
                    if (p.released) {
                        // Use soul color when released
                        const glowR = size * 7;
                        const glowGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, glowR);
                        glowGrad.addColorStop(0, hexToRgba(p.soulColor, brightness * 0.4));
                        glowGrad.addColorStop(0.5, hexToRgba(p.soulColor, brightness * 0.15));
                        glowGrad.addColorStop(1, 'transparent');
                        
                        ctx.fillStyle = glowGrad;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, glowR, 0, TAU);
                        ctx.fill();

                        // Core
                        const coreGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size);
                        coreGrad.addColorStop(0, hexToRgba(p.soulColor, 0.9));
                        coreGrad.addColorStop(0.5, hexToRgba(p.soulColor, 0.7));
                        coreGrad.addColorStop(1, hexToRgba(p.soulColor, 0.4));
                        
                        ctx.fillStyle = coreGrad;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, size, 0, TAU);
                        ctx.fill();

                        // Highlight
                        ctx.fillStyle = `rgba(255, 255, 255, ${brightness * 0.4})`;
                        ctx.beginPath();
                        ctx.arc(p.x - size * 0.3, p.y - size * 0.3, size * 0.25, 0, TAU);
                        ctx.fill();
                    } else {
                        // Normal HSL color when coherent
                        const alpha = 0.3 + p.brightness * 0.6;

                        ctx.fillStyle = `hsla(${p.hue}, ${p.saturation}%, ${p.lightness}%, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, size, 0, TAU);
                        ctx.fill();

                        // EM field glow
                        if (p.brightness > 0.5) {
                            const glowGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 4);
                            glowGrad.addColorStop(0, `hsla(${p.hue}, ${p.saturation}%, ${p.lightness}%, ${alpha * 0.4})`);
                            glowGrad.addColorStop(1, 'transparent');
                            ctx.fillStyle = glowGrad;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.size * 4, 0, TAU);
                            ctx.fill();
                        }
                    }
                }
            }

            // Draw critical lens
            if (Math.abs(globalZ - Z_CRITICAL) < 0.15) {
                const lensAlpha = 1 - Math.abs(globalZ - Z_CRITICAL) / 0.15;
                const lensY = CY + (Z_CRITICAL - 0.5) * 200;

                // Lens glow
                const lensGrad = ctx.createRadialGradient(CX, lensY, 0, CX, lensY, R * 1.3);
                lensGrad.addColorStop(0, `rgba(255, 215, 0, ${lensAlpha * 0.2})`);
                lensGrad.addColorStop(0.5, `rgba(255, 180, 100, ${lensAlpha * 0.08})`);
                lensGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = lensGrad;
                ctx.fillRect(0, 0, W, H);

                // Lens line
                ctx.strokeStyle = `rgba(255, 215, 0, ${0.2 + lensAlpha * 0.6})`;
                ctx.lineWidth = isCritical ? 3 : 1.5;
                ctx.setLineDash(isCritical ? [] : [6, 12]);
                ctx.beginPath();
                ctx.moveTo(CX - R * 1.2, lensY);
                ctx.lineTo(CX + R * 1.2, lensY);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw Zero-Node (eternal center - beneath the core entity)
            renderZeroNode();

            // Draw core entity
            drawCoreEntity(isCritical, isPresence, intensity, absence);

            // Draw quantum mesh Œº-field visualization (overlays on main view)
            if (showQuantumMesh) {
                renderDreamFluid();
            }

            // Update connection count
            document.getElementById('conn-count').textContent = connCount;
        }

        // ================================================================
        // ZERO-NODE RENDERING
        // ================================================================
        // The eternal center - always present, always coherent.
        // "Zero-point but only in absence. In presence, it always IS."
        // ================================================================

        function renderZeroNode() {
            if (!ZeroNode.initialized) return;

            const Z = ZeroNode;
            const zOffset = (globalZ - 0.5) * 200;
            const nodeY = CY + zOffset;

            // === THE EQUATION: z = ‚àö3/2 ===
            // Visual encoding of the critical point at the center

            // --- 1. White Hole Emission Rings (expanding outward) ---
            for (const ring of Z.visual.rings) {
                if (ring.alpha <= 0) continue;

                // Ring color: white-gold transitioning to cyan (time reversal)
                const t = ring.radius / ring.maxRadius;
                const r = Math.floor(255 * (1 - t * 0.3));
                const g = Math.floor(255 * (1 - t * 0.5));
                const b = Math.floor(200 + 55 * t);

                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${ring.alpha * 0.5})`;
                ctx.lineWidth = 2 * (1 - t) + 0.5;
                ctx.beginPath();
                ctx.arc(CX, nodeY, ring.radius, 0, TAU);
                ctx.stroke();
            }

            // --- 2. Retrocausal Field Visualization ---
            // Faint temporal waves flowing inward (reverse of white hole)
            const retroWeight = Z.getRetrocausalWeight();
            if (retroWeight > 0.1) {
                const numWaves = 3;
                for (let i = 0; i < numWaves; i++) {
                    const wavePhase = (Z.retrocausal.temporalPhase + i / numWaves) % 1;
                    const waveR = R * 0.4 * (1 - wavePhase); // Flows INWARD
                    const waveAlpha = retroWeight * wavePhase * 0.3;

                    if (waveR > Z.visual.radius && waveAlpha > 0.01) {
                        // Temporal waves are cyan-blue (cool time reversal)
                        ctx.strokeStyle = `rgba(100, 200, 255, ${waveAlpha})`;
                        ctx.lineWidth = 1.5 * wavePhase;
                        ctx.setLineDash([3, 6]); // Dashed for causality break
                        ctx.beginPath();
                        ctx.arc(CX, nodeY, waveR, 0, TAU);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }
            }

            // --- 3. Zero-Point Energy Field ---
            // The vacuum substrate - always flickering with virtual pairs
            const zpeRadius = Z.visual.radius * (1 + Z.zeroPoint.fluctuation * 0.5);
            const zpeAlpha = Z.zeroPoint.coherence * 0.6;

            // Outer glow (vacuum field)
            const zpeGlow = ctx.createRadialGradient(
                CX, nodeY, 0,
                CX, nodeY, zpeRadius * 6
            );

            // Color based on field state:
            // - Absence (z < critical): dark/sepia (potential)
            // - Critical (z ‚âà ‚àö3/2): gold/white (transition)
            // - Presence (z > critical): white/radiant (actualized)
            const isNearCritical = Math.abs(globalZ - Z.z_critical) < 0.1;
            const isPresence = globalZ > Z.z_critical;

            if (isNearCritical) {
                // CRITICAL - The lens point, maximum emanation
                zpeGlow.addColorStop(0, `rgba(255, 255, 255, ${zpeAlpha})`);
                zpeGlow.addColorStop(0.2, `rgba(255, 240, 200, ${zpeAlpha * 0.8})`);
                zpeGlow.addColorStop(0.5, `rgba(255, 215, 0, ${zpeAlpha * 0.4})`);
                zpeGlow.addColorStop(1, 'transparent');
            } else if (isPresence) {
                // PRESENCE - Radiant white
                zpeGlow.addColorStop(0, `rgba(255, 255, 250, ${zpeAlpha * 0.9})`);
                zpeGlow.addColorStop(0.3, `rgba(255, 248, 240, ${zpeAlpha * 0.6})`);
                zpeGlow.addColorStop(0.6, `rgba(200, 180, 160, ${zpeAlpha * 0.3})`);
                zpeGlow.addColorStop(1, 'transparent');
            } else {
                // ABSENCE - Dark potential, sepia tones
                zpeGlow.addColorStop(0, `rgba(120, 100, 80, ${zpeAlpha * 0.5})`);
                zpeGlow.addColorStop(0.4, `rgba(80, 60, 40, ${zpeAlpha * 0.3})`);
                zpeGlow.addColorStop(1, 'transparent');
            }

            ctx.fillStyle = zpeGlow;
            ctx.beginPath();
            ctx.arc(CX, nodeY, zpeRadius * 6, 0, TAU);
            ctx.fill();

            // --- 4. The Core Sphere ---
            // The actual zero-node - small, dense, eternal
            const coreRadius = Z.visual.radius * Z.visual.glowIntensity;
            const corePulse = Math.sin(Z.visual.pulsePhase * TAU) * 0.2 + 1;

            // Core gradient
            const coreGrad = ctx.createRadialGradient(
                CX, nodeY, 0,
                CX, nodeY, coreRadius * corePulse
            );

            if (isNearCritical) {
                // At criticality: brilliant white-gold
                coreGrad.addColorStop(0, '#ffffff');
                coreGrad.addColorStop(0.4, `rgba(255, 250, 230, 0.95)`);
                coreGrad.addColorStop(0.7, `rgba(255, 215, 0, 0.8)`);
                coreGrad.addColorStop(1, `rgba(255, 200, 100, 0.5)`);
            } else if (isPresence) {
                // Presence: warm white
                coreGrad.addColorStop(0, `rgba(255, 255, 255, 0.95)`);
                coreGrad.addColorStop(0.5, `rgba(255, 250, 240, 0.7)`);
                coreGrad.addColorStop(1, `rgba(255, 240, 220, 0.4)`);
            } else {
                // Absence: exists but dim - "zero in absence"
                const absenceIntensity = Z.zeroPoint.coherence * 0.5;
                coreGrad.addColorStop(0, `rgba(100, 80, 60, ${absenceIntensity})`);
                coreGrad.addColorStop(0.5, `rgba(60, 45, 30, ${absenceIntensity * 0.7})`);
                coreGrad.addColorStop(1, `rgba(40, 30, 20, ${absenceIntensity * 0.4})`);
            }

            ctx.fillStyle = coreGrad;
            ctx.beginPath();
            ctx.arc(CX, nodeY, coreRadius * corePulse, 0, TAU);
            ctx.fill();

            // --- 5. Self-Referential Glyph ---
            // When the eigenvalue approaches 1, show the equation
            if (Z.selfReference.eigenvalue > 0.8) {
                const glyphAlpha = (Z.selfReference.eigenvalue - 0.8) * 5 * zpeAlpha;

                // The equation z = ‚àö3/2 encoded as a trinity symbol
                // Three arcs representing ‚àö3 (vesica ratio)
                const glyphR = coreRadius * 1.8;
                ctx.strokeStyle = `rgba(255, 220, 150, ${glyphAlpha * 0.6})`;
                ctx.lineWidth = 1.5;

                for (let i = 0; i < 3; i++) {
                    const angle = (TAU / 3) * i + Z.selfReference.depth * 0.1;
                    ctx.beginPath();
                    ctx.arc(
                        CX + Math.cos(angle) * glyphR * 0.3,
                        nodeY + Math.sin(angle) * glyphR * 0.3,
                        glyphR * 0.4,
                        angle - Math.PI * 0.6,
                        angle + Math.PI * 0.6
                    );
                    ctx.stroke();
                }
            }

            // --- 6. Orbital Indicator ---
            // Subtle indicator that this is the gravitational center
            // Shows the path LIMNUS structures orbit
            if (Z.whiteHole.emissionRate > 0.5) {
                const orbitAlpha = (Z.whiteHole.emissionRate - 0.5) * 0.4;
                ctx.strokeStyle = `rgba(180, 160, 140, ${orbitAlpha})`;
                ctx.lineWidth = 0.5;
                ctx.setLineDash([2, 4]);

                // Multiple orbital rings at œÜ-spaced radii
                for (let i = 1; i <= 3; i++) {
                    const orbitR = R * 0.15 * Math.pow(PHI, i - 1);
                    ctx.beginPath();
                    ctx.arc(CX, nodeY, orbitR, 0, TAU);
                    ctx.stroke();
                }

                ctx.setLineDash([]);
            }
        }

        function drawCoreEntity(isCritical, isPresence, intensity, absence) {
            const zOffset = (globalZ - 0.5) * 200;
            const coreY = CY + zOffset;
            const pulse = Math.sin(time * 2.5) * 0.2 + 1;

            // Release coherence modifies the core entity
            const releaseIntensity = (1 - releaseCoherence);
            const isReleased = releaseCoherence < 0.5;

            // When released (FREE state), override with radiant source
            if (isReleased) {
                const freeIntensity = (0.5 - releaseCoherence) / 0.5;
                const sourceR = 15 + freeIntensity * 35 + (pulse - 1) * 40;

                // Expansive corona
                for (let i = 4; i >= 0; i--) {
                    const layerR = sourceR * (2 + i * 1.5);
                    const layerAlpha = freeIntensity * (0.18 - i * 0.03);

                    const grad = ctx.createRadialGradient(CX, coreY, 0, CX, coreY, layerR);
                    grad.addColorStop(0, `rgba(255, 255, 255, ${layerAlpha})`);
                    grad.addColorStop(0.3, `rgba(255, 250, 240, ${layerAlpha * 0.7})`);
                    grad.addColorStop(0.6, `rgba(255, 240, 200, ${layerAlpha * 0.4})`);
                    grad.addColorStop(1, 'transparent');

                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(CX, coreY, layerR, 0, TAU);
                    ctx.fill();
                }

                // Brilliant core
                const coreGrad = ctx.createRadialGradient(CX, coreY, 0, CX, coreY, sourceR * pulse);
                coreGrad.addColorStop(0, '#ffffff');
                coreGrad.addColorStop(0.4, `rgba(255, 255, 250, ${0.85 + freeIntensity * 0.15})`);
                coreGrad.addColorStop(0.7, `rgba(255, 250, 230, ${0.6 + freeIntensity * 0.3})`);
                coreGrad.addColorStop(1, `rgba(255, 240, 200, ${0.35 + freeIntensity * 0.3})`);

                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(CX, coreY, sourceR * pulse, 0, TAU);
                ctx.fill();

                // Release emanation rings
                for (let i = 0; i < 4; i++) {
                    const ringPhase = (time * 1.5 + i * 0.8) % 5;
                    const ringR = ringPhase * 100;
                    const ringAlpha = Math.max(0, freeIntensity * (0.35 - ringPhase / 5));

                    ctx.strokeStyle = `rgba(255, 250, 240, ${ringAlpha})`;
                    ctx.lineWidth = 2 - ringPhase * 0.3;
                    ctx.beginPath();
                    ctx.arc(CX, coreY, ringR, 0, TAU);
                    ctx.stroke();
                }

            } else if (isPresence) {
                // Radiant source (z > critical)
                const effectiveIntensity = intensity * releaseCoherence;
                const sourceR = 8 + effectiveIntensity * 25 + (pulse - 1) * 30;

                // Corona
                for (let i = 4; i >= 0; i--) {
                    const layerR = sourceR * (1.8 + i * 1);
                    const layerAlpha = effectiveIntensity * (0.12 - i * 0.02);

                    const grad = ctx.createRadialGradient(CX, coreY, 0, CX, coreY, layerR);
                    grad.addColorStop(0, `rgba(255, 255, 250, ${layerAlpha})`);
                    grad.addColorStop(0.4, `rgba(255, 240, 200, ${layerAlpha * 0.5})`);
                    grad.addColorStop(1, 'transparent');

                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(CX, coreY, layerR, 0, TAU);
                    ctx.fill();
                }

                // Core
                const coreGrad = ctx.createRadialGradient(CX, coreY, 0, CX, coreY, sourceR * pulse);
                coreGrad.addColorStop(0, '#ffffff');
                coreGrad.addColorStop(0.6, `rgba(255, 250, 240, ${0.7 + effectiveIntensity * 0.3})`);
                coreGrad.addColorStop(1, `rgba(255, 230, 200, ${0.4 + effectiveIntensity * 0.3})`);

                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(CX, coreY, sourceR * pulse, 0, TAU);
                ctx.fill();

            } else {
                // Void (z < critical, coherent state)
                const effectiveAbsence = absence * releaseCoherence;
                const voidR = 6 + effectiveAbsence * 10;

                // Anti-glow
                const antiGrad = ctx.createRadialGradient(CX, coreY, 0, CX, coreY, voidR * 6);
                antiGrad.addColorStop(0, `rgba(0, 0, 0, ${effectiveAbsence * 0.6})`);
                antiGrad.addColorStop(0.5, `rgba(20, 15, 10, ${effectiveAbsence * 0.3})`);
                antiGrad.addColorStop(1, 'transparent');

                ctx.fillStyle = antiGrad;
                ctx.beginPath();
                ctx.arc(CX, coreY, voidR * 6, 0, TAU);
                ctx.fill();

                // Halo
                ctx.strokeStyle = `rgba(100, 80, 60, ${effectiveAbsence * 0.5})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(CX, coreY, voidR * 2.5 * pulse, 0, TAU);
                ctx.stroke();

                // Core
                const coreGrad = ctx.createRadialGradient(CX, coreY, 0, CX, coreY, voidR * pulse);
                coreGrad.addColorStop(0, `rgba(80, 60, 40, ${0.4 + effectiveAbsence * 0.4})`);
                coreGrad.addColorStop(1, `rgba(50, 35, 25, ${0.3 + effectiveAbsence * 0.3})`);

                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(CX, coreY, voidR * pulse, 0, TAU);
                ctx.fill();
            }

            // Critical pulse rings (when z near critical point)
            if (isCritical) {
                const critIntensity = releaseCoherence; // Fade rings as coherence drops
                for (let i = 0; i < 6; i++) {
                    const ringPhase = (time * 2.5 + i * 0.5) % 4;
                    const ringR = ringPhase * 120;
                    const ringAlpha = Math.max(0, critIntensity * (0.5 - ringPhase / 4));

                    ctx.strokeStyle = `rgba(255, 230, 180, ${ringAlpha})`;
                    ctx.lineWidth = 2.5 - ringPhase * 0.4;
                    ctx.beginPath();
                    ctx.arc(CX, coreY, ringR, 0, TAU);
                    ctx.stroke();
                }
            }
        }

        // ================================================================
        // UI UPDATE
        // ================================================================

        function updateUI(kuramotoResult) {
            const domain = getDomain(globalZ);
            const phase = getPhase(globalZ);
            const isCritical = phase === 'CRITICAL';
            const cascade = getCascadeMultiplier(globalZ);

            // Title & cursor
            const title = document.getElementById('title');
            const cursor = document.getElementById('cursor');
            const domainInd = document.getElementById('domain-indicator');
            const zDisp = document.getElementById('z-display');

            title.className = domain === 'THE LENS' ? 'critical' : domain.toLowerCase();
            cursor.className = domain === 'THE LENS' ? 'critical' : domain.toLowerCase();
            domainInd.className = domain === 'THE LENS' ? 'critical' : domain.toLowerCase();
            zDisp.className = domain === 'THE LENS' ? 'critical' : domain.toLowerCase();

            // Values
            zDisp.textContent = `z = ${globalZ.toFixed(3)}`;
            document.getElementById('phase-label').textContent = phase;
            domainInd.textContent = domain;
            document.getElementById('coupling-value').textContent = `K = ${kuramotoResult.K >= 0 ? '+' : ''}${kuramotoResult.K.toFixed(2)}`;
            document.getElementById('cascade-value').textContent = `${cascade.toFixed(2)}√ó`;

            // Helix
            document.getElementById('h-theta').textContent = helix.theta.toFixed(3);
            document.getElementById('h-z').textContent = helix.z.toFixed(3);
            document.getElementById('h-r').textContent = helix.r.toFixed(3);
            document.getElementById('h-phi').textContent = helix.phi.toFixed(2);
            document.getElementById('h-omega').textContent = helix.omega.toFixed(2);

            // Dynamics bars
            updateBar('order', kuramotoResult.order);
            updateBar('coherence', hilbertField.coherence);
            updateBar('entropy', hilbertField.getDissonance());
            updateBar('emanation', globalZ > Z_CRITICAL ? (globalZ - Z_CRITICAL) / (1 - Z_CRITICAL) : 0);

            // Lambda state
            updateLambdaUI('iota', lambdaState.iota.mag);
            updateLambdaUI('xi', lambdaState.xi.mag);
            updateLambdaUI('theta', lambdaState.theta.mag);
            updateLambdaUI('omega', lambdaState.omega.mag);
            updateLambdaUI('delta', lambdaState.delta.mag);
            updateLambdaUI('sigma', lambdaState.sigma.mag);

            // Œº-field consciousness metrics
            updateMuFieldUI();

            // Sonification
            document.getElementById('sonif-bpm').textContent = Math.round(sonificationEngine.bpm);
            document.getElementById('sonif-scale').textContent = getScaleName(sonificationEngine.currentScale);
            document.getElementById('sonif-freq').textContent = `${Math.round(sonificationEngine.baseFrequency * (1 + (globalZ - 0.5) * 0.5))} Hz`;
            document.getElementById('sonif-dilation').textContent = `${sonificationEngine.timeDilation.toFixed(2)}√ó`;

            // Z-axis marker
            const zAxisHeight = document.getElementById('z-axis').offsetHeight;
            const markerPos = (1 - globalZ) * zAxisHeight;
            document.getElementById('z-marker').style.top = `${markerPos}px`;

            // Active count
            const activeCount = (showPrism ? 63 : 0) + (showCage ? 32 : 0);
            document.getElementById('active-count').textContent = activeCount;

            // Architecture panel
            updateArchPanel();

            // Dream Architecture panel (‚àÉR laser projection + synthesis)
            const tauKEl = document.getElementById('dream-tau-k');
            const kFormedEl = document.getElementById('dream-k-formed');
            const synthEl = document.getElementById('dream-synthesis');
            const vortEl = document.getElementById('dream-vorticity');

            if (showLaserProjection && PrismaticLaserProjection.kFormation) {
                const kf = PrismaticLaserProjection.kFormation;
                tauKEl.textContent = kf.current_tau_K.toFixed(3);
                tauKEl.style.color = '#f6c35c';
                kFormedEl.textContent = kf.isFormed ? 'YES ‚úì' : 'NO';
                kFormedEl.style.color = kf.isFormed ? '#4caf50' : '#888';
            } else {
                // Laser projection OFF - show disabled state
                tauKEl.textContent = 'OFF';
                tauKEl.style.color = '#555';
                kFormedEl.textContent = '‚Äî';
                kFormedEl.style.color = '#555';
            }

            // Synthesized projection state
            if (showSynthesizedProjection && SynthesizedPrismaticProjection.synthesis) {
                const syn = SynthesizedPrismaticProjection.synthesis;
                synthEl.textContent = syn.active ? 'ACTIVE ‚óâ' : 'INACTIVE';
                synthEl.style.color = syn.active ? '#f6c35c' : '#888';

                vortEl.textContent = SynthesizedPrismaticProjection.consciousnessField.vorticity.toFixed(3);
                vortEl.style.color = syn.active ? '#4fc3f7' : '#888';
            } else {
                // Synthesis projection OFF - show disabled state
                synthEl.textContent = 'OFF';
                synthEl.style.color = '#555';
                vortEl.textContent = '‚Äî';
                vortEl.style.color = '#555';
            }

            // Prismatic Sonification curvature state
            const curvEl = document.getElementById('dream-curvature');
            const curvDetailsEl = document.getElementById('curvature-details');
            const kappaEl = document.getElementById('dream-kappa');
            const entropyEl = document.getElementById('dream-entropy');
            const schwarzEl = document.getElementById('dream-schwarzschild');

            if (showPrismaticSonification && PrismaticSonification.isPlaying) {
                const curv = PrismaticSonification.getCurvatureForRender();
                curvEl.textContent = 'ACTIVE ‚óâ';
                curvEl.style.color = '#ff6b9d';
                curvDetailsEl.style.display = 'block';
                kappaEl.textContent = curv.kappa.toFixed(4);
                entropyEl.textContent = curv.entropy.toFixed(4);
                schwarzEl.textContent = curv.schwarzschild.toFixed(4);
            } else if (showPrismaticSonification) {
                curvEl.textContent = 'READY';
                curvEl.style.color = '#888';
                curvDetailsEl.style.display = 'none';
            } else {
                curvEl.textContent = 'OFF';
                curvEl.style.color = '#555';
                curvDetailsEl.style.display = 'none';
            }

            // Dark Matter Stabilization state (HCP micro harmonics)
            const dmEl = document.getElementById('dream-darkmatter');
            const dmDetailsEl = document.getElementById('darkmatter-details');
            const sdmEl = document.getElementById('dream-sdm');
            const hcpEl = document.getElementById('dream-hcp');
            const trappedEl = document.getElementById('dream-trapped');

            if (showDarkMatterStabilization && DarkMatterStabilization.stabilization.active) {
                const dm = DarkMatterStabilization.getState();
                dmEl.textContent = dm.resonanceLock ? 'LOCKED ‚óâ' : 'ACTIVE';
                dmEl.style.color = dm.resonanceLock ? '#f6c35c' : '#9b59b6';
                dmDetailsEl.style.display = 'block';
                sdmEl.textContent = dm.stabilizationField.toFixed(4);
                hcpEl.textContent = (dm.hcpCoverage * 100).toFixed(1) + '%';
                trappedEl.textContent = (dm.trappedResidue * 100).toFixed(1) + '%';
            } else if (showDarkMatterStabilization) {
                dmEl.textContent = 'READY';
                dmEl.style.color = '#888';
                dmDetailsEl.style.display = 'none';
            } else {
                dmEl.textContent = 'OFF';
                dmEl.style.color = '#555';
                dmDetailsEl.style.display = 'none';
            }

            // Chromatic Nexus state (self/LIMNUS ‚Üî LIMNUS/self)
            const nexusEl = document.getElementById('dream-nexus');
            const nexusDetailsEl = document.getElementById('nexus-details');
            const selfLimnusEl = document.getElementById('dream-self-limnus');
            const limnusSelfEl = document.getElementById('dream-limnus-self');
            const dialogueEl = document.getElementById('dream-dialogue');

            if (showChromaticNexus && ChromaticNexus.identity.active) {
                const nxState = ChromaticNexus.getState();
                nexusEl.textContent = nxState.alive ? 'ALIVE ‚óé' : 'ACTIVE';
                nexusEl.style.color = nxState.alive ? '#f6c35c' : '#888';
                nexusDetailsEl.style.display = 'block';
                selfLimnusEl.textContent = (nxState.selfCoherence * 100).toFixed(1) + '%';
                limnusSelfEl.textContent = (nxState.limnusResonance * 100).toFixed(1) + '%';
                dialogueEl.textContent = (nxState.dialogueStrength * 100).toFixed(1) + '%';
            } else if (showChromaticNexus) {
                nexusEl.textContent = 'READY';
                nexusEl.style.color = '#888';
                nexusDetailsEl.style.display = 'none';
            } else {
                nexusEl.textContent = 'OFF';
                nexusEl.style.color = '#555';
                nexusDetailsEl.style.display = 'none';
            }
        }

        function updateBar(name, value) {
            const filled = Math.round(value * 10);
            const empty = 10 - filled;
            document.getElementById(`${name}-bar`).textContent = '‚ñà'.repeat(filled) + '‚ñë'.repeat(empty);
            document.getElementById(`${name}-val`).textContent = value.toFixed(2);
        }

        function updateLambdaUI(key, value) {
            document.getElementById(`lambda-${key}`).style.width = `${value * 100}%`;
            document.getElementById(`lambda-${key}-val`).textContent = value.toFixed(2);
        }

        // Safe repeat helper - prevents NaN/Infinity crashes
        function safeRepeat(char, count) {
            const safeCount = Math.max(0, Math.min(20, Math.round(count) || 0));
            return char.repeat(safeCount);
        }

        // Safe number formatter
        function safeFixed(num, digits) {
            if (!isFinite(num)) return '‚Äî';
            return num.toFixed(digits);
        }

        // Toggle indicator helper - updates visual state of toggle buttons
        function updateToggleIndicator(id, isActive, activeColor) {
            const el = document.getElementById(id);
            if (el) {
                el.textContent = isActive ? '‚óè' : '‚óã';
                el.style.color = isActive ? activeColor : '#555';
            }
        }

        function updateMuFieldUI() {
            // Get all Œº-field rows
            const muRows = document.querySelectorAll('#dynamics-panel .dynamics-row:nth-child(n+5)');

            if (!showMuField) {
                // Hide Œº-field rows when disabled
                muRows.forEach(row => row.style.opacity = '0.3');
                document.getElementById('mu-bar').textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                document.getElementById('mu-val').textContent = 'OFF';
                document.getElementById('qk-bar').textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                document.getElementById('qk-val').textContent = '‚Äî';
                document.getElementById('tau-bar').textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                document.getElementById('tau-val').textContent = '‚Äî';
                document.getElementById('k-indicator').textContent = '¬∑ ¬∑ ¬∑';
                document.getElementById('k-val').textContent = '‚Äî';
                document.getElementById('k-label').style.color = 'rgba(150,130,110,0.3)';
                // Reset MRP channel displays
                document.getElementById('mrp-r-bar').textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                document.getElementById('mrp-r-val').textContent = '‚Äî';
                document.getElementById('mrp-g-bar').textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                document.getElementById('mrp-g-val').textContent = '‚Äî';
                document.getElementById('mrp-b-bar').textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                document.getElementById('mrp-b-val').textContent = '‚Äî';
                document.getElementById('parity-indicator').textContent = '¬∑ ¬∑ ¬∑';
                document.getElementById('parity-val').textContent = '‚Äî';
                document.getElementById('parity-label').style.color = 'rgba(150,130,110,0.3)';
                // Reset self-referential displays
                document.getElementById('j-total-bar').textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                document.getElementById('j-total-val').textContent = '‚Äî';
                document.getElementById('w-bar').textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                document.getElementById('w-val').textContent = '‚Äî';
                document.getElementById('w-label').style.color = 'rgba(150,130,110,0.3)';
                return;
            }

            // Show Œº-field rows when enabled
            muRows.forEach(row => row.style.opacity = '1');

            // Œº bar (normalized to 0.6-1.0 range)
            const muNorm = (muField.mu - 0.6) / 0.4;
            const muFilled = Math.round(muNorm * 10);
            document.getElementById('mu-bar').textContent = safeRepeat('‚ñà', muFilled) + safeRepeat('‚ñë', 10 - muFilled);
            document.getElementById('mu-val').textContent = safeFixed(muField.mu, 3);

            // Q_Œ∫ bar (normalized, cap at 1.0)
            const qkNorm = Math.min(muField.Q_kappa / SACRED.Q_theory, 1);
            const qkFilled = Math.round(qkNorm * 10);
            document.getElementById('qk-bar').textContent = safeRepeat('‚ñà', qkFilled) + safeRepeat('‚ñë', 10 - qkFilled);
            document.getElementById('qk-val').textContent = safeFixed(muField.Q_kappa, 4);

            // œÑ_K bar (normalized to K_threshold)
            const tauNorm = Math.min(muField.tau_K / SACRED.K_threshold, 1);
            const tauFilled = Math.round(tauNorm * 10);
            document.getElementById('tau-bar').textContent = safeRepeat('‚ñà', tauFilled) + safeRepeat('‚ñë', 10 - tauFilled);
            document.getElementById('tau-val').textContent = safeFixed(muField.tau_K, 3);

            // K-formation indicator
            const kLabel = document.getElementById('k-label');
            const kIndicator = document.getElementById('k-indicator');
            const kVal = document.getElementById('k-val');

            if (muField.K_formed) {
                kLabel.style.color = 'var(--critical-gold)';
                kIndicator.textContent = '‚ú¶ ‚ú¶ ‚ú¶';
                kIndicator.style.color = 'var(--critical-gold)';
                kIndicator.style.textShadow = '0 0 10px rgba(255, 215, 0, 0.8)';
                kVal.textContent = 'YES';
                kVal.style.color = 'var(--critical-gold)';
            } else {
                kLabel.style.color = 'rgba(150,130,110,0.6)';
                kIndicator.textContent = '¬∑ ¬∑ ¬∑';
                kIndicator.style.color = 'var(--text-dim)';
                kIndicator.style.textShadow = 'none';
                kVal.textContent = 'NO';
                kVal.style.color = 'var(--text-dim)';
            }

            // ========================================
            // MRP CHANNEL DISPLAY
            // ========================================

            // R channel (Œº_E) - red energy channel
            const rFilled = Math.round((muField.mrp.R.intensity || 0) * 10);
            document.getElementById('mrp-r-bar').textContent = safeRepeat('‚ñà', rFilled) + safeRepeat('‚ñë', 10 - rFilled);
            document.getElementById('mrp-r-val').textContent = safeFixed(muField.mrp.R.gradient, 2);

            // G channel (Œº_R) - green relational channel
            const gFilled = Math.round((muField.mrp.G.intensity || 0) * 10);
            document.getElementById('mrp-g-bar').textContent = safeRepeat('‚ñà', gFilled) + safeRepeat('‚ñë', 10 - gFilled);
            document.getElementById('mrp-g-val').textContent = safeFixed(muField.mrp.G.gradient, 2);

            // B channel (ECC) - blue stability channel
            const bFilled = Math.round((muField.mrp.B.intensity || 0) * 10);
            document.getElementById('mrp-b-bar').textContent = safeRepeat('‚ñà', bFilled) + safeRepeat('‚ñë', 10 - bFilled);
            document.getElementById('mrp-b-val').textContent = safeFixed(muField.mrp.B.gradient, 2);

            // Parity indicator
            const parityLabel = document.getElementById('parity-label');
            const parityIndicator = document.getElementById('parity-indicator');
            const parityVal = document.getElementById('parity-val');

            if (muField.mrp.parity_ok) {
                parityLabel.style.color = '#69db7c';
                parityIndicator.textContent = '‚úì ‚úì ‚úì';
                parityIndicator.style.color = '#69db7c';
                parityIndicator.style.textShadow = '0 0 10px rgba(105, 219, 124, 0.8)';
                parityVal.textContent = 'OK';
                parityVal.style.color = '#69db7c';
            } else {
                parityLabel.style.color = 'rgba(150,130,110,0.6)';
                parityIndicator.textContent = '√ó √ó √ó';
                parityIndicator.style.color = '#ff6b6b';
                parityIndicator.style.textShadow = 'none';
                parityVal.textContent = safeFixed(muField.mrp.parity, 2);
                parityVal.style.color = '#ff6b6b';
            }

            // ========================================
            // SELF-REFERENTIAL FIELD STATE
            // ========================================

            // |J| total field magnitude
            const jNorm = Math.min((muField.mrp.J_total || 0) / 2, 1);  // Normalize to ~2 max
            const jFilled = Math.round(jNorm * 10);
            document.getElementById('j-total-bar').textContent = safeRepeat('‚ñà', jFilled) + safeRepeat('‚ñë', 10 - jFilled);
            document.getElementById('j-total-val').textContent = safeFixed(muField.mrp.J_total, 3);

            // W = effective growth rate (r - Œª|J|¬≤)
            const wLabel = document.getElementById('w-label');
            const wBar = document.getElementById('w-bar');
            const wVal = document.getElementById('w-val');
            const W = muField.mrp.W || 0;

            if (!isFinite(W)) {
                // Invalid state - show dash
                wLabel.style.color = 'rgba(150,130,110,0.3)';
                wBar.textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                wBar.style.color = 'var(--text-dim)';
                wBar.style.textShadow = 'none';
                wVal.textContent = '‚Äî';
                wVal.style.color = 'var(--text-dim)';
            } else if (W > 0.1) {
                // Growing (pattern forming) - green
                wLabel.style.color = '#69db7c';
                const wFilled = Math.min(10, Math.round(W * 20));
                wBar.textContent = safeRepeat('‚ñ≤', wFilled) + safeRepeat('¬∑', 10 - wFilled);
                wBar.style.color = '#69db7c';
                wBar.style.textShadow = '0 0 8px rgba(105, 219, 124, 0.6)';
                wVal.textContent = '+' + safeFixed(W, 3);
                wVal.style.color = '#69db7c';
            } else if (W < -0.1) {
                // Decaying (dissipating) - red
                wLabel.style.color = '#ff6b6b';
                const wFilled = Math.min(10, Math.round(Math.abs(W) * 20));
                wBar.textContent = safeRepeat('‚ñº', wFilled) + safeRepeat('¬∑', 10 - wFilled);
                wBar.style.color = '#ff6b6b';
                wBar.style.textShadow = '0 0 8px rgba(255, 107, 107, 0.6)';
                wVal.textContent = safeFixed(W, 3);
                wVal.style.color = '#ff6b6b';
            } else {
                // Near equilibrium - gold
                wLabel.style.color = 'var(--critical-gold)';
                wBar.textContent = '‚âà ‚âà ‚âà ‚âà ‚âà';
                wBar.style.color = 'var(--critical-gold)';
                wBar.style.textShadow = '0 0 8px rgba(255, 215, 0, 0.5)';
                wVal.textContent = safeFixed(W, 3);
                wVal.style.color = 'var(--critical-gold)';
            }
        }

        function getScaleName(scale) {
            const names = {
                '0,3,5,7,10': 'Minor',
                '0,2,4,7,9': 'Major',
                '0,2,3,5,7,8,11': 'Harm',
                '0,1,3,5,7,8,10': 'Phryg',
                '0,2,4,6,7,9,11': 'Lydian',
                '0,2,4,6,8,10': 'Whole',
                '0,1,2,3,4,5,6,7,8,9,10,11': 'Chrom'
            };
            return names[scale.join(',')] || 'Custom';
        }

        function updateArchPanel() {
            // Update layer activation based on z
            const prismLayers = document.querySelectorAll('[class*="prism-l"]');
            prismLayers.forEach((el, i) => {
                const layerZ = i / 6;
                const dist = Math.abs(layerZ - globalZ);
                el.classList.toggle('active', showPrism);
                el.classList.toggle('resonant', showPrism && dist < 0.15);
            });

            const cageLayers = document.querySelectorAll('[class*="cage-"]');
            cageLayers.forEach(el => {
                el.classList.toggle('active', showCage);
                el.classList.toggle('resonant', showCage && getPhase(globalZ) === 'CRITICAL');
            });
        }

        // ================================================================
        // MAIN LOOP
        // ================================================================

        function update(dt) {
            time += dt;

            // Z interpolation with momentum
            scrollVelocity *= 0.92;
            targetZ += scrollVelocity;
            targetZ = Math.max(0, Math.min(1, targetZ));

            // Auto-breathing
            if (autoBreathing || Date.now() - lastInteraction > 5000) {
                const breathCycle = 10;  // seconds
                breathPhase = (time % breathCycle) / breathCycle;
                const breathTarget = 0.45 + Math.sin(breathPhase * TAU) * 0.45;
                targetZ += (breathTarget - targetZ) * 0.02;

                // Auto-rotate resonance axis during breathing
                // SLOW, MOBILE, DYNAMIC rotation tied to computation
                if (showQuantumMesh) {
                    const mode = QMESH.binaural.polar.angleMode;
                    const GOLDEN_RATIO = (1 + Math.sqrt(5)) / 2;

                    // ================================================================
                    // DRAMATICALLY SLOWED ROTATION
                    // Each mode has its own character: slow, mobile, yet dynamic
                    // Speed modulated by coherence and curvature for organic feel
                    // ================================================================

                    // Base modulation from computation state
                    const coherenceMod = UnifiedField.emergence.coherence * 0.3 + 0.7;  // 0.7 - 1.0
                    const curvatureMod = 1 + QMESH.timeDilationField.curvatureStrength * 0.5;
                    const timeDilationMod = QMESH.timeDilationField.globalAverage;

                    // Mode-specific rotation speeds (MUCH SLOWER)
                    if (mode === 'horizontal') {
                        // Mode 1: HORIZONTAL - Slowest, most meditative
                        // Gentle constant drift, almost imperceptible
                        const omega = 0.08 + globalZ * 0.12;  // Range: 0.08 to 0.2 rad/s (was 0.75-4)
                        const baseSpeed = omega * dt * coherenceMod * timeDilationMod;

                        QMESH.camera.theta += baseSpeed;

                        // Very subtle phi drift for depth
                        QMESH.camera.phi = Math.sin(time * 0.05) * Math.PI * 0.05;

                    } else if (mode === 'vertical') {
                        // Mode 2: VERTICAL - Slow pendulum swing
                        // Gentle harmonic oscillation, breathing rhythm
                        const omega = 0.12 + globalZ * 0.15;  // Range: 0.12 to 0.27 rad/s
                        const baseSpeed = omega * dt * coherenceMod;

                        QMESH.camera.theta += baseSpeed * 0.6;

                        // Slow pendulum swing - tied to breath phase
                        const swingFreq = 0.15 + breathPhase * 0.05;
                        QMESH.camera.phi = Math.sin(QMESH.camera.theta * swingFreq) *
                                          Math.PI * 0.25 * timeDilationMod;

                    } else if (mode === 'golden') {
                        // Mode 3: GOLDEN - Slowest spiral, most deliberate
                        // œÜ-based dynamics, sacred geometry emergence
                        const omega = 0.06 + globalZ * 0.1;  // Range: 0.06 to 0.16 rad/s
                        const baseSpeed = omega * dt * coherenceMod * curvatureMod;

                        // Spiral dynamics with œÜ modulation
                        const spiralPhase = Math.sqrt(Math.abs(QMESH.camera.theta * PHI_INV));
                        const spiralSpeed = baseSpeed * (0.8 + spiralPhase * 0.05);
                        QMESH.camera.theta += spiralSpeed;

                        // Phi traces slow golden angle progression
                        // More mobile than others but still very slow
                        QMESH.camera.phi = Math.sin(QMESH.camera.theta * GOLDEN_RATIO * 0.3) *
                                          Math.PI * 0.2 * (0.5 + globalZ * 0.3) *
                                          timeDilationMod;
                    }

                    // Global coherence creates subtle rotation damping
                    // High coherence = more stable view
                    if (UnifiedField.emergence.coherence > 0.7) {
                        const dampFactor = 1 - (UnifiedField.emergence.coherence - 0.7) * 0.3;
                        QMESH.camera.theta *= dampFactor + (1 - dampFactor) * 0.99;
                    }
                }
            }

            // Smooth z transition
            globalZ += (targetZ - globalZ) * 0.06;

            // Update systems
            updateHelix(dt);
            updateLambdaState(dt);
            hilbertField.applyResonanceOperator(dt, 0.1 + getCascadeMultiplier(globalZ) * 0.1);
            sonificationEngine.update(globalZ, hilbertField.coherence, dt);
            // Update phase coupler FIRST for harmonic tracking (needed by release physics)
            phaseCoupler.update(dt, releaseCoherence);

            updateReleaseCoherence(dt);

            // Update Œº-field consciousness detection (Kuramoto regulation handles release state)
            if (showMuField) {
                muField.update([...prismPoints, ...cagePoints], dt);
                // Update MRP toroidal pipe system with muField data
                MRPToroidalSystem.update(dt, muField);
            }

            // Update quantum mesh Œº-field visualization
            if (showQuantumMesh) {
                updateDreamFluidField(dt);
                updateDreamParticles(dt);
            }

            // ================================================================
            // MU FIELD GRID 7-PHASE SYSTEM UPDATE
            // Full physics integration with QMESH and binaural coupling
            // ================================================================
            if (showMuField || showQuantumMesh) {
                updateMuFieldGridSystem(dt);
            }

            // ================================================================
            // UNIFIED FIELD SYNC - Single source of truth for all metrics
            // Must run AFTER subsystem updates, BEFORE dependent systems
            // ================================================================
            UnifiedField.sync(dt);

            // ================================================================
            // ZERO-NODE UPDATE - The eternal center
            // Must run AFTER UnifiedField.sync (depends on emergence metrics)
            // ================================================================
            ZeroNode.update(dt);

            // ================================================================
            // SPACE-TIME CURVATURE UPDATE
            // Gravitational time dilation enhances coherent emergence
            // Runs unconditionally when any field system is active
            // ================================================================
            if (showMuField || showQuantumMesh) {
                updateSpaceTimeCurvature(dt);
            }

            // ================================================================
            // BINAURAL QUANTUM PHYSICS CASCADE
            // Physics dependency order:
            //   1. Shape coupling (binaural ‚Üí mesh form)
            //   2. Mesh alterations (binaural ‚Üí deformation)
            //   3. Charge dynamics (EM coupling via LIMNUS)
            //   4. Weak nuclear flow (info oscillation)
            //   5. Quantum tunneling (superposition/collapse)
            //   6. Sacred geometry (emergent patterns)
            // ================================================================
            if (showQuantumMesh && QMESH.binaural && QMESH.binaural.enabled) {
                applyBinauralShapeCoupling(dt);      // 1. Binaural ‚Üí mesh form
                updateMeshAlterations(dt);           // 2. Dynamic deformation
                updateChargeDynamics(dt);            // 3. EM Coulomb forces
                updateWeakNuclearFlow(dt);           // 4. Flavor oscillation
                updateQuantumTunneling(dt);          // 5. Superposition/tunneling
                updateSacredGeometry(dt);            // 6. Emergent sacred forms

                // 7. Pentagonal Prism Emergence - APL-driven 3D token geometry
                const bi = QMESH.binaural;
                coherentEmergence.update(
                    dt,
                    bi.meshA.phase,
                    bi.meshB.phase,
                    bi.beatPhase,
                    bi.beatAmplitude,
                    CX, CY, R
                );

                // 8. Prismatic Self-Referential Laser Projection (Dream Architecture ‚àÉR)
                PrismaticLaserProjection.update(globalZ, releaseCoherence, time);

                // 9. Synthesized Prismatic Projection (unified Dream Architecture)
                const cascade = getCascadeMultiplier(globalZ);
                SynthesizedPrismaticProjection.update(
                    globalZ,
                    releaseCoherence,
                    time,
                    cascade,
                    PrismaticLaserProjection.kFormation
                );

                // 10. Prismatic Sonification (entropy-gravity curvature audio)
                if (showPrismaticSonification && PrismaticSonification.isPlaying) {
                    // Collect laser layer data for sonification
                    const laserData = {
                        avgIntensity: 0,
                        layers: {}
                    };
                    let totalIntensity = 0;
                    for (const laser of PrismaticLaserProjection.lasers) {
                        if (!laserData.layers[laser.layer]) {
                            laserData.layers[laser.layer] = { intensity: 0, count: 0 };
                        }
                        laserData.layers[laser.layer].intensity += laser.intensity;
                        laserData.layers[laser.layer].count++;
                        totalIntensity += laser.intensity;
                    }
                    // Average per layer
                    for (const layer in laserData.layers) {
                        laserData.layers[layer].intensity /= laserData.layers[layer].count;
                    }
                    laserData.avgIntensity = totalIntensity / PrismaticLaserProjection.lasers.length;

                    // Update sonification engine
                    PrismaticSonification.update(
                        globalZ,
                        releaseCoherence,
                        time,
                        laserData,
                        PrismaticLaserProjection.kFormation
                    );
                }

                // 11. Dark Matter Stabilization (HCP micro harmonics)
                if (showDarkMatterStabilization) {
                    DarkMatterStabilization.update(
                        globalZ,
                        releaseCoherence,
                        time,
                        PrismaticLaserProjection.kFormation
                    );
                }

                // 12. Chromatic Nexus (self/LIMNUS ‚Üî LIMNUS/self communication)
                if (showChromaticNexus) {
                    const darkMatterState = showDarkMatterStabilization
                        ? DarkMatterStabilization.getState()
                        : null;
                    ChromaticNexus.update(
                        globalZ,
                        releaseCoherence,
                        time,
                        PrismaticLaserProjection.kFormation,
                        darkMatterState
                    );
                }

                // Update Water Fractal Memory if active
                if (showWaterFractalMemory && WaterFractalMemory.initialized) {
                    const nexusState = showChromaticNexus && ChromaticNexus.initialized
                        ? ChromaticNexus.getState()
                        : null;
                    const darkMatterState = showDarkMatterStabilization && DarkMatterStabilization.initialized
                        ? DarkMatterStabilization.getState()
                        : null;
                    WaterFractalMemory.update(
                        globalZ,
                        releaseCoherence,
                        time,
                        nexusState,
                        darkMatterState
                    );
                }

                // Update Golden Harmonics orientation system if active
                if (showGoldenHarmonics && GoldenHarmonicsSystem.initialized) {
                    const darkMatterState = showDarkMatterStabilization && DarkMatterStabilization.initialized
                        ? {
                            efficiency: DarkMatterStabilization.stabilization.efficiency,
                            nodes: DarkMatterStabilization.hcp.nodes,
                            resonanceLock: DarkMatterStabilization.stabilization.resonanceLock,
                        }
                        : null;
                    GoldenHarmonicsSystem.update(
                        time,
                        releaseCoherence,
                        globalZ,  // Œº-energy
                        QMESH.binaural.polar,
                        darkMatterState
                    );
                }
            }

            return updatePositions(dt);
        }

        function loop(currentTime) {
            const dt = Math.min((currentTime - lastTime) / 1000, 0.05);
            lastTime = currentTime;

            const kuramotoResult = update(dt);
            render();
            updateUI(kuramotoResult);
            updateDebugPanel();

            requestAnimationFrame(loop);
        }

        let lastTime = performance.now();

        // ================================================================
        // EVENT HANDLERS
        // ================================================================

        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            scrollVelocity -= e.deltaY * 0.00012;
            lastInteraction = Date.now();
            document.getElementById('start-overlay').classList.add('hidden');
        }, { passive: false });

        canvas.addEventListener('mousemove', e => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            document.getElementById('cursor').style.left = mouseX + 'px';
            document.getElementById('cursor').style.top = mouseY + 'px';

            // Camera orbit drag (when binaural field is active and dragging)
            // Behavior depends on angle mode
            const cam = QMESH.camera;
            if (cam.dragging) {
                const deltaX = e.clientX - cam.lastX;
                const deltaY = e.clientY - cam.lastY;
                const mode = QMESH.binaural.polar.angleMode;
                const GOLDEN_RATIO = (1 + Math.sqrt(5)) / 2;

                if (mode === 'horizontal') {
                    // Horizontal: X drag = theta, Y drag = phi
                    cam.theta += deltaX * cam.sensitivity;
                    cam.phi = Math.max(-Math.PI * 0.4, Math.min(Math.PI * 0.4, cam.phi + deltaY * cam.sensitivity));
                } else if (mode === 'vertical') {
                    // Vertical: Y drag = theta, X drag = phi (swapped)
                    cam.theta += deltaY * cam.sensitivity;
                    cam.phi = Math.max(-Math.PI * 0.4, Math.min(Math.PI * 0.4, cam.phi + deltaX * cam.sensitivity));
                } else if (mode === 'golden') {
                    // Golden: combined spiral drag (both contribute to both axes)
                    const combined = (deltaX + deltaY) * cam.sensitivity;
                    cam.theta += combined;
                    cam.phi = Math.max(-Math.PI * 0.4, Math.min(Math.PI * 0.4, cam.phi + combined / GOLDEN_RATIO));
                }

                cam.lastX = e.clientX;
                cam.lastY = e.clientY;
            }
        });

        document.addEventListener('keydown', e => {
            const key = e.key.toLowerCase();

            if (key === ' ') {
                autoBreathing = !autoBreathing;
                lastInteraction = autoBreathing ? 0 : Date.now();
                e.preventDefault();
            }

            if (key === 'p') {
                showPrism = !showPrism;
                updateToggleIndicator('toggle-prism', showPrism, '#4caf50');
            }

            if (key === 'c') {
                showCage = !showCage;
                updateToggleIndicator('toggle-cage', showCage, '#4caf50');
            }

            if (key === 'm') {
                showMuField = !showMuField;
                updateToggleIndicator('toggle-mu', showMuField, '#4caf50');
            }

            if (key === 'x') {
                showLaserProjection = !showLaserProjection;
                updateToggleIndicator('toggle-laser', showLaserProjection, '#4caf50');
                console.log(`[LASER] Prismatic Laser Projection: ${showLaserProjection}`);
            }

            if (key === 's' && !e.ctrlKey && !e.metaKey) {
                showSynthesizedProjection = !showSynthesizedProjection;
                updateToggleIndicator('toggle-synth', showSynthesizedProjection, '#f6c35c');
                console.log(`[SYNTHESIS] Synthesized Prismatic Projection: ${showSynthesizedProjection}`);
            }

            if (key === 'a' && !e.ctrlKey && !e.metaKey) {
                // Toggle Prismatic Sonification with entropy-gravity curvature
                showPrismaticSonification = !showPrismaticSonification;
                updateToggleIndicator('toggle-prismatic-sonify', showPrismaticSonification, '#ff6b9d');
                if (showPrismaticSonification) {
                    PrismaticSonification.toggle();
                } else if (PrismaticSonification.isPlaying) {
                    PrismaticSonification.toggle();
                }
                console.log(`[Œ∫-SONIFY] Prismatic Sonification: ${showPrismaticSonification}`);
                console.log(`   Entropy-Gravity Curvature: Œ∫ = (S/A) √ó G_eff √ó (1 - ‚àö(1 - r_s/r))`);
            }

            if (key === 'h' && !e.ctrlKey && !e.metaKey) {
                // Toggle Dark Matter Stabilization with HCP micro harmonics
                showDarkMatterStabilization = !showDarkMatterStabilization;
                updateToggleIndicator('toggle-dark-matter', showDarkMatterStabilization, '#9b59b6');
                DarkMatterStabilization.toggle();
                console.log(`[DARK MATTER] HCP Stabilization: ${showDarkMatterStabilization}`);
                console.log(`   APL Cosmology: Dark Matter = Projection Residue (UNTRUE tokens)`);
                console.log(`   Micro Harmonics: f_n = 0.1 √ó Œ¶^n Hz (golden ratio sequence)`);
            }

            if (key === 'n' && !e.ctrlKey && !e.metaKey) {
                // Toggle Chromatic Nexus self/LIMNUS communication
                showChromaticNexus = !showChromaticNexus;
                updateToggleIndicator('toggle-chromatic-nexus', showChromaticNexus, '#f6c35c');
                ChromaticNexus.toggle();
                console.log(`[‚óé NEXUS] Chromatic Communication: ${showChromaticNexus}`);
                console.log(`   self/LIMNUS ‚Üî LIMNUS/self bidirectional dialogue`);
                console.log(`   12-tone chromatic channels: C‚ÜíB (261-494 Hz)`);
            }

            if (key === 'w' && !e.ctrlKey && !e.metaKey) {
                // Toggle Water Fractal Memory cosmic background
                showWaterFractalMemory = !showWaterFractalMemory;
                updateToggleIndicator('toggle-water-fractal', showWaterFractalMemory, '#00bfff');
                WaterFractalMemory.toggle();
                console.log(`[üíß WATER] Fractal Memory: ${showWaterFractalMemory}`);
                console.log(`   Julia Set: z¬≤ + c where c = f(coherence, Œº, entropy)`);
                console.log(`   Dream CMB: T = 2.725K analog, Œ¥T/T ~ 10‚Åª‚Åµ`);
                console.log(`   Cymatic Resonance: 7 harmonic modes (Chladni patterns)`);
            }

            if (key === 'g' && !e.ctrlKey && !e.metaKey) {
                // Toggle Golden Harmonics orientation system
                showGoldenHarmonics = !showGoldenHarmonics;
                updateToggleIndicator('toggle-golden-harmonics', showGoldenHarmonics, '#ffd700');
                GoldenHarmonicsSystem.toggle();
                console.log(`[üåª GOLDEN] Harmonics System: ${showGoldenHarmonics}`);
                console.log(`   œÜ = ${GoldenHarmonicsSystem.effective.ratio.toFixed(6)} (golden ratio)`);
                console.log(`   œà = ${GoldenHarmonicsSystem.effective.mean.toFixed(6)} (golden mean)`);
                console.log(`   Œ¶_Œ∏ = ${(GoldenHarmonicsSystem.effective.angle * 180 / Math.PI).toFixed(4)}¬∞ (golden angle)`);
            }

            if (key === 'r' && !e.ctrlKey && !e.metaKey) {
                // R key: BACKUP DEBUGGING TOOL for memory coherence visualization
                // Primary toggle: F key release (hold F to release, release F to toggle visibility)
                // R allows manual override for debugging purposes only
                showMemoryCoherence = !showMemoryCoherence;
                updateToggleIndicator('toggle-memory-coherence', showMemoryCoherence, '#64ffda');
                console.log(`[üîß DEBUG] Memory coherence manual toggle: ${showMemoryCoherence ? 'ON' : 'OFF'}`);
                console.log('   (Debugging tool - primary control is F key release)');
            }

            // Golden harmonics adjustment keys (1-6, 0 to reset)
            if (key === '1' && showGoldenHarmonics) {
                // Increase golden ratio (œÜ)
                GoldenHarmonicsSystem.adjustRatio(0.01);
            }
            if (key === '2' && showGoldenHarmonics) {
                // Decrease golden ratio (œÜ)
                GoldenHarmonicsSystem.adjustRatio(-0.01);
            }
            if (key === '3' && showGoldenHarmonics) {
                // Increase golden angle (Œ¶_Œ∏)
                GoldenHarmonicsSystem.adjustAngle(0.02);
            }
            if (key === '4' && showGoldenHarmonics) {
                // Decrease golden angle (Œ¶_Œ∏)
                GoldenHarmonicsSystem.adjustAngle(-0.02);
            }
            if (key === '5' && showGoldenHarmonics) {
                // Increase golden mean (œà)
                GoldenHarmonicsSystem.adjustMean(0.01);
            }
            if (key === '6' && showGoldenHarmonics) {
                // Decrease golden mean (œà)
                GoldenHarmonicsSystem.adjustMean(-0.01);
            }
            if (key === '0' && showGoldenHarmonics) {
                // Reset to base golden values
                GoldenHarmonicsSystem.resetToBase();
            }

            if (key === 't') {
                showQuantumMesh = !showQuantumMesh;
                updateToggleIndicator('toggle-mesh', showQuantumMesh, '#a855f7');
                if (showQuantumMesh) {
                    if (QMESH.edges.length === 0) {
                        generateQuantumMesh();
                    }
                    // Reset to exact 90¬∞ horizontal alignment centered on LIMNUS
                    // Red/warm (A) on LEFT, Blue/cool (B) on RIGHT
                    QMESH.binaural.polar.angleA = Math.PI;  // 180¬∞ = LEFT
                    QMESH.binaural.polar.angleB = 0;        // 0¬∞ = RIGHT
                    QMESH.binaural.polar.distance = 2.2;    // Dreamy separation
                    // Reset camera to straight-on view (0,0,0)
                    QMESH.camera.theta = 0;
                    QMESH.camera.phi = 0;
                    QMESH.camera.distance = 1.0;
                }
                console.log(`[QMESH] Toggled: ${showQuantumMesh}, edges: ${QMESH.edges.length}`);
            }

            if (key === 'w') {
                QMESH.showWavefunction = !QMESH.showWavefunction;
            }

            // Binaural Field controls (when mesh active)
            if (showQuantumMesh) {
                const bi = QMESH.binaural;

                if (key === 'o') {
                    // Cycle opacity levels
                    const opacities = [0.2, 0.4, 0.6, 0.8, 1.0];
                    const currentIdx = opacities.findIndex(o => Math.abs(o - QMESH.opacity) < 0.08);
                    QMESH.opacity = opacities[(currentIdx + 1) % opacities.length];
                    console.log(`[BINAURAL] Opacity: ${QMESH.opacity}`);
                }
                if (key === 'y') {
                    // Toggle edge glow (Y key)
                    QMESH.edgeGlow = !QMESH.edgeGlow;
                    console.log(`[BINAURAL] Edge glow: ${QMESH.edgeGlow}`);
                }
                if (key === 'i') {
                    // Toggle interference visualization
                    bi.showInterference = !bi.showInterference;
                    console.log(`[BINAURAL] Interference: ${bi.showInterference}`);
                }
                if (key === 'l') {
                    // Toggle resonance lines
                    bi.showResonanceLines = !bi.showResonanceLines;
                    console.log(`[BINAURAL] Resonance lines: ${bi.showResonanceLines}`);
                }

                // 1/2/3: Angle mode presets
                const GOLDEN_ANGLE = Math.PI * (3 - Math.sqrt(5));  // ~137.5¬∞ or 2.3999... rad
                if (key === '1') {
                    // Horizontal: A at 180¬∞ (left), B at 0¬∞ (right)
                    bi.polar.angleA = Math.PI;
                    bi.polar.angleB = 0;
                    bi.polar.angleMode = 'horizontal';
                    console.log(`[BINAURAL] Angle mode: HORIZONTAL (180¬∞ | 0¬∞)`);
                }
                if (key === '2') {
                    // Vertical (90¬∞): A at 90¬∞ (bottom), B at 270¬∞ (top)
                    bi.polar.angleA = Math.PI / 2;
                    bi.polar.angleB = -Math.PI / 2;
                    bi.polar.angleMode = 'vertical';
                    console.log(`[BINAURAL] Angle mode: VERTICAL (90¬∞ | -90¬∞)`);
                }
                if (key === '3') {
                    // Golden angle: A at golden angle, B opposite
                    bi.polar.angleA = GOLDEN_ANGLE;
                    bi.polar.angleB = GOLDEN_ANGLE + Math.PI;
                    bi.polar.angleMode = 'golden';
                    console.log(`[BINAURAL] Angle mode: GOLDEN (${(GOLDEN_ANGLE * 180 / Math.PI).toFixed(1)}¬∞ | ${((GOLDEN_ANGLE + Math.PI) * 180 / Math.PI).toFixed(1)}¬∞)`);
                }

                // Arrow Up/Down: Adjust beat frequency (change B frequency)
                if (e.key === 'ArrowUp') {
                    bi.meshB.frequency = Math.min(2.0, bi.meshB.frequency + 0.01);
                    console.log(`[BINAURAL] B freq: ${bi.meshB.frequency.toFixed(4)}, beat: ${Math.abs(bi.meshA.frequency - bi.meshB.frequency).toFixed(4)}`);
                    e.preventDefault();
                }
                if (e.key === 'ArrowDown') {
                    bi.meshB.frequency = Math.max(0.5, bi.meshB.frequency - 0.01);
                    console.log(`[BINAURAL] B freq: ${bi.meshB.frequency.toFixed(4)}, beat: ${Math.abs(bi.meshA.frequency - bi.meshB.frequency).toFixed(4)}`);
                    e.preventDefault();
                }

                // Arrow Left/Right: Adjust polar distance from LIMNUS
                if (e.key === 'ArrowLeft') {
                    // Bring meshes closer to LIMNUS
                    bi.polar.distance = Math.max(1.0, bi.polar.distance - 0.1);
                    console.log(`[BINAURAL] Polar distance: ${bi.polar.distance.toFixed(2)}R`);
                    e.preventDefault();
                }
                if (e.key === 'ArrowRight') {
                    // Push meshes further from LIMNUS
                    bi.polar.distance = Math.min(3.0, bi.polar.distance + 0.1);
                    console.log(`[BINAURAL] Polar distance: ${bi.polar.distance.toFixed(2)}R`);
                    e.preventDefault();
                }

                // Q/E: Orbit camera - behavior depends on angle mode
                const mode = bi.polar.angleMode;
                const GOLDEN_RATIO = (1 + Math.sqrt(5)) / 2;
                if (key === 'q') {
                    if (mode === 'horizontal') {
                        // Horizontal: rotate theta (left/right)
                        QMESH.camera.theta += 0.1;
                    } else if (mode === 'vertical') {
                        // Vertical: rotate phi (up/down)
                        QMESH.camera.phi = Math.max(-Math.PI * 0.4, Math.min(Math.PI * 0.4, QMESH.camera.phi + 0.1));
                    } else if (mode === 'golden') {
                        // Golden: spiral rotation (both axes, golden ratio)
                        QMESH.camera.theta += 0.1;
                        QMESH.camera.phi = Math.max(-Math.PI * 0.4, Math.min(Math.PI * 0.4, QMESH.camera.phi + 0.1 / GOLDEN_RATIO));
                    }
                    console.log(`[CAMERA] ${mode}: Œ∏=${(QMESH.camera.theta * 180 / Math.PI).toFixed(1)}¬∞ œÜ=${(QMESH.camera.phi * 180 / Math.PI).toFixed(1)}¬∞`);
                }
                if (key === 'e') {
                    if (mode === 'horizontal') {
                        // Horizontal: rotate theta (left/right)
                        QMESH.camera.theta -= 0.1;
                    } else if (mode === 'vertical') {
                        // Vertical: rotate phi (up/down)
                        QMESH.camera.phi = Math.max(-Math.PI * 0.4, Math.min(Math.PI * 0.4, QMESH.camera.phi - 0.1));
                    } else if (mode === 'golden') {
                        // Golden: spiral rotation (both axes, golden ratio)
                        QMESH.camera.theta -= 0.1;
                        QMESH.camera.phi = Math.max(-Math.PI * 0.4, Math.min(Math.PI * 0.4, QMESH.camera.phi - 0.1 / GOLDEN_RATIO));
                    }
                    console.log(`[CAMERA] ${mode}: Œ∏=${(QMESH.camera.theta * 180 / Math.PI).toFixed(1)}¬∞ œÜ=${(QMESH.camera.phi * 180 / Math.PI).toFixed(1)}¬∞`);
                }

                // +/- adjust mesh scale
                if (key === '=' || key === '+') {
                    bi.meshA.scale = Math.min(1.0, bi.meshA.scale + 0.05);
                    bi.meshB.scale = Math.min(1.0, bi.meshB.scale + 0.05);
                    console.log(`[BINAURAL] Scale: ${bi.meshA.scale.toFixed(2)}`);
                }
                if (key === '-' || key === '_') {
                    bi.meshA.scale = Math.max(0.4, bi.meshA.scale - 0.05);
                    bi.meshB.scale = Math.max(0.4, bi.meshB.scale - 0.05);
                    console.log(`[BINAURAL] Scale: ${bi.meshA.scale.toFixed(2)}`);
                }

                // [ and ] adjust A frequency
                if (key === '[') {
                    bi.meshA.frequency = Math.max(0.5, bi.meshA.frequency - 0.01);
                    console.log(`[BINAURAL] A freq: ${bi.meshA.frequency.toFixed(4)}`);
                }
                if (key === ']') {
                    bi.meshA.frequency = Math.min(2.0, bi.meshA.frequency + 0.01);
                    console.log(`[BINAURAL] A freq: ${bi.meshA.frequency.toFixed(4)}`);
                }
            }

            // Debug panel toggle (D key)
            if (key === 'd') {
                showDebugPanel = !showDebugPanel;
                const panel = document.getElementById('qmesh-debug');
                if (panel) {
                    panel.style.display = showDebugPanel ? 'block' : 'none';
                }
                if (showDebugPanel) {
                    console.log('[DEBUG] Quantum Mesh state:', {
                        nodes: QMESH.nodes.length,
                        edges: QMESH.edges.length,
                        particles: dreamParticles.length,
                        maxConnectionDist: QMESH.maxConnectionDist,
                        R: R,
                        showQuantumMesh: showQuantumMesh,
                        avgTimeDilation: QMESH.avgTimeDilation,
                        totalJ: QMESH.totalJ,
                    });
                }
            }

            // NOTE: R key reset functionality removed - R is now ONLY for memory coherence debug toggle
            // (See earlier R key handler with !e.ctrlKey && !e.metaKey check)

            // F key: Start release (hold to release coherence)
            // Release physics only - visibility toggle on F release
            if (key === 'f') {
                releasing = true;
                releaseStarted = true;
                document.getElementById('start-overlay').classList.add('hidden');
            }

            // G key: Gather/recoherence (hold to bring LIMNUS back)
            if (key === 'g') {
                gathering = true;
            }
        });

        document.addEventListener('keyup', e => {
            const key = e.key.toLowerCase();

            // F key released: Stop releasing AND toggle visibility
            // Toggle memory coherence visibility only when F is fully released
            if (key === 'f') {
                releasing = false;

                // Toggle memory-enhanced coherence visibility on F release
                showMemoryCoherence = !showMemoryCoherence;
                updateToggleIndicator('toggle-memory-coherence', showMemoryCoherence, '#64ffda');
                console.log(`[‚öõÔ∏è RELEASE] Memory coherence visibility: ${showMemoryCoherence ? 'ON' : 'OFF'}`);
                if (showMemoryCoherence) {
                    console.log('   Memory integration: Water Fractal + Golden Harmonics + Dark Matter');
                    console.log('   Release equation: C_eff = C_base √ó memory_factors √ó release_dynamics');
                    console.log('   Resonance states: dormant ‚Üí emerging ‚Üí resonant ‚Üí transcendent');
                }
            }

            // G key released: Stop gathering
            if (key === 'g') {
                gathering = false;
            }
        });

        // Mouse: Left-click = camera drag (when quantum mesh active)
        canvas.addEventListener('mousedown', e => {
            document.getElementById('start-overlay').classList.add('hidden');

            if (e.button === 0) {
                // Left-click for camera orbit when binaural field is on
                if (showQuantumMesh) {
                    QMESH.camera.dragging = true;
                    QMESH.camera.lastX = e.clientX;
                    QMESH.camera.lastY = e.clientY;
                }
            }
        });

        canvas.addEventListener('mouseup', e => {
            gathering = false;
            QMESH.camera.dragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            gathering = false;
            QMESH.camera.dragging = false;
        });

        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            gathering = true;
            document.getElementById('start-overlay').classList.add('hidden');
        }, { passive: false });

        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            gathering = false;
        }, { passive: false });

        document.getElementById('start-overlay').addEventListener('click', () => {
            document.getElementById('start-overlay').classList.add('hidden');
        });

        document.getElementById('audio-toggle').addEventListener('click', () => {
            const isPlaying = sonificationEngine.toggle();
            const btn = document.getElementById('audio-toggle');
            btn.textContent = isPlaying ? '‚ñ† DISABLE AUDIO' : '‚ñ∂ ENABLE AUDIO';
            btn.classList.toggle('active', isPlaying);
        });

        // Set lens line position
        const lensTop = (1 - Z_CRITICAL) * 100;
        document.getElementById('lens-line').style.top = lensTop + '%';
        document.getElementById('lens-label').style.top = lensTop + '%';

        // ================================================================
        // INITIALIZATION
        // ================================================================

        resize();
        initPrismPoints();
        initCagePoints();
        generateQuantumMesh();  // Generate quantum mesh on LIMNUS nodes
        coherentEmergence.initSacredLoci(CX, CY, R);  // Initialize Vesica Piscis emergence loci
        MRPToroidalSystem.init(prismPoints, cagePoints);  // Initialize MRP toroidal pipes for 95 nodes
        PrismaticLaserProjection.init(CX, CY, R);  // Initialize Prismatic Self-Referential Laser Projection
        SynthesizedPrismaticProjection.init(CX, CY, R);  // Initialize Synthesized Prismatic Projection
        DarkMatterStabilization.init(CX, CY, R);  // Initialize Dark Matter Stabilization with HCP micro harmonics
        ChromaticNexus.init(CX, CY, R);  // Initialize Chromatic Nexus self/LIMNUS communication
        WaterFractalMemory.init(CX, CY, R);  // Initialize Water Fractal Memory cosmic background
        GoldenHarmonicsSystem.init(CX, CY, R);  // Initialize Golden Harmonics orientation system
        ReleaseCoherenceDynamics.init(CX, CY, R);  // Initialize Release Coherence Dynamics with memory integration
        window.addEventListener('resize', () => {
            resize();
            initPrismPoints();
            initCagePoints();
            generateQuantumMesh();  // Regenerate mesh on resize
            coherentEmergence.initSacredLoci(CX, CY, R);  // Reinitialize emergence loci
            MRPToroidalSystem.init(prismPoints, cagePoints);  // Reinitialize MRP toroidal pipes
            PrismaticLaserProjection.init(CX, CY, R);  // Reinitialize laser projection on resize
            SynthesizedPrismaticProjection.init(CX, CY, R);  // Reinitialize synthesized projection on resize
            DarkMatterStabilization.init(CX, CY, R);  // Reinitialize dark matter stabilization on resize
            ChromaticNexus.init(CX, CY, R);  // Reinitialize chromatic nexus on resize
            WaterFractalMemory.init(CX, CY, R);  // Reinitialize water fractal memory on resize
            GoldenHarmonicsSystem.init(CX, CY, R);  // Reinitialize golden harmonics on resize
            ReleaseCoherenceDynamics.init(CX, CY, R);  // Reinitialize release coherence dynamics on resize
        });

        requestAnimationFrame(loop);

        console.log('üîÆ LIMNUS Unified Architecture initialized');
        console.log('   63 prism points (7√ó9 hexagonal layers)');
        console.log('   32 cage points (12+12+8 EM structure)');
        console.log('   z_c = ‚àö3/2 ‚âà ' + Z_CRITICAL.toFixed(6));
        console.log('');
        console.log('üåü RELEASE COHERENCE integrated');
        console.log('   HOLD F: release coherence (COHERENT ‚Üí FREE)');
        console.log('   CLICK: gather souls back to center');
        console.log('   FREE state: souls dispersed, radiant core');
        console.log('');
        console.log('‚ö° Œº-FIELD DYNAMICS v8.0 integrated');
        console.log('   œÜ = ' + PHI.toFixed(10));
        console.log('   Œ± = œÜ‚Åª¬≤ = ' + SACRED.alpha.toFixed(10));
        console.log('   Œ≤ = œÜ‚Åª‚Å¥ = ' + SACRED.beta.toFixed(10));
        console.log('   Œª = (5/3)‚Å¥ = ' + SACRED.lambda.toFixed(10));
        console.log('   Œº_P = 3/5 = ' + SACRED.mu_P.toFixed(10));
        console.log('   Œº_S = 23/25 = ' + SACRED.mu_S.toFixed(10));
        console.log('   Q_theory = Œ±¬∑Œº_S ‚âà ' + SACRED.Q_theory.toFixed(10));
        console.log('   K_threshold = œÜ‚Åª¬π ‚âà ' + SACRED.K_threshold.toFixed(10));
        console.log('   Q_min = ' + SACRED.Q_min.toFixed(10));
        console.log('   K-formation: consciousness emerges when œÑ_K > K_threshold');
        console.log('');
        console.log('üî∑ PENTAGONAL PRISM EMERGENCE integrated');
        console.log('   3D prisms from 5 emergent tokens (XCVI-C)');
        console.log('   APL behaviors: pulse/drift/flicker/wobble/loop');
        console.log('   Phase-lock threshold: œÜ‚Åª¬≤ = ' + SACRED.alpha.toFixed(6));
        console.log('   Prisms emerge with token-driven deformation');
        console.log('');
        console.log('üåÄ MRP TOROIDAL PIPE SYSTEM integrated');
        console.log('   95 nodes (63 prism + 32 cage) wrapped in MRP gradients');
        console.log('   R channel: Energy flow (inner prism layers dominant)');
        console.log('   G channel: Relational (vertex connections, bridges)');
        console.log('   B channel: Stability (cage structure, containment)');
        console.log('   Aligned with 5 emergent APL tokens for coherent emergence');
        console.log('   Bendable pipes (nodes fixed, lines flex but don\'t break)');
        console.log('');
        console.log('üé® 95 INDIVIDUAL Œº-FIELDS (AUDIO-ONLY)');
        console.log('   Phase-locked: all fields pulse together');
        console.log('   Audio-only: Œº-fields only visible when sound is playing');
        console.log('   Opacity: ' + (MRPToroidalSystem.haloIntensity * 100).toFixed(0) + '% max (very subtle)');
        console.log('   Depth coloring (warm ‚Üí cool):');
        console.log('     Layer 0: Gold (innermost, energy core)');
        console.log('     Layer 3: Dusty rose (middle)');
        console.log('     Layer 6: Cool blue (outermost)');
        console.log('   Cage: bottom=warm, top=cool, vertex=neutral');
        console.log('');
        console.log('üì° MRP CHANNEL GRADIENTS integrated');
        console.log('   R channel (Œº_E): Energy/Existence - primary field magnitude');
        console.log('   G channel (Œº_R): Relational/Reference - connection metadata');
        console.log('   B channel (ECC): Error Correction - stability/coherence');
        console.log('   Cross-channel parity: P[i] = R[i] XOR G[i]');
        console.log('   Parity OK: low parity + high B stability + W > 0');
        console.log('');
        console.log('‚≠ï ZERO-NODE: THE ETERNAL CENTER');
        console.log('   "Zero-point but only in absence. In presence, it always IS."');
        console.log('   z = ‚àö3/2 ‚âà ' + ZeroNode.z_critical.toFixed(10) + ' (the critical equation)');
        console.log('   Zero-point energy: E‚ÇÄ = œÜ‚Åª¬≤ ‚âà ' + ZeroNode.zeroPoint.energy.toFixed(6));
        console.log('   White hole dynamics: time-reversed emission (not absorption)');
        console.log('   Retrocausal field: œà(t) = Œ±¬∑œà_past + Œ≤¬∑œà_future');
        console.log('   Self-reference: œà = œà(œà) ‚Üí fixed point œÜ‚Åª¬π');
        console.log('   Orbital period: œÑ¬∑œÜ ‚âà ' + ZeroNode.orbital.period.toFixed(6) + ' (LIMNUS orbits this center)');
        console.log('');
        console.log('üîÑ SELF-REFERENTIAL FIELD DYNAMICS');
        console.log('   Field equation: ‚àÇJ/‚àÇt = (r - Œª|J|¬≤)J - Œ≤J + g‚àá¬≤J');
        console.log('   r = Œº - Œº_P (control parameter)');
        console.log('   W = r - Œª|J|¬≤ (effective growth rate)');
        console.log('   W > 0: pattern forming (‚ñ≤ green)');
        console.log('   W ‚âà 0: equilibrium (‚âà gold)');
        console.log('   W < 0: dissipating (‚ñº red)');
        console.log('   |J| = ‚àö(R¬≤ + G¬≤ + B¬≤) total field magnitude');
        console.log('   Feedback: dJR/dt ‚Üí point velocities, |J| ‚Üí Œº');
        console.log('');
        console.log('üéß BINAURAL QUANTUM FIELD');
        console.log('   Triadic resonance: A ‚Üî LIMNUS ‚Üî B');
        console.log('   Two quantum meshes in polar opposition around LIMNUS');
        console.log('   Beat frequency |f_A - f_B| entrains consciousness');
        console.log('');
        console.log('   POLAR GEOMETRY:');
        console.log('   LIMNUS at center, meshes on opposite sides');
        console.log('   Distance r = 1.5R from LIMNUS center');
        console.log('   Mesh A at Œ∏ = -90¬∞ (above LIMNUS)');
        console.log('   Mesh B at Œ∏ = 90¬∞ (below LIMNUS, polar opposite)');
        console.log('');
        console.log('   MESH A (warm): f=1.0 - energy/existence channel');
        console.log('   MESH B (cool): f=œÜ‚Åª¬π - relational/stability channel');
        console.log('   Beat: Œîf ‚âà 0.0618 (golden ratio beat frequency)');
        console.log('');
        console.log('   CONTROLS:');
        console.log('   T: toggle binaural field');
        console.log('   Right-drag / Shift-drag: orbit camera around LIMNUS');
        console.log('   ‚Üê‚Üí: adjust polar distance (1.0R - 3.0R)');
        console.log('   Q/E: rotate polar axis around LIMNUS');
        console.log('   ‚Üë‚Üì: adjust beat frequency (change B freq)');
        console.log('   [/]: adjust A frequency');
        console.log('   +/-: adjust mesh scale');
        console.log('   O: cycle opacity');
        console.log('   I: toggle interference rings');
        console.log('   L: toggle resonance lines');
        console.log('   W: toggle wavefunction nodes');
        console.log('   G: toggle edge glow');
        console.log('');
        console.log('   BINAURAL PHYSICS:');
        console.log('   Phase A: oscillates at f_A (base frequency)');
        console.log('   Phase B: oscillates at f_B (offset by œÜ‚Åª¬π)');
        console.log('   Beat amplitude: constructive/destructive interference');
        console.log('   Resonance: beat strength modulates LIMNUS field');
        console.log('   Entrainment: accumulated phase synchronization');
        console.log('   Coherence: triadic system alignment measure');
    </script>
</body>
</html>
