# INTEGRITY_METADATA
# Date: 2025-12-23
# Status: ⚠️ TRULY UNSUPPORTED - No supporting evidence found
# Severity: HIGH RISK
# Risk Types: unsupported_claims, unverified_math


{
  "stack_array_manipulation_0": {
    "name": "stack_array_manipulation_0",
    "pattern_type": "list",
    "code_template": "rotated_arr = np.rot90($P0, -1)\nflattened_arr = rotated_arr.flatten()\nnegated_func = lambda x: -flattened_arr[int(x)]\nlargest_index = int(optimize.fminbound(negated_func, 0, len(flattened_arr) - 1))\nlargest_element = flattened_arr[largest_index]\nreturn largest_element",
    "description": "array_manipulation (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_secureQuery_1": {
    "name": "stack_secureQuery_1",
    "pattern_type": "general",
    "code_template": "try:\n    connection = sqlite3.connect('example.db')\n    cursor = connection.cursor()\n    query = 'SELECT * FROM users WHERE username = ?'\n    cursor.execute(query, ($P0,))\n    result = cursor.fetchall()\n    connection.close()\n    return result\nexcept sqlite3.Error as e:\n    return f'An error occurred: {e}'",
    "description": "secureQuery (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_parse_array_to_graph_2": {
    "name": "stack_parse_array_to_graph_2",
    "pattern_type": "list",
    "code_template": "graph = Graph()\ntry:\n    for item in $P0:\n        if isinstance(item, dict):\n            if 'node' in item:\n                graph.add_node(item['node'])\n            elif 'edge' in item:\n                (from_node, to_node) = item['edge']\n                graph.add_edge(from_node, to_node)\n            else:\n                raise ValueError(\"Invalid item format, must contain 'node' or 'edge'.\")\n        else:\n            raise TypeError('Each item must be a dictionary.')\nexcept Exception as e:\n    return f'Error: {str(e)}'\nreturn graph",
    "description": "parse_array_to_graph (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_node_3": {
    "name": "stack_add_node_3",
    "pattern_type": "general",
    "code_template": "if $P1 not in $P0.nodes:\n    $P0.nodes[$P1] = []\nelse:\n    raise ValueError(f'Node {$P1} already exists.')",
    "description": "add_node (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_sort_4": {
    "name": "stack_merge_sort_4",
    "pattern_type": "algorithm",
    "code_template": "if len($P0) <= 1:\n    return $P0\nmid = len($P0) // 2\nleft_half = $P0[:mid]\nright_half = $P0[mid:]\nsorted_left = merge_sort(left_half)\nsorted_right = merge_sort(right_half)\nreturn merge(sorted_left, sorted_right)",
    "description": "merge_sort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_5": {
    "name": "stack_merge_5",
    "pattern_type": "general",
    "code_template": "merged = []\n(left_index, right_index) = (0, 0)\nwhile left_index < len($P0) and right_index < len($P1):\n    if $P0[left_index] <= $P1[right_index]:\n        merged.append($P0[left_index])\n        left_index += 1\n    else:\n        merged.append($P1[right_index])\n        right_index += 1\nmerged.extend($P0[left_index:])\nmerged.extend($P1[right_index:])\nreturn merged",
    "description": "merge (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_single_digit_pattern_6": {
    "name": "stack_single_digit_pattern_6",
    "pattern_type": "general",
    "code_template": "if not isinstance($P0, int) or $P0 < 0 or $P0 > 9:\n    raise ValueError('Input must be an integer between 0 and 9.')\npattern_lines = []\nfor i in range(1, $P0 + 1):\n    line = str(i) * i\n    pattern_lines.append(line)\nresult_pattern = '\\$P0'.join(pattern_lines)\nreturn result_pattern",
    "description": "single_digit_pattern (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_create_maze_7": {
    "name": "stack_create_maze_7",
    "pattern_type": "general",
    "code_template": "maze = [[1 for _ in range($P0)] for _ in range($P1)]\ndef is_valid_move(x, y):\n    \"\"\"Check if moving to the cell (x, y) is within bounds and is a wall.\"\"\"\n    return 0 <= x < $P1 and 0 <= y < $P0 and (maze[x][y] == 1)\ndef carve_passages_from(cx, cy):\n    \"\"\"Recursively carve passages starting from (cx, cy).\"\"\"\n    maze[cx][cy] = 0\n    directions = random.sample(DIRECTIONS, len(DIRECTIONS))\n    for (dx, dy) in directions:\n        (nx, ny) = (cx + 2 * dx, cy + 2 * dy)\n        if is_valid_move(nx, ny):\n            maze[cx + dx][cy + dy] = 0\n            carve_passages_from(nx, ny)\n(start_x, start_y) = (random.randrange(0, $P1, 2), random.randrange(0, $P0, 2))\ncarve_passages_from(start_x, start_y)\nmaze[0][0] = 0\nmaze[$P1 - 1][$P0 - 1] = 0\nreturn maze",
    "description": "create_maze (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_sort_8": {
    "name": "stack_merge_sort_8",
    "pattern_type": "algorithm",
    "code_template": "if len($P0) < 2:\n    return $P0\nmid = len($P0) // 2\nleft_half = merge_sort($P0[:mid])\nright_half = merge_sort($P0[mid:])\nsorted_array = []\ni = j = 0\nwhile i < len(left_half) and j < len(right_half):\n    if left_half[i] < right_half[j]:\n        sorted_array.append(left_half[i])\n        i += 1\n    else:\n        sorted_array.append(right_half[j])\n        j += 1\nsorted_array.extend(left_half[i:])\nsorted_array.extend(right_half[j:])\nreturn sorted_array",
    "description": "merge_sort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_quick_sort_9": {
    "name": "stack_quick_sort_9",
    "pattern_type": "algorithm",
    "code_template": "if len($P0) < 2:\n    return $P0\npivot = $P0[-1]\nless_than_pivot = [x for x in $P0[:-1] if x <= pivot]\ngreater_than_pivot = [x for x in $P0[:-1] if x > pivot]\nreturn quick_sort(less_than_pivot) + [pivot] + quick_sort(greater_than_pivot)",
    "description": "quick_sort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_sort_array_and_rearrange_string_10": {
    "name": "stack_sort_array_and_rearrange_string_10",
    "pattern_type": "algorithm",
    "code_template": "if len($P0) != len($P1):\n    raise ValueError('\u6570\u7ec4\u548c\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u5fc5\u987b\u76f8\u540c\u3002')\nindexed_arr = list(enumerate($P0))\nindexed_arr.sort(key=lambda x: x[1])\nsorted_arr = [x[1] for x in indexed_arr]\nsorted_indices = [x[0] for x in indexed_arr]\nrearranged_string = ''.join(($P1[i] for i in sorted_indices))\nreturn (sorted_arr, rearranged_string)",
    "description": "sort_array_and_rearrange_string (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_task_11": {
    "name": "stack_add_task_11",
    "pattern_type": "general",
    "code_template": "heapq.heappush($P0._tasks, (-$P1.priority, $P1))\nprint(f'Added $P1: {$P1.description} with priority {$P1.priority}')",
    "description": "add_task (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_remove_highest_priority_task_12": {
    "name": "stack_remove_highest_priority_task_12",
    "pattern_type": "general",
    "code_template": "if not $P0._tasks:\n    print('No tasks available to remove.')\n    return None\ntask = heapq.heappop($P0._tasks)[1]\nprint(f'Removed task: {task.description} with priority {task.priority}')\nreturn task",
    "description": "remove_highest_priority_task (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_roman_to_integer_13": {
    "name": "stack_roman_to_integer_13",
    "pattern_type": "general",
    "code_template": "roman_to_int = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\nrepeatable = {'I', 'X', 'C', 'M'}\nsubtractive_combinations = {'IV': 4, 'IX': 9, 'XL': 40, 'XC': 90, 'CD': 400, 'CM': 900}\ni = 0\nvalue = 0\nlength = len($P0)\nwhile i < length:\n    if i < length - 1 and $P0[i:i + 2] in subtractive_combinations:\n        value += subtractive_combinations[$P0[i:i + 2]]\n        i += 2\n    elif $P0[i] in roman_to_int:\n        if i > 0 and roman_to_int[$P0[i]] > roman_to_int[$P0[i - 1]]:\n            return None\n        value += roman_to_int[$P0[i]]\n        i += 1\n    else:\n        return None\n    if i < length and i >= 3 and ($P0[i] == $P0[i - 1] == $P0[i - 2] == $P0[i - 3]):\n        if $P0[i] not in repeatable:\n            return None\nreturn value",
    "description": "roman_to_integer (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_analyze_roman_numerals_14": {
    "name": "stack_analyze_roman_numerals_14",
    "pattern_type": "general",
    "code_template": "results = {}\nfor numeral in $P0:\n    result = roman_to_integer(numeral)\n    if result is None:\n        results[numeral] = 'Incorrect or ambiguous'\n    else:\n        results[numeral] = result\nreturn results",
    "description": "analyze_roman_numerals (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_max_path_sum_15": {
    "name": "stack_max_path_sum_15",
    "pattern_type": "general",
    "code_template": "if not $P0 or not $P0[0]:\n    return 0\nrows = len($P0)\ncols = len($P0[0])\ndp = [[0] * cols for _ in range(rows)]\ndp[0][0] = $P0[0][0]\nfor j in range(1, cols):\n    dp[0][j] = dp[0][j - 1] + $P0[0][j]\nfor i in range(1, rows):\n    dp[i][0] = dp[i - 1][0] + $P0[i][0]\nfor i in range(1, rows):\n    for j in range(1, cols):\n        dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + $P0[i][j]\nreturn dp[rows - 1][cols - 1]",
    "description": "max_path_sum (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_display_welcome_message_16": {
    "name": "stack_display_welcome_message_16",
    "pattern_type": "general",
    "code_template": "print('\u6b22\u8fce\u6765\u5230\u865a\u62df\u5fc3\u7406\u5065\u5eb7\u652f\u6301\u5c0f\u7ec4\uff01')\nprint('\u5728\u8fd9\u91cc\uff0c\u4f60\u53ef\u4ee5\u533f\u540d\u5206\u4eab\u4f60\u7684\u7ecf\u5386\u6216\u56f0\u6270\u3002')\nprint('\u8bf7\u8bb0\u4f4f\uff0c\u8fd9\u4e0d\u662f\u4e13\u4e1a\u7684\u5fc3\u7406\u5065\u5eb7\u670d\u52a1\u3002\u5982\u679c\u4f60\u9700\u8981\u5e2e\u52a9\uff0c\u8bf7\u8054\u7cfb\u4e13\u4e1a\u4eba\u58eb\u3002')\nprint(\"\u8f93\u5165 'exit' \u9000\u51fa\u7a0b\u5e8f\u3002\\n\")",
    "description": "display_welcome_message (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_detect_mental_health_issues_17": {
    "name": "stack_detect_mental_health_issues_17",
    "pattern_type": "general",
    "code_template": "anxiety_keywords = ['\u7126\u8651', '\u7d27\u5f20', '\u62c5\u5fc3', '\u6050\u614c']\ndepression_keywords = ['\u6291\u90c1', '\u60b2\u4f24', '\u65e0\u52a9', '\u7edd\u671b']\nanxiety_detected = any((keyword in $P0 for keyword in anxiety_keywords))\ndepression_detected = any((keyword in $P0 for keyword in depression_keywords))\nreturn (anxiety_detected, depression_detected)",
    "description": "detect_mental_health_issues (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_provide_support_suggestions_18": {
    "name": "stack_provide_support_suggestions_18",
    "pattern_type": "general",
    "code_template": "if $P0:\n    print('\\n\u6211\u4eec\u68c0\u6d4b\u5230\u4f60\u53ef\u80fd\u6b63\u5728\u7ecf\u5386\u7126\u8651\u3002')\nif $P1:\n    print('\\n\u6211\u4eec\u68c0\u6d4b\u5230\u4f60\u53ef\u80fd\u6b63\u5728\u7ecf\u5386\u6291\u90c1\u3002')\nif $P0 or $P1:\n    print('\u5efa\u8bae\u4f60\u8003\u8651\u5bfb\u6c42\u4e13\u4e1a\u5e2e\u52a9\u3002')\n    print('\u5efa\u7acb\u4e00\u4e2a\u652f\u6301\u7f51\u7edc\u4e5f\u5f88\u91cd\u8981\uff0c\u53ef\u4ee5\u4e0e\u4fe1\u4efb\u7684\u670b\u53cb\u6216\u5bb6\u4eba\u4ea4\u8c08\u3002')\nelse:\n    print('\\n\u611f\u8c22\u4f60\u7684\u5206\u4eab\u3002\u8bf7\u8bb0\u4f4f\uff0c\u5efa\u7acb\u652f\u6301\u7f51\u7edc\u662f\u4fdd\u6301\u5fc3\u7406\u5065\u5eb7\u7684\u91cd\u8981\u90e8\u5206\u3002')",
    "description": "provide_support_suggestions (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_fibonacci_memo_19": {
    "name": "stack_fibonacci_memo_19",
    "pattern_type": "math",
    "code_template": "if $P0 <= 1:\n    return $P0\nif $P0 in $P1:\n    return $P1[$P0]\n$P1[$P0] = fibonacci_memo($P0 - 1, $P1) + fibonacci_memo($P0 - 2, $P1)\nreturn $P1[$P0]",
    "description": "fibonacci_memo (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_fibonacci_tab_20": {
    "name": "stack_fibonacci_tab_20",
    "pattern_type": "math",
    "code_template": "if $P0 <= 1:\n    return $P0\ndp = [0] * ($P0 + 1)\n(dp[0], dp[1]) = (0, 1)\nfor i in range(2, $P0 + 1):\n    dp[i] = dp[i - 1] + dp[i - 2]\nreturn dp[$P0]",
    "description": "fibonacci_tab (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_lambda_handler_21": {
    "name": "stack_lambda_handler_21",
    "pattern_type": "general",
    "code_template": "http_method = $P0['httpMethod']\npath = $P0['path']\nif http_method == 'GET' and path == '/tasks':\n    return list_tasks()\nelif http_method == 'POST' and path == '/tasks':\n    body = json.loads($P0['body'])\n    return add_task(body['task'])",
    "description": "lambda_handler (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_list_tasks_22": {
    "name": "stack_list_tasks_22",
    "pattern_type": "list",
    "code_template": "response = table.scan()\nreturn {'statusCode': 200, 'body': json.dumps(response['Items'])}",
    "description": "list_tasks (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_task_23": {
    "name": "stack_add_task_23",
    "pattern_type": "general",
    "code_template": "table.put_item(Item={'$P0': $P0})\nreturn {'statusCode': 200, 'body': json.dumps({'message': 'Task added'})}",
    "description": "add_task (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_generate_key_24": {
    "name": "stack_generate_key_24",
    "pattern_type": "general",
    "code_template": "return Fernet.generate_key()",
    "description": "generate_key (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_encrypt_file_25": {
    "name": "stack_encrypt_file_25",
    "pattern_type": "general",
    "code_template": "fernet = Fernet($P1)\nwith open($P0, 'rb') as file:\n    original_data = file.read()\n    encrypted_data = fernet.encrypt(original_data)\nwith open($P0, 'wb') as file:\n    file.write(encrypted_data)",
    "description": "encrypt_file (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_send_file_26": {
    "name": "stack_send_file_26",
    "pattern_type": "general",
    "code_template": "seq_num = 0\nwith open($P0, 'rb') as file:\n    while True:\n        data = file.read(BUFFER_SIZE - 16)\n        if not data:\n            break\n        packet = f'{seq_num:016}'.encode() + data\n        ack_received = False\n        while not ack_received:\n            sender_socket.sendto(packet, (SERVER_IP, SERVER_PORT))\n            try:\n                (ack, _) = sender_socket.recvfrom(BUFFER_SIZE)\n                if int(ack.decode()) == seq_num:\n                    print(f'ACK {seq_num} received.')\n                    ack_received = True\n            except socket.timeout:\n                print(f'Timeout, resending packet {seq_num}')\n        seq_num += 1",
    "description": "send_file (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_receive_file_27": {
    "name": "stack_receive_file_27",
    "pattern_type": "general",
    "code_template": "expected_seq_num = 0\nwith open($P0, 'wb') as file:\n    while True:\n        try:\n            (packet, addr) = receiver_socket.recvfrom(BUFFER_SIZE)\n            seq_num = int(packet[:16].decode())\n            data = packet[16:]\n            if seq_num == expected_seq_num:\n                print(f'Packet {seq_num} received correctly.')\n                file.write(data)\n                expected_seq_num += 1\n            receiver_socket.sendto(f'{seq_num:016}'.encode(), addr)\n        except KeyboardInterrupt:\n            break",
    "description": "receive_file (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_minimum_platforms_28": {
    "name": "stack_find_minimum_platforms_28",
    "pattern_type": "algorithm",
    "code_template": "$P0.sort()\n$P1.sort()\ni = 0\nj = 0\nplatforms_needed = 0\nmax_platforms = 0\nwhile i < len($P0) and j < len($P1):\n    if $P0[i] <= $P1[j]:\n        platforms_needed += 1\n        i += 1\n        max_platforms = max(max_platforms, platforms_needed)\n    else:\n        platforms_needed -= 1\n        j += 1\nreturn max_platforms",
    "description": "find_minimum_platforms (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_round_robin_29": {
    "name": "stack_round_robin_29",
    "pattern_type": "general",
    "code_template": "queue = deque()\ncurrent_time = 0\nwaiting_time = 0\nturnaround_time = 0\nwhile $P0 or queue:\n    while $P0 and $P0[0].arrival_time <= current_time:\n        queue.append($P0.pop(0))\n    if queue:\n        current_process = queue.popleft()\n        if current_process.remaining_time > $P1:\n            print(f'Process {current_process.pid} executed for {$P1} units.')\n            current_time += $P1\n            current_process.remaining_time -= $P1\n            while $P0 and $P0[0].arrival_time <= current_time:\n                queue.append($P0.pop(0))\n            queue.append(current_process)\n        else:\n            print(f'Process {current_process.pid} executed for {current_process.remaining_time} units and finished.')\n            current_time += current_process.remaining_time\n            turnaround_time += current_time - current_process.arrival_time\n            waiting_time += current_time - current_process.arrival_time - current_process.burst_time\n            current_process.remaining_time = 0\n            current_process.completion_time = current_time\n    elif $P0:\n        current_time = $P0[0].arrival_time\nn = len($P0) + len(queue)\nprint(f'Average Waiting Time: {waiting_time / n:.2f}')\nprint(f'Average Turnaround Time: {turnaround_time / n:.2f}')",
    "description": "round_robin (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_insert_30": {
    "name": "stack_insert_30",
    "pattern_type": "general",
    "code_template": "idx = $P0._hash_function($P1)\nfor (i, (k, v)) in enumerate($P0.table[idx]):\n    if k == $P1:\n        $P0.table[idx][i] = ($P1, $P2)\n        return\n$P0.table[idx].append(($P1, $P2))",
    "description": "insert (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_insert_31": {
    "name": "stack_insert_31",
    "pattern_type": "general",
    "code_template": "node = $P0.root\nfor char in $P1:\n    if char not in node.children:\n        node.children[char] = TrieNode()\n    node = node.children[char]\nnode.is_end = True",
    "description": "insert (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_power_mod_32": {
    "name": "stack_power_mod_32",
    "pattern_type": "general",
    "code_template": "MOD = 1000000007\nresult = 1\nbase = $P0 % MOD\nwhile $P1 > 0:\n    if $P1 % 2 == 1:\n        result = result * base % MOD\n    base = base * base % MOD\n    $P1 //= 2\nreturn result",
    "description": "power_mod (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_coin_placement_33": {
    "name": "stack_coin_placement_33",
    "pattern_type": "general",
    "code_template": "from collections import defaultdict\ntree = defaultdict(list)\nfor (u, v) in $P1:\n    tree[u].append(v)\n    tree[v].append(u)\ndegree = {i: len(tree[i]) for i in range($P0)}\nnodes = sorted(range($P0), key=lambda x: (-degree[x], x))\nreturn nodes[:$P2]",
    "description": "coin_placement (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_max_depth_34": {
    "name": "stack_max_depth_34",
    "pattern_type": "general",
    "code_template": "if not $P0:\n    return 0\nleft_depth = max_depth($P0.left)\nright_depth = max_depth($P0.right)\nreturn max(left_depth, right_depth) + 1",
    "description": "max_depth (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_35": {
    "name": "stack_dfs_35",
    "pattern_type": "general",
    "code_template": "$P2[$P1] = True\n$P3.append($P1)\nfor neighbor in $P0[$P1]:\n    if not $P2[neighbor]:\n        dfs($P0, neighbor, $P2, $P3)",
    "description": "dfs (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_connected_components_36": {
    "name": "stack_find_connected_components_36",
    "pattern_type": "algorithm",
    "code_template": "visited = {node: False for node in $P0}\ncomponents = []\nfor node in $P0:\n    if not visited[node]:\n        component = []\n        dfs($P0, node, visited, component)\n        components.append(component)\nreturn components",
    "description": "find_connected_components (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_ap_b_37": {
    "name": "stack_dfs_ap_b_37",
    "pattern_type": "general",
    "code_template": "children = 0\n$P2[$P1] = True\n$P3[$P1] = $P8[0]\n$P4[$P1] = $P8[0]\n$P8[0] += 1\nfor v in $P0[$P1]:\n    if not $P2[v]:\n        $P5[v] = $P1\n        children += 1\n        dfs_ap_b($P0, v, $P2, $P3, $P4, $P5, $P6, $P7, $P8)\n        $P4[$P1] = min($P4[$P1], $P4[v])\n        if $P5[$P1] is None and children > 1:\n            $P6[$P1] = True\n        if $P5[$P1] is not None and $P4[v] >= $P3[$P1]:\n            $P6[$P1] = True\n        if $P4[v] > $P3[$P1]:\n            $P7.append(($P1, v))\n    elif v != $P5[$P1]:\n        $P4[$P1] = min($P4[$P1], $P3[v])",
    "description": "dfs_ap_b (9 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_greedy_string_match_38": {
    "name": "stack_greedy_string_match_38",
    "pattern_type": "string",
    "code_template": "n = len($P0)\nm = len($P1)\nmatches = []\nfor i in range(n - m + 1):\n    match_found = True\n    for j in range(m):\n        if $P0[i + j] != $P1[j]:\n            match_found = False\n            break\n    if match_found:\n        matches.append(i)\nreturn matches",
    "description": "greedy_string_match (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_bfs_maze_solver_39": {
    "name": "stack_bfs_maze_solver_39",
    "pattern_type": "general",
    "code_template": "(rows, cols) = (len($P0), len($P0[0]))\ndirections = [(-1, 0), (1, 0), (0, -1), (0, 1)]\nqueue = deque([($P1, [$P1])])\nvisited = set([$P1])\nhas_cycle = False\nwhile queue:\n    ((x, y), path) = queue.popleft()\n    if (x, y) == $P2:\n        return (path, has_cycle)\n    for (dx, dy) in directions:\n        (nx, ny) = (x + dx, y + dy)\n        if 0 <= nx < rows and 0 <= ny < cols and ($P0[nx][ny] == 0):\n            if (nx, ny) in visited:\n                has_cycle = True\n            else:\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [(nx, ny)]))\nreturn ([], has_cycle)",
    "description": "bfs_maze_solver (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_gcd_of_list_40": {
    "name": "stack_gcd_of_list_40",
    "pattern_type": "math",
    "code_template": "return reduce(math.gcd, $P0)",
    "description": "gcd_of_list (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_main_41": {
    "name": "stack_main_41",
    "pattern_type": "general",
    "code_template": "import sys\ninput = sys.stdin.read\ndata = input().split()\nindex = 0\nT = int(data[index])\nindex += 1\nresults = []\nfor _ in range(T):\n    N = int(data[index])\n    index += 1\n    spin_times = list(map(int, data[index:index + N]))\n    index += N\n    result = gcd_of_list(spin_times)\n    results.append(result)\nfor result in results:\n    print(result)",
    "description": "main (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_optimized_merge_sort_42": {
    "name": "stack_optimized_merge_sort_42",
    "pattern_type": "algorithm",
    "code_template": "def is_partially_sorted($P0):\n    for i in range(1, len($P0)):\n        if $P0[i] < $P0[i - 1]:\n            return False\n    return True\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\ndef merge_sort($P0):\n    if len($P0) <= 1:\n        return $P0\n    if is_partially_sorted($P0):\n        return $P0\n    mid = len($P0) // 2\n    left = merge_sort($P0[:mid])\n    right = merge_sort($P0[mid:])\n    return merge(left, right)\nreturn merge_sort($P0)",
    "description": "optimized_merge_sort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_partially_sorted_43": {
    "name": "stack_is_partially_sorted_43",
    "pattern_type": "algorithm",
    "code_template": "for i in range(1, len($P0)):\n    if $P0[i] < $P0[i - 1]:\n        return False\nreturn True",
    "description": "is_partially_sorted (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_44": {
    "name": "stack_merge_44",
    "pattern_type": "general",
    "code_template": "result = []\ni = j = 0\nwhile i < len($P0) and j < len($P1):\n    if $P0[i] <= $P1[j]:\n        result.append($P0[i])\n        i += 1\n    else:\n        result.append($P1[j])\n        j += 1\nresult.extend($P0[i:])\nresult.extend($P1[j:])\nreturn result",
    "description": "merge (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_edge_4": {
    "name": "stack_add_edge_4",
    "pattern_type": "general",
    "code_template": "if $P1 not in $P0.nodes or $P2 not in $P0.nodes:\n    raise ValueError(f'One or both nodes {$P1}, {$P2} are not in the graph.')\n$P0.edges.append(($P1, $P2))\n$P0.nodes[$P1].append($P2)",
    "description": "add_edge (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_sort_5": {
    "name": "stack_merge_sort_5",
    "pattern_type": "algorithm",
    "code_template": "if len($P0) <= 1:\n    return $P0\nmid = len($P0) // 2\nleft_half = $P0[:mid]\nright_half = $P0[mid:]\nsorted_left = merge_sort(left_half)\nsorted_right = merge_sort(right_half)\nreturn merge(sorted_left, sorted_right)",
    "description": "merge_sort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_6": {
    "name": "stack_merge_6",
    "pattern_type": "general",
    "code_template": "merged = []\n(left_index, right_index) = (0, 0)\nwhile left_index < len($P0) and right_index < len($P1):\n    if $P0[left_index] <= $P1[right_index]:\n        merged.append($P0[left_index])\n        left_index += 1\n    else:\n        merged.append($P1[right_index])\n        right_index += 1\nmerged.extend($P0[left_index:])\nmerged.extend($P1[right_index:])\nreturn merged",
    "description": "merge (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_single_digit_pattern_7": {
    "name": "stack_single_digit_pattern_7",
    "pattern_type": "general",
    "code_template": "if not isinstance($P0, int) or $P0 < 0 or $P0 > 9:\n    raise ValueError('Input must be an integer between 0 and 9.')\npattern_lines = []\nfor i in range(1, $P0 + 1):\n    line = str(i) * i\n    pattern_lines.append(line)\nresult_pattern = '\\$P0'.join(pattern_lines)\nreturn result_pattern",
    "description": "single_digit_pattern (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_create_maze_8": {
    "name": "stack_create_maze_8",
    "pattern_type": "general",
    "code_template": "maze = [[1 for _ in range($P0)] for _ in range($P1)]\ndef is_valid_move(x, y):\n    \"\"\"Check if moving to the cell (x, y) is within bounds and is a wall.\"\"\"\n    return 0 <= x < $P1 and 0 <= y < $P0 and (maze[x][y] == 1)\ndef carve_passages_from(cx, cy):\n    \"\"\"Recursively carve passages starting from (cx, cy).\"\"\"\n    maze[cx][cy] = 0\n    directions = random.sample(DIRECTIONS, len(DIRECTIONS))\n    for (dx, dy) in directions:\n        (nx, ny) = (cx + 2 * dx, cy + 2 * dy)\n        if is_valid_move(nx, ny):\n            maze[cx + dx][cy + dy] = 0\n            carve_passages_from(nx, ny)\n(start_x, start_y) = (random.randrange(0, $P1, 2), random.randrange(0, $P0, 2))\ncarve_passages_from(start_x, start_y)\nmaze[0][0] = 0\nmaze[$P1 - 1][$P0 - 1] = 0\nreturn maze",
    "description": "create_maze (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_sort_9": {
    "name": "stack_merge_sort_9",
    "pattern_type": "algorithm",
    "code_template": "if len($P0) < 2:\n    return $P0\nmid = len($P0) // 2\nleft_half = merge_sort($P0[:mid])\nright_half = merge_sort($P0[mid:])\nsorted_array = []\ni = j = 0\nwhile i < len(left_half) and j < len(right_half):\n    if left_half[i] < right_half[j]:\n        sorted_array.append(left_half[i])\n        i += 1\n    else:\n        sorted_array.append(right_half[j])\n        j += 1\nsorted_array.extend(left_half[i:])\nsorted_array.extend(right_half[j:])\nreturn sorted_array",
    "description": "merge_sort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_quick_sort_10": {
    "name": "stack_quick_sort_10",
    "pattern_type": "algorithm",
    "code_template": "if len($P0) < 2:\n    return $P0\npivot = $P0[-1]\nless_than_pivot = [x for x in $P0[:-1] if x <= pivot]\ngreater_than_pivot = [x for x in $P0[:-1] if x > pivot]\nreturn quick_sort(less_than_pivot) + [pivot] + quick_sort(greater_than_pivot)",
    "description": "quick_sort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_11": {
    "name": "stack_get_11",
    "pattern_type": "general",
    "code_template": "if $P1 in $P0.cache:\n    node = $P0.cache[$P1]\n    $P0._remove(node)\n    $P0._add(node)\n    return node.value\nreturn -1",
    "description": "get (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_sort_array_and_rearrange_string_12": {
    "name": "stack_sort_array_and_rearrange_string_12",
    "pattern_type": "algorithm",
    "code_template": "if len($P0) != len($P1):\n    raise ValueError('\u6570\u7ec4\u548c\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u5fc5\u987b\u76f8\u540c\u3002')\nindexed_arr = list(enumerate($P0))\nindexed_arr.sort(key=lambda x: x[1])\nsorted_arr = [x[1] for x in indexed_arr]\nsorted_indices = [x[0] for x in indexed_arr]\nrearranged_string = ''.join(($P1[i] for i in sorted_indices))\nreturn (sorted_arr, rearranged_string)",
    "description": "sort_array_and_rearrange_string (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_task_13": {
    "name": "stack_add_task_13",
    "pattern_type": "general",
    "code_template": "heapq.heappush($P0._tasks, (-$P1.priority, $P1))\nprint(f'Added $P1: {$P1.description} with priority {$P1.priority}')",
    "description": "add_task (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_remove_highest_priority_task_14": {
    "name": "stack_remove_highest_priority_task_14",
    "pattern_type": "general",
    "code_template": "if not $P0._tasks:\n    print('No tasks available to remove.')\n    return None\ntask = heapq.heappop($P0._tasks)[1]\nprint(f'Removed task: {task.description} with priority {task.priority}')\nreturn task",
    "description": "remove_highest_priority_task (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_fetch_highest_priority_task_15": {
    "name": "stack_fetch_highest_priority_task_15",
    "pattern_type": "general",
    "code_template": "if not $P0._tasks:\n    print('No tasks available.')\n    return None\ntask = $P0._tasks[0][1]\nprint(f'Highest priority task: {task.description} with priority {task.priority}')\nreturn task",
    "description": "fetch_highest_priority_task (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_roman_to_integer_16": {
    "name": "stack_roman_to_integer_16",
    "pattern_type": "general",
    "code_template": "roman_to_int = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\nrepeatable = {'I', 'X', 'C', 'M'}\nsubtractive_combinations = {'IV': 4, 'IX': 9, 'XL': 40, 'XC': 90, 'CD': 400, 'CM': 900}\ni = 0\nvalue = 0\nlength = len($P0)\nwhile i < length:\n    if i < length - 1 and $P0[i:i + 2] in subtractive_combinations:\n        value += subtractive_combinations[$P0[i:i + 2]]\n        i += 2\n    elif $P0[i] in roman_to_int:\n        if i > 0 and roman_to_int[$P0[i]] > roman_to_int[$P0[i - 1]]:\n            return None\n        value += roman_to_int[$P0[i]]\n        i += 1\n    else:\n        return None\n    if i < length and i >= 3 and ($P0[i] == $P0[i - 1] == $P0[i - 2] == $P0[i - 3]):\n        if $P0[i] not in repeatable:\n            return None\nreturn value",
    "description": "roman_to_integer (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_analyze_roman_numerals_17": {
    "name": "stack_analyze_roman_numerals_17",
    "pattern_type": "general",
    "code_template": "results = {}\nfor numeral in $P0:\n    result = roman_to_integer(numeral)\n    if result is None:\n        results[numeral] = 'Incorrect or ambiguous'\n    else:\n        results[numeral] = result\nreturn results",
    "description": "analyze_roman_numerals (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_max_path_sum_18": {
    "name": "stack_max_path_sum_18",
    "pattern_type": "general",
    "code_template": "if not $P0 or not $P0[0]:\n    return 0\nrows = len($P0)\ncols = len($P0[0])\ndp = [[0] * cols for _ in range(rows)]\ndp[0][0] = $P0[0][0]\nfor j in range(1, cols):\n    dp[0][j] = dp[0][j - 1] + $P0[0][j]\nfor i in range(1, rows):\n    dp[i][0] = dp[i - 1][0] + $P0[i][0]\nfor i in range(1, rows):\n    for j in range(1, cols):\n        dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + $P0[i][j]\nreturn dp[rows - 1][cols - 1]",
    "description": "max_path_sum (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_helper_19": {
    "name": "stack_helper_19",
    "pattern_type": "general",
    "code_template": "if not $P0:\n    return 'null'\nnode_repr = json.dumps({'value': $P0.value, 'timestamp': $P0.timestamp, 'labels': $P0.labels})\nleft_serialized = helper($P0.left)\nright_serialized = helper($P0.right)\nreturn f'{node_repr},{left_serialized},{right_serialized}'",
    "description": "helper (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_helper_20": {
    "name": "stack_helper_20",
    "pattern_type": "general",
    "code_template": "if not $P0:\n    return None\nnode_data = $P0.pop(0)\nif node_data == 'null':\n    return None\ndata = json.loads(node_data)\nnode = TreeNode(value=data['value'], timestamp=data.get('timestamp', ''), labels=data.get('labels', []))\nnode.left = helper($P0)\nnode.right = helper($P0)\nreturn node",
    "description": "helper (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_allocate_21": {
    "name": "stack_allocate_21",
    "pattern_type": "general",
    "code_template": "for block in $P0.memory:\n    if block.free and block.$P1 >= $P1:\n        if block.$P1 > $P1:\n            new_block = MemoryBlock(block.start + $P1, block.$P1 - $P1)\n            $P0.memory.insert($P0.memory.index(block) + 1, new_block)\n        block.$P1 = $P1\n        block.free = False\n        return block.start\nraise MemoryError('Not enough memory to allocate')",
    "description": "allocate (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_free_22": {
    "name": "stack_free_22",
    "pattern_type": "general",
    "code_template": "for block in $P0.memory:\n    if block.$P1 == $P1:\n        block.free = True\n        $P0._merge_free_blocks()\n        return\nraise ValueError('Invalid memory block $P1 address')",
    "description": "free (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_display_welcome_message_23": {
    "name": "stack_display_welcome_message_23",
    "pattern_type": "general",
    "code_template": "print('\u6b22\u8fce\u6765\u5230\u865a\u62df\u5fc3\u7406\u5065\u5eb7\u652f\u6301\u5c0f\u7ec4\uff01')\nprint('\u5728\u8fd9\u91cc\uff0c\u4f60\u53ef\u4ee5\u533f\u540d\u5206\u4eab\u4f60\u7684\u7ecf\u5386\u6216\u56f0\u6270\u3002')\nprint('\u8bf7\u8bb0\u4f4f\uff0c\u8fd9\u4e0d\u662f\u4e13\u4e1a\u7684\u5fc3\u7406\u5065\u5eb7\u670d\u52a1\u3002\u5982\u679c\u4f60\u9700\u8981\u5e2e\u52a9\uff0c\u8bf7\u8054\u7cfb\u4e13\u4e1a\u4eba\u58eb\u3002')\nprint(\"\u8f93\u5165 'exit' \u9000\u51fa\u7a0b\u5e8f\u3002\\n\")",
    "description": "display_welcome_message (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_detect_mental_health_issues_24": {
    "name": "stack_detect_mental_health_issues_24",
    "pattern_type": "general",
    "code_template": "anxiety_keywords = ['\u7126\u8651', '\u7d27\u5f20', '\u62c5\u5fc3', '\u6050\u614c']\ndepression_keywords = ['\u6291\u90c1', '\u60b2\u4f24', '\u65e0\u52a9', '\u7edd\u671b']\nanxiety_detected = any((keyword in $P0 for keyword in anxiety_keywords))\ndepression_detected = any((keyword in $P0 for keyword in depression_keywords))\nreturn (anxiety_detected, depression_detected)",
    "description": "detect_mental_health_issues (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_provide_support_suggestions_25": {
    "name": "stack_provide_support_suggestions_25",
    "pattern_type": "general",
    "code_template": "if $P0:\n    print('\\n\u6211\u4eec\u68c0\u6d4b\u5230\u4f60\u53ef\u80fd\u6b63\u5728\u7ecf\u5386\u7126\u8651\u3002')\nif $P1:\n    print('\\n\u6211\u4eec\u68c0\u6d4b\u5230\u4f60\u53ef\u80fd\u6b63\u5728\u7ecf\u5386\u6291\u90c1\u3002')\nif $P0 or $P1:\n    print('\u5efa\u8bae\u4f60\u8003\u8651\u5bfb\u6c42\u4e13\u4e1a\u5e2e\u52a9\u3002')\n    print('\u5efa\u7acb\u4e00\u4e2a\u652f\u6301\u7f51\u7edc\u4e5f\u5f88\u91cd\u8981\uff0c\u53ef\u4ee5\u4e0e\u4fe1\u4efb\u7684\u670b\u53cb\u6216\u5bb6\u4eba\u4ea4\u8c08\u3002')\nelse:\n    print('\\n\u611f\u8c22\u4f60\u7684\u5206\u4eab\u3002\u8bf7\u8bb0\u4f4f\uff0c\u5efa\u7acb\u652f\u6301\u7f51\u7edc\u662f\u4fdd\u6301\u5fc3\u7406\u5065\u5eb7\u7684\u91cd\u8981\u90e8\u5206\u3002')",
    "description": "provide_support_suggestions (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_main_26": {
    "name": "stack_main_26",
    "pattern_type": "general",
    "code_template": "display_welcome_message()\nwhile True:\n    user_input = input('\u8bf7\u5206\u4eab\u4f60\u7684\u7ecf\u5386\u6216\u56f0\u6270\uff1a\\n')\n    if user_input.lower() == 'exit':\n        print('\u611f\u8c22\u4f60\u7684\u53c2\u4e0e\u3002\u8bf7\u4fdd\u6301\u5065\u5eb7\uff01')\n        break\n    (anxiety, depression) = detect_mental_health_issues(user_input)\n    provide_support_suggestions(anxiety, depression)",
    "description": "main (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_fibonacci_memo_27": {
    "name": "stack_fibonacci_memo_27",
    "pattern_type": "math",
    "code_template": "if $P0 <= 1:\n    return $P0\nif $P0 in $P1:\n    return $P1[$P0]\n$P1[$P0] = fibonacci_memo($P0 - 1, $P1) + fibonacci_memo($P0 - 2, $P1)\nreturn $P1[$P0]",
    "description": "fibonacci_memo (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_fibonacci_tab_28": {
    "name": "stack_fibonacci_tab_28",
    "pattern_type": "math",
    "code_template": "if $P0 <= 1:\n    return $P0\ndp = [0] * ($P0 + 1)\n(dp[0], dp[1]) = (0, 1)\nfor i in range(2, $P0 + 1):\n    dp[i] = dp[i - 1] + dp[i - 2]\nreturn dp[$P0]",
    "description": "fibonacci_tab (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_lambda_handler_29": {
    "name": "stack_lambda_handler_29",
    "pattern_type": "general",
    "code_template": "http_method = $P0['httpMethod']\npath = $P0['path']\nif http_method == 'GET' and path == '/tasks':\n    return list_tasks()\nelif http_method == 'POST' and path == '/tasks':\n    body = json.loads($P0['body'])\n    return add_task(body['task'])",
    "description": "lambda_handler (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_list_tasks_30": {
    "name": "stack_list_tasks_30",
    "pattern_type": "list",
    "code_template": "response = table.scan()\nreturn {'statusCode': 200, 'body': json.dumps(response['Items'])}",
    "description": "list_tasks (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_task_31": {
    "name": "stack_add_task_31",
    "pattern_type": "general",
    "code_template": "table.put_item(Item={'$P0': $P0})\nreturn {'statusCode': 200, 'body': json.dumps({'message': 'Task added'})}",
    "description": "add_task (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_generate_key_32": {
    "name": "stack_generate_key_32",
    "pattern_type": "general",
    "code_template": "return Fernet.generate_key()",
    "description": "generate_key (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_encrypt_file_33": {
    "name": "stack_encrypt_file_33",
    "pattern_type": "general",
    "code_template": "fernet = Fernet($P1)\nwith open($P0, 'rb') as file:\n    original_data = file.read()\n    encrypted_data = fernet.encrypt(original_data)\nwith open($P0, 'wb') as file:\n    file.write(encrypted_data)",
    "description": "encrypt_file (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_calculate_file_hash_34": {
    "name": "stack_calculate_file_hash_34",
    "pattern_type": "general",
    "code_template": "hash_md5 = hashlib.md5()\nwith open($P0, 'rb') as file:\n    for chunk in iter(lambda : file.read(4096), b''):\n        hash_md5.update(chunk)\nreturn hash_md5.hexdigest()",
    "description": "calculate_file_hash (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_secure_file_transfer_35": {
    "name": "stack_secure_file_transfer_35",
    "pattern_type": "general",
    "code_template": "print(f'Starting $P0 transfer: {$P0}')\noriginal_hash = calculate_file_hash($P0)\nprint(f'Original Hash: {original_hash}')\nencrypt_file($P0, $P1)\ndecrypt_file($P0, $P1)\nfinal_hash = calculate_file_hash($P0)\nprint(f'Final Hash: {final_hash}')\nif original_hash == final_hash:\n    print(f'File {$P0} transferred successfully and integrity verified.')\nelse:\n    print(f'Integrity check failed for $P0 {$P0}.')",
    "description": "secure_file_transfer (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_send_file_36": {
    "name": "stack_send_file_36",
    "pattern_type": "general",
    "code_template": "seq_num = 0\nwith open($P0, 'rb') as file:\n    while True:\n        data = file.read(BUFFER_SIZE - 16)\n        if not data:\n            break\n        packet = f'{seq_num:016}'.encode() + data\n        ack_received = False\n        while not ack_received:\n            sender_socket.sendto(packet, (SERVER_IP, SERVER_PORT))\n            try:\n                (ack, _) = sender_socket.recvfrom(BUFFER_SIZE)\n                if int(ack.decode()) == seq_num:\n                    print(f'ACK {seq_num} received.')\n                    ack_received = True\n            except socket.timeout:\n                print(f'Timeout, resending packet {seq_num}')\n        seq_num += 1",
    "description": "send_file (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_receive_file_37": {
    "name": "stack_receive_file_37",
    "pattern_type": "general",
    "code_template": "expected_seq_num = 0\nwith open($P0, 'wb') as file:\n    while True:\n        try:\n            (packet, addr) = receiver_socket.recvfrom(BUFFER_SIZE)\n            seq_num = int(packet[:16].decode())\n            data = packet[16:]\n            if seq_num == expected_seq_num:\n                print(f'Packet {seq_num} received correctly.')\n                file.write(data)\n                expected_seq_num += 1\n            receiver_socket.sendto(f'{seq_num:016}'.encode(), addr)\n        except KeyboardInterrupt:\n            break",
    "description": "receive_file (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_minimum_platforms_38": {
    "name": "stack_find_minimum_platforms_38",
    "pattern_type": "algorithm",
    "code_template": "$P0.sort()\n$P1.sort()\ni = 0\nj = 0\nplatforms_needed = 0\nmax_platforms = 0\nwhile i < len($P0) and j < len($P1):\n    if $P0[i] <= $P1[j]:\n        platforms_needed += 1\n        i += 1\n        max_platforms = max(max_platforms, platforms_needed)\n    else:\n        platforms_needed -= 1\n        j += 1\nreturn max_platforms",
    "description": "find_minimum_platforms (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_round_robin_39": {
    "name": "stack_round_robin_39",
    "pattern_type": "general",
    "code_template": "queue = deque()\ncurrent_time = 0\nwaiting_time = 0\nturnaround_time = 0\nwhile $P0 or queue:\n    while $P0 and $P0[0].arrival_time <= current_time:\n        queue.append($P0.pop(0))\n    if queue:\n        current_process = queue.popleft()\n        if current_process.remaining_time > $P1:\n            print(f'Process {current_process.pid} executed for {$P1} units.')\n            current_time += $P1\n            current_process.remaining_time -= $P1\n            while $P0 and $P0[0].arrival_time <= current_time:\n                queue.append($P0.pop(0))\n            queue.append(current_process)\n        else:\n            print(f'Process {current_process.pid} executed for {current_process.remaining_time} units and finished.')\n            current_time += current_process.remaining_time\n            turnaround_time += current_time - current_process.arrival_time\n            waiting_time += current_time - current_process.arrival_time - current_process.burst_time\n            current_process.remaining_time = 0\n            current_process.completion_time = current_time\n    elif $P0:\n        current_time = $P0[0].arrival_time\nn = len($P0) + len(queue)\nprint(f'Average Waiting Time: {waiting_time / n:.2f}')\nprint(f'Average Turnaround Time: {turnaround_time / n:.2f}')",
    "description": "round_robin (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_insert_40": {
    "name": "stack_insert_40",
    "pattern_type": "general",
    "code_template": "idx = $P0._hash_function($P1)\nfor (i, (k, v)) in enumerate($P0.table[idx]):\n    if k == $P1:\n        $P0.table[idx][i] = ($P1, $P2)\n        return\n$P0.table[idx].append(($P1, $P2))",
    "description": "insert (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_41": {
    "name": "stack_find_41",
    "pattern_type": "algorithm",
    "code_template": "idx = $P0._hash_function($P1)\nfor (k, v) in $P0.table[idx]:\n    if k == $P1:\n        return v\nreturn None",
    "description": "find (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_delete_42": {
    "name": "stack_delete_42",
    "pattern_type": "general",
    "code_template": "idx = $P0._hash_function($P1)\nfor (i, (k, _)) in enumerate($P0.table[idx]):\n    if k == $P1:\n        del $P0.table[idx][i]\n        return",
    "description": "delete (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_insert_43": {
    "name": "stack_insert_43",
    "pattern_type": "general",
    "code_template": "node = $P0.root\nfor char in $P1:\n    if char not in node.children:\n        node.children[char] = TrieNode()\n    node = node.children[char]\nnode.is_end = True",
    "description": "insert (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_search_with_prefix_44": {
    "name": "stack_search_with_prefix_44",
    "pattern_type": "algorithm",
    "code_template": "node = $P0.root\nfor char in $P1:\n    if char not in node.children:\n        return []\n    node = node.children[char]\nresult = []\n$P0._dfs(node, $P1, result)\nreturn result",
    "description": "search_with_prefix (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_power_mod_45": {
    "name": "stack_power_mod_45",
    "pattern_type": "general",
    "code_template": "MOD = 1000000007\nresult = 1\nbase = $P0 % MOD\nwhile $P1 > 0:\n    if $P1 % 2 == 1:\n        result = result * base % MOD\n    base = base * base % MOD\n    $P1 //= 2\nreturn result",
    "description": "power_mod (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_coin_placement_46": {
    "name": "stack_coin_placement_46",
    "pattern_type": "general",
    "code_template": "from collections import defaultdict\ntree = defaultdict(list)\nfor (u, v) in $P1:\n    tree[u].append(v)\n    tree[v].append(u)\ndegree = {i: len(tree[i]) for i in range($P0)}\nnodes = sorted(range($P0), key=lambda x: (-degree[x], x))\nreturn nodes[:$P2]",
    "description": "coin_placement (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_max_depth_47": {
    "name": "stack_max_depth_47",
    "pattern_type": "general",
    "code_template": "if not $P0:\n    return 0\nleft_depth = max_depth($P0.left)\nright_depth = max_depth($P0.right)\nreturn max(left_depth, right_depth) + 1",
    "description": "max_depth (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_48": {
    "name": "stack_dfs_48",
    "pattern_type": "general",
    "code_template": "$P2[$P1] = True\n$P3.append($P1)\nfor neighbor in $P0[$P1]:\n    if not $P2[neighbor]:\n        dfs($P0, neighbor, $P2, $P3)",
    "description": "dfs (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_connected_components_49": {
    "name": "stack_find_connected_components_49",
    "pattern_type": "algorithm",
    "code_template": "visited = {node: False for node in $P0}\ncomponents = []\nfor node in $P0:\n    if not visited[node]:\n        component = []\n        dfs($P0, node, visited, component)\n        components.append(component)\nreturn components",
    "description": "find_connected_components (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_ap_b_50": {
    "name": "stack_dfs_ap_b_50",
    "pattern_type": "general",
    "code_template": "children = 0\n$P2[$P1] = True\n$P3[$P1] = $P8[0]\n$P4[$P1] = $P8[0]\n$P8[0] += 1\nfor v in $P0[$P1]:\n    if not $P2[v]:\n        $P5[v] = $P1\n        children += 1\n        dfs_ap_b($P0, v, $P2, $P3, $P4, $P5, $P6, $P7, $P8)\n        $P4[$P1] = min($P4[$P1], $P4[v])\n        if $P5[$P1] is None and children > 1:\n            $P6[$P1] = True\n        if $P5[$P1] is not None and $P4[v] >= $P3[$P1]:\n            $P6[$P1] = True\n        if $P4[v] > $P3[$P1]:\n            $P7.append(($P1, v))\n    elif v != $P5[$P1]:\n        $P4[$P1] = min($P4[$P1], $P3[v])",
    "description": "dfs_ap_b (9 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_articulation_points_bridges_51": {
    "name": "stack_find_articulation_points_bridges_51",
    "pattern_type": "algorithm",
    "code_template": "visited = {node: False for node in $P0}\ndisc = {node: float('inf') for node in $P0}\nlow = {node: float('inf') for node in $P0}\nparent = {node: None for node in $P0}\nap = {node: False for node in $P0}\nbridges = []\ntime = [0]\nfor node in $P0:\n    if not visited[node]:\n        dfs_ap_b($P0, node, visited, disc, low, parent, ap, bridges, time)\narticulation_points = [node for node in ap if ap[node]]\nreturn (articulation_points, bridges)",
    "description": "find_articulation_points_bridges (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_greedy_string_match_52": {
    "name": "stack_greedy_string_match_52",
    "pattern_type": "string",
    "code_template": "n = len($P0)\nm = len($P1)\nmatches = []\nfor i in range(n - m + 1):\n    match_found = True\n    for j in range(m):\n        if $P0[i + j] != $P1[j]:\n            match_found = False\n            break\n    if match_found:\n        matches.append(i)\nreturn matches",
    "description": "greedy_string_match (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_bfs_maze_solver_53": {
    "name": "stack_bfs_maze_solver_53",
    "pattern_type": "general",
    "code_template": "(rows, cols) = (len($P0), len($P0[0]))\ndirections = [(-1, 0), (1, 0), (0, -1), (0, 1)]\nqueue = deque([($P1, [$P1])])\nvisited = set([$P1])\nhas_cycle = False\nwhile queue:\n    ((x, y), path) = queue.popleft()\n    if (x, y) == $P2:\n        return (path, has_cycle)\n    for (dx, dy) in directions:\n        (nx, ny) = (x + dx, y + dy)\n        if 0 <= nx < rows and 0 <= ny < cols and ($P0[nx][ny] == 0):\n            if (nx, ny) in visited:\n                has_cycle = True\n            else:\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [(nx, ny)]))\nreturn ([], has_cycle)",
    "description": "bfs_maze_solver (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_gcd_of_list_54": {
    "name": "stack_gcd_of_list_54",
    "pattern_type": "math",
    "code_template": "return reduce(math.gcd, $P0)",
    "description": "gcd_of_list (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_main_55": {
    "name": "stack_main_55",
    "pattern_type": "general",
    "code_template": "import sys\ninput = sys.stdin.read\ndata = input().split()\nindex = 0\nT = int(data[index])\nindex += 1\nresults = []\nfor _ in range(T):\n    N = int(data[index])\n    index += 1\n    spin_times = list(map(int, data[index:index + N]))\n    index += N\n    result = gcd_of_list(spin_times)\n    results.append(result)\nfor result in results:\n    print(result)",
    "description": "main (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_optimized_merge_sort_56": {
    "name": "stack_optimized_merge_sort_56",
    "pattern_type": "algorithm",
    "code_template": "def is_partially_sorted($P0):\n    for i in range(1, len($P0)):\n        if $P0[i] < $P0[i - 1]:\n            return False\n    return True\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\ndef merge_sort($P0):\n    if len($P0) <= 1:\n        return $P0\n    if is_partially_sorted($P0):\n        return $P0\n    mid = len($P0) // 2\n    left = merge_sort($P0[:mid])\n    right = merge_sort($P0[mid:])\n    return merge(left, right)\nreturn merge_sort($P0)",
    "description": "optimized_merge_sort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_partially_sorted_57": {
    "name": "stack_is_partially_sorted_57",
    "pattern_type": "algorithm",
    "code_template": "for i in range(1, len($P0)):\n    if $P0[i] < $P0[i - 1]:\n        return False\nreturn True",
    "description": "is_partially_sorted (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_58": {
    "name": "stack_merge_58",
    "pattern_type": "general",
    "code_template": "result = []\ni = j = 0\nwhile i < len($P0) and j < len($P1):\n    if $P0[i] <= $P1[j]:\n        result.append($P0[i])\n        i += 1\n    else:\n        result.append($P1[j])\n        j += 1\nresult.extend($P0[i:])\nresult.extend($P1[j:])\nreturn result",
    "description": "merge (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_sort_59": {
    "name": "stack_merge_sort_59",
    "pattern_type": "algorithm",
    "code_template": "if len($P0) <= 1:\n    return $P0\nif is_partially_sorted($P0):\n    return $P0\nmid = len($P0) // 2\nleft = merge_sort($P0[:mid])\nright = merge_sort($P0[mid:])\nreturn merge(left, right)",
    "description": "merge_sort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_60": {
    "name": "stack_dfs_60",
    "pattern_type": "general",
    "code_template": "visited = set()\ntraversal = []\ndef dfs_util(v):\n    visited.add(v)\n    traversal.append(v)\n    for neighbour in $P0.graph.get(v, []):\n        if neighbour not in visited:\n            dfs_util(neighbour)\ndfs_util($P1)\nreturn traversal",
    "description": "dfs (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_bfs_61": {
    "name": "stack_bfs_61",
    "pattern_type": "general",
    "code_template": "visited = set()\nqueue = [$P1]\ntraversal = []\nvisited.add($P1)\nwhile queue:\n    s = queue.pop(0)\n    traversal.append(s)\n    for neighbour in $P0.graph.get(s, []):\n        if neighbour not in visited:\n            visited.add(neighbour)\n            queue.append(neighbour)\nreturn traversal",
    "description": "bfs (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_topological_sort_62": {
    "name": "stack_topological_sort_62",
    "pattern_type": "algorithm",
    "code_template": "visited = set()\nstack = []\ndef topological_sort_util(v):\n    visited.add(v)\n    for neighbour in $P0.graph.get(v, []):\n        if neighbour not in visited:\n            topological_sort_util(neighbour)\n    stack.append(v)\nfor vertex in $P0.graph:\n    if vertex not in visited:\n        topological_sort_util(vertex)\nreturn stack[::-1]",
    "description": "topological_sort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_edge_63": {
    "name": "stack_add_edge_63",
    "pattern_type": "general",
    "code_template": "if $P1 not in $P0.graph:\n    $P0.graph[$P1] = []\n$P0.graph[$P1].append($P2)",
    "description": "add_edge (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_main_64": {
    "name": "stack_main_64",
    "pattern_type": "general",
    "code_template": "server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind((HOST, PORT))\nserver_socket.listen(5)\nlogging.info(f'Serving HTTP on {HOST} port {PORT}')\nthreads = []\nfor _ in range(MAX_THREADS):\n    thread = threading.Thread(target=worker)\n    thread.start()\n    threads.append(thread)\ntry:\n    while True:\n        (client_socket, address) = server_socket.accept()\n        if request_queue.qsize() >= MAX_QUEUE_SIZE:\n            logging.info('Too many connections. Throttling incoming request.')\n            client_socket.sendall(b'HTTP/1.1 503 Service Unavailable\\n\\nServer busy.')\n            client_socket.close()\n            continue\n        logging.info(f'Connection from {address}')\n        request_queue.put(client_socket)\nexcept KeyboardInterrupt:\n    logging.info('Shutting down server.')\nfinally:\n    server_socket.close()\n    for _ in threads:\n        request_queue.put(None)\n    for thread in threads:\n        thread.join()",
    "description": "main (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_sort_list_65": {
    "name": "stack_merge_sort_list_65",
    "pattern_type": "algorithm",
    "code_template": "if not $P0 or not $P0.next:\n    return $P0\ndef get_middle(node):\n    slow = node\n    fast = node.next\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n    return slow\ndef merge(l1, l2):\n    dummy = ListNode()\n    tail = dummy\n    while l1 and l2:\n        if l1.value < l2.value:\n            tail.next = l1\n            l1 = l1.next\n        else:\n            tail.next = l2\n            l2 = l2.next\n        tail = tail.next\n    tail.next = l1 if l1 else l2\n    return dummy.next\nmiddle = get_middle($P0)\nnext_to_middle = middle.next\nmiddle.next = None\nleft = merge_sort_list($P0)\nright = merge_sort_list(next_to_middle)\nsorted_list = merge(left, right)\nreturn sorted_list",
    "description": "merge_sort_list (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_middle_66": {
    "name": "stack_get_middle_66",
    "pattern_type": "general",
    "code_template": "slow = $P0\nfast = $P0.next\nwhile fast and fast.next:\n    slow = slow.next\n    fast = fast.next.next\nreturn slow",
    "description": "get_middle (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_67": {
    "name": "stack_merge_67",
    "pattern_type": "general",
    "code_template": "dummy = ListNode()\ntail = dummy\nwhile $P0 and $P1:\n    if $P0.value < $P1.value:\n        tail.next = $P0\n        $P0 = $P0.next\n    else:\n        tail.next = $P1\n        $P1 = $P1.next\n    tail = tail.next\ntail.next = $P0 if $P0 else $P1\nreturn dummy.next",
    "description": "merge (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_transform_x_matrix_68": {
    "name": "stack_transform_x_matrix_68",
    "pattern_type": "general",
    "code_template": "n = len($P0)\nfor i in range(n):\n    $P0[i][i] += 1\n    $P0[i][n - 1 - i] += 1\nif n % 2 == 1:\n    center = n // 2\n    $P0[center][center] -= 1\nreturn $P0",
    "description": "transform_x_matrix (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_69": {
    "name": "stack_find_69",
    "pattern_type": "algorithm",
    "code_template": "if $P0[$P1] == $P1:\n    return $P1\nelse:\n    $P0[$P1] = find($P0, $P0[$P1])\n    return $P0[$P1]",
    "description": "find (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_union_70": {
    "name": "stack_union_70",
    "pattern_type": "general",
    "code_template": "rootX = find($P0, $P2)\nrootY = find($P0, $P3)\nif rootX != rootY:\n    if $P1[rootX] > $P1[rootY]:\n        $P0[rootY] = rootX\n    elif $P1[rootX] < $P1[rootY]:\n        $P0[rootX] = rootY\n    else:\n        $P0[rootY] = rootX\n        $P1[rootX] += 1",
    "description": "union (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_kruskal_71": {
    "name": "stack_kruskal_71",
    "pattern_type": "general",
    "code_template": "$P1.sort(key=lambda x: x[2])\nparent = [i for i in range($P0)]\nrank = [0] * $P0\ntotal_weight = 0\nnum_edges = 0\nfor (u, v, w) in $P1:\n    if find(parent, u) != find(parent, v):\n        union(parent, rank, u, v)\n        total_weight += w\n        num_edges += 1\n        if num_edges == $P0 - 1:\n            break\nroot = find(parent, $P2[0])\nfor node in $P2:\n    if find(parent, node) != root:\n        return -1\nreturn total_weight if num_edges == $P0 - 1 else -1",
    "description": "kruskal (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_count_internal_substrings_72": {
    "name": "stack_count_internal_substrings_72",
    "pattern_type": "string",
    "code_template": "count = 0\nfor a in $P1:\n    index = $P0.find(a)\n    if index > 0:\n        count += 1\nreturn count",
    "description": "count_internal_substrings (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_mergeSortAndCount_73": {
    "name": "stack_mergeSortAndCount_73",
    "pattern_type": "algorithm",
    "code_template": "if len($P0) < 2:\n    return ($P0, 0)\nmid = len($P0) // 2\n(left_half, left_inv) = mergeSortAndCount($P0[:mid])\n(right_half, right_inv) = mergeSortAndCount($P0[mid:])\n(merged_array, split_inv) = mergeAndCount(left_half, right_half)\ntotal_inversions = left_inv + right_inv + split_inv\nreturn (merged_array, total_inversions)",
    "description": "mergeSortAndCount (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_mergeAndCount_74": {
    "name": "stack_mergeAndCount_74",
    "pattern_type": "general",
    "code_template": "sorted_array = []\n(i, j) = (0, 0)\ninversions = 0\nwhile i < len($P0) and j < len($P1):\n    if $P0[i] <= $P1[j]:\n        sorted_array.append($P0[i])\n        i += 1\n    else:\n        sorted_array.append($P1[j])\n        inversions += len($P0) - i\n        j += 1\nsorted_array.extend($P0[i:])\nsorted_array.extend($P1[j:])\nreturn (sorted_array, inversions)",
    "description": "mergeAndCount (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_valid_75": {
    "name": "stack_is_valid_75",
    "pattern_type": "general",
    "code_template": "if $P3 in $P0[$P1]:\n    return False\nif $P3 in $P0[:, $P2]:\n    return False\nbox_row_start = $P1 - $P1 % 3\nbox_col_start = $P2 - $P2 % 3\nfor i in range(3):\n    for j in range(3):\n        if $P0[box_row_start + i, box_col_start + j] == $P3:\n            return False\nreturn True",
    "description": "is_valid (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_sudoku_solver_helper_76": {
    "name": "stack_sudoku_solver_helper_76",
    "pattern_type": "general",
    "code_template": "for row in range(9):\n    for col in range(9):\n        if $P0[row, col] == 0:\n            for num in range(1, 10):\n                if is_valid($P0, row, col, num):\n                    $P0[row, col] = num\n                    if sudoku_solver_helper($P0):\n                        return True\n                    $P0[row, col] = 0\n            return False\nreturn True",
    "description": "sudoku_solver_helper (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_sudoku_solver_77": {
    "name": "stack_sudoku_solver_77",
    "pattern_type": "general",
    "code_template": "board = np.array($P0)\nif sudoku_solver_helper(board):\n    return board\nelse:\n    raise ValueError('No solution exists for the provided Sudoku $P0.')",
    "description": "sudoku_solver (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_save_sudoku_to_json_78": {
    "name": "stack_save_sudoku_to_json_78",
    "pattern_type": "general",
    "code_template": "with open($P0, 'w') as json_file:\n    json.dump($P1.tolist(), json_file)",
    "description": "save_sudoku_to_json (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_load_sudoku_from_json_79": {
    "name": "stack_load_sudoku_from_json_79",
    "pattern_type": "general",
    "code_template": "with open($P0, 'r') as json_file:\n    puzzle = json.load(json_file)\nreturn np.array(puzzle)",
    "description": "load_sudoku_from_json (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_empty_80": {
    "name": "stack_is_empty_80",
    "pattern_type": "general",
    "code_template": "return $P0.size == 0",
    "description": "is_empty (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_push_81": {
    "name": "stack_push_81",
    "pattern_type": "general",
    "code_template": "if $P0.size == $P0.capacity:\n    $P0._resize(2 * $P0.capacity)\n$P0.stack[$P0.size] = $P1\n$P0.size += 1",
    "description": "push (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_pop_82": {
    "name": "stack_pop_82",
    "pattern_type": "general",
    "code_template": "if $P0.is_empty():\n    raise ValueError('Stack is empty')\nitem = $P0.stack[$P0.size - 1]\n$P0.stack[$P0.size - 1] = None\n$P0.size -= 1\nif 0 < $P0.size == $P0.capacity // 4:\n    $P0._resize($P0.capacity // 2)\nreturn item",
    "description": "pop (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_reverse_string_with_special_characters_83": {
    "name": "stack_reverse_string_with_special_characters_83",
    "pattern_type": "string",
    "code_template": "alphabets = [char for char in $P0 if char.isalpha()]\nreversed_alphabets = alphabets[::-1]\nresult = []\nalpha_index = 0\nfor char in $P0:\n    if char.isalpha():\n        result.append(reversed_alphabets[alpha_index])\n        alpha_index += 1\n    else:\n        result.append(char)\nreturn ''.join(result)",
    "description": "reverse_string_with_special_characters (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_valid_placement_84": {
    "name": "stack_is_valid_placement_84",
    "pattern_type": "general",
    "code_template": "directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\nfor (dr, dc) in directions:\n    (r, c) = ($P1 + dr, $P2 + dc)\n    while 0 <= r < len($P0) and 0 <= c < len($P0[0]):\n        if $P0[r][c] == 1:\n            return False\n        r += dr\n        c += dc\nreturn True",
    "description": "is_valid_placement (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_85": {
    "name": "stack_dfs_85",
    "pattern_type": "general",
    "code_template": "if $P1 == len($P0):\n    return True\n(next_row, next_col) = ($P1, $P2 + 1) if $P2 + 1 < len($P0[0]) else ($P1 + 1, 0)\nif $P0[$P1][$P2] == -1:\n    return dfs($P0, next_row, next_col)\nif is_valid_placement($P0, $P1, $P2):\n    $P0[$P1][$P2] = 1\n    if dfs($P0, next_row, next_col):\n        return True\n    $P0[$P1][$P2] = 0\nif dfs($P0, next_row, next_col):\n    return True\nreturn False",
    "description": "dfs (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_seating_arrangement_86": {
    "name": "stack_dfs_seating_arrangement_86",
    "pattern_type": "general",
    "code_template": "for row in range(len($P0)):\n    for col in range(len($P0[0])):\n        if $P0[row][col] == 1:\n            $P0[row][col] = 0\nif dfs($P0, 0, 0):\n    return $P0\nelse:\n    return []",
    "description": "dfs_seating_arrangement (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dijkstra_87": {
    "name": "stack_dijkstra_87",
    "pattern_type": "string",
    "code_template": "dist = {node: float('infinity') for node in $P0}\ndist[$P1] = 0\npriority_queue = [(0, $P1)]\nvisited = set()\nwhile priority_queue:\n    (current_dist, current_node) = heapq.heappop(priority_queue)\n    if current_node in visited:\n        continue\n    visited.add(current_node)\n    for (neighbor, weight) in $P0[current_node]:\n        distance = current_dist + weight\n        if distance < dist[neighbor]:\n            dist[neighbor] = distance\n            heapq.heappush(priority_queue, (distance, neighbor))\nreturn dist",
    "description": "dijkstra (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_88": {
    "name": "stack_add_88",
    "pattern_type": "general",
    "code_template": "new_node = Node($P1)\nif not $P0.head:\n    $P0.head = $P0.tail = new_node\nelse:\n    $P0.tail.next = new_node\n    new_node.prev = $P0.tail\n    $P0.tail = new_node",
    "description": "add (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_remove_89": {
    "name": "stack_remove_89",
    "pattern_type": "general",
    "code_template": "current = $P0.head\nwhile current:\n    if current.$P1 == $P1:\n        if current.prev:\n            current.prev.next = current.next\n        if current.next:\n            current.next.prev = current.prev\n        if current == $P0.head:\n            $P0.head = current.next\n        if current == $P0.tail:\n            $P0.tail = current.prev\n        return True\n    current = current.next\nreturn False",
    "description": "remove (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_90": {
    "name": "stack_find_90",
    "pattern_type": "algorithm",
    "code_template": "results = []\ncurrent = $P0.head\nwhile current:\n    if current.$P1 == $P1:\n        results.append(current)\n    current = current.next\nreturn results",
    "description": "find (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_iterate_forward_91": {
    "name": "stack_iterate_forward_91",
    "pattern_type": "general",
    "code_template": "current = $P0.head\nwhile current:\n    yield current.value\n    current = current.next",
    "description": "iterate_forward (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_iterate_backward_92": {
    "name": "stack_iterate_backward_92",
    "pattern_type": "general",
    "code_template": "current = $P0.tail\nwhile current:\n    yield current.value\n    current = current.prev",
    "description": "iterate_backward (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_calculate_z_scores_93": {
    "name": "stack_calculate_z_scores_93",
    "pattern_type": "general",
    "code_template": "z_scores = {}\nfor percentile in $P0:\n    z_scores[percentile] = norm.ppf(percentile / 100)\nreturn z_scores",
    "description": "calculate_z_scores (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_countNonDecreasing_94": {
    "name": "stack_countNonDecreasing_94",
    "pattern_type": "general",
    "code_template": "n = len($P0)\nif n == 0:\n    return 0\ncount = 0\nlength = 1\nfor i in range(1, n):\n    if $P0[i] >= $P0[i - 1]:\n        length += 1\n    else:\n        length = 1\n    count += length\nreturn count",
    "description": "countNonDecreasing (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_95": {
    "name": "stack_merge_95",
    "pattern_type": "general",
    "code_template": "result = []\n(left_index, right_index) = (0, 0)\nwhile left_index < len($P0) and right_index < len($P1):\n    if $P0[left_index] < $P1[right_index]:\n        result.append($P0[left_index])\n        left_index += 1\n    else:\n        result.append($P1[right_index])\n        right_index += 1\nresult.extend($P0[left_index:])\nresult.extend($P1[right_index:])\nreturn result",
    "description": "merge (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_quicksort_96": {
    "name": "stack_quicksort_96",
    "pattern_type": "algorithm",
    "code_template": "if len($P0) <= 1:\n    return $P0\npivot = $P0[len($P0) // 2]\nleft = [x for x in $P0 if x < pivot]\nmiddle = [x for x in $P0 if x == pivot]\nright = [x for x in $P0 if x > pivot]\nreturn quicksort(left) + middle + quicksort(right)",
    "description": "quicksort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_custom_sort_97": {
    "name": "stack_custom_sort_97",
    "pattern_type": "algorithm",
    "code_template": "return sorted($P0, key=lambda x: x % $P1)",
    "description": "custom_sort (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_describe_98": {
    "name": "stack_describe_98",
    "pattern_type": "general",
    "code_template": "return f'This vehicle is a {$P0.make} {$P0.model}.'",
    "description": "describe (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_describe_99": {
    "name": "stack_describe_99",
    "pattern_type": "general",
    "code_template": "return f'This car is a {$P0.make} {$P0.model} with {$P0.doors} doors.'",
    "description": "describe (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_detectCycle_100": {
    "name": "stack_detectCycle_100",
    "pattern_type": "general",
    "code_template": "slow = $P0\nfast = $P0\nwhile fast and fast.next:\n    slow = slow.next\n    fast = fast.next.next\n    if slow == fast:\n        entry = $P0\n        while entry != slow:\n            entry = entry.next\n            slow = slow.next\n        return entry\nreturn None",
    "description": "detectCycle (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_combineLinkedListAndCycleDetection_101": {
    "name": "stack_combineLinkedListAndCycleDetection_101",
    "pattern_type": "list",
    "code_template": "cycle_start = detectCycle($P0)\ncurrent = $P0\npath = []\nvisited = set()\nwhile current:\n    if current in visited:\n        break\n    path.append(current.value)\n    visited.add(current)\n    current = current.next\nreturn (path, cycle_start.value if cycle_start else None)",
    "description": "combineLinkedListAndCycleDetection (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_kmp_search_102": {
    "name": "stack_kmp_search_102",
    "pattern_type": "algorithm",
    "code_template": "def build_lps($P1):\n    lps = [0] * len($P1)\n    length = 0\n    i = 1\n    while i < len($P1):\n        if $P1[i] == $P1[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        elif length != 0:\n            length = lps[length - 1]\n        else:\n            lps[i] = 0\n            i += 1\n    return lps\nindices = []\n(m, n) = (len($P1), len($P0))\nlps = build_lps($P1)\ni = j = 0\nwhile i < n:\n    if $P1[j] == $P0[i]:\n        i += 1\n        j += 1\n    if j == m:\n        indices.append(i - j)\n        j = lps[j - 1]\n    elif i < n and $P1[j] != $P0[i]:\n        if j != 0:\n            j = lps[j - 1]\n        else:\n            i += 1\nreturn indices",
    "description": "kmp_search (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_build_lps_103": {
    "name": "stack_build_lps_103",
    "pattern_type": "general",
    "code_template": "lps = [0] * len($P0)\nlength = 0\ni = 1\nwhile i < len($P0):\n    if $P0[i] == $P0[length]:\n        length += 1\n        lps[i] = length\n        i += 1\n    elif length != 0:\n        length = lps[length - 1]\n    else:\n        lps[i] = 0\n        i += 1\nreturn lps",
    "description": "build_lps (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_recursive_104": {
    "name": "stack_dfs_recursive_104",
    "pattern_type": "general",
    "code_template": "visited = set()\norder = []\ndef dfs(node):\n    if node in visited:\n        return\n    visited.add(node)\n    order.append(node)\n    for neighbor in $P0[node]:\n        dfs(neighbor)\ndfs($P1)\nreturn order",
    "description": "dfs_recursive (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_105": {
    "name": "stack_dfs_105",
    "pattern_type": "general",
    "code_template": "if $P0 in visited:\n    return\nvisited.add($P0)\norder.append($P0)\nfor neighbor in graph[$P0]:\n    dfs(neighbor)",
    "description": "dfs (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_generate_array_106": {
    "name": "stack_generate_array_106",
    "pattern_type": "list",
    "code_template": "$P0.array = [random.randint(10, 390) for _ in range(50)]\n$P0.draw_array($P0.array)",
    "description": "generate_array (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_draw_array_107": {
    "name": "stack_draw_array_107",
    "pattern_type": "list",
    "code_template": "$P0.canvas.delete('all')\ncanvas_height = 400\ncanvas_width = 800\nbar_width = canvas_width / len($P1)\noffset = 10\nspacing = 2\nif not $P2:\n    $P2 = ['blue' for _ in range(len($P1))]\nfor (i, height) in enumerate($P1):\n    x0 = i * bar_width + offset + spacing\n    y0 = canvas_height - height\n    x1 = (i + 1) * bar_width + offset\n    y1 = canvas_height\n    $P0.canvas.create_rectangle(x0, y0, x1, y1, fill=$P2[i])\n$P0.root.update_idletasks()",
    "description": "draw_array (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_start_sorting_108": {
    "name": "stack_start_sorting_108",
    "pattern_type": "algorithm",
    "code_template": "$P0.quick_sort($P0.array, 0, len($P0.array) - 1)",
    "description": "start_sorting (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_quick_sort_109": {
    "name": "stack_quick_sort_109",
    "pattern_type": "algorithm",
    "code_template": "if $P2 < $P3:\n    pi = $P0.partition($P1, $P2, $P3)\n    $P0.quick_sort($P1, $P2, pi - 1)\n    $P0.quick_sort($P1, pi + 1, $P3)",
    "description": "quick_sort (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_maxProfit_110": {
    "name": "stack_maxProfit_110",
    "pattern_type": "general",
    "code_template": "n = len($P0)\nmemo = {}\ndef dp(day, transactions_left, holding):\n    if day == n or transactions_left == 0:\n        return 0\n    if (day, transactions_left, holding) in memo:\n        return memo[day, transactions_left, holding]\n    do_nothing = dp(day + 1, transactions_left, holding)\n    if holding:\n        do_something = $P0[day] + dp(day + 1, transactions_left - 1, False)\n    else:\n        do_something = -$P0[day] + dp(day + 1, transactions_left, True)\n    memo[day, transactions_left, holding] = max(do_nothing, do_something)\n    return memo[day, transactions_left, holding]\nreturn dp(0, 2, False)",
    "description": "maxProfit (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_maxProfit_111": {
    "name": "stack_maxProfit_111",
    "pattern_type": "general",
    "code_template": "n = len($P0)\nif n == 0:\n    return 0\ndp = [[[0] * 2 for _ in range(3)] for _ in range(n)]\nfor i in range(3):\n    dp[0][i][0] = 0\n    dp[0][i][1] = -$P0[0]\nfor day in range(1, n):\n    for transactions_left in range(3):\n        dp[day][transactions_left][0] = dp[day - 1][transactions_left][0]\n        if transactions_left > 0:\n            dp[day][transactions_left][0] = max(dp[day][transactions_left][0], dp[day - 1][transactions_left - 1][1] + $P0[day])\n        dp[day][transactions_left][1] = max(dp[day - 1][transactions_left][1], dp[day - 1][transactions_left][0] - $P0[day])\nreturn dp[n - 1][2][0]",
    "description": "maxProfit (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dp_112": {
    "name": "stack_dp_112",
    "pattern_type": "general",
    "code_template": "if $P0 == n or $P1 == 0:\n    return 0\nif ($P0, $P1, $P2) in memo:\n    return memo[$P0, $P1, $P2]\ndo_nothing = dp($P0 + 1, $P1, $P2)\nif $P2:\n    do_something = prices[$P0] + dp($P0 + 1, $P1 - 1, False)\nelse:\n    do_something = -prices[$P0] + dp($P0 + 1, $P1, True)\nmemo[$P0, $P1, $P2] = max(do_nothing, do_something)\nreturn memo[$P0, $P1, $P2]",
    "description": "dp (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_count_ascending_subarrays_113": {
    "name": "stack_count_ascending_subarrays_113",
    "pattern_type": "list",
    "code_template": "count = 0\ncurrent_length = 0\nfor i in range(len($P0)):\n    if i == 0 or $P0[i] > $P0[i - 1]:\n        current_length += 1\n    else:\n        current_length = 1\n    count += current_length\nreturn count",
    "description": "count_ascending_subarrays (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_sort_by_strength_114": {
    "name": "stack_sort_by_strength_114",
    "pattern_type": "algorithm",
    "code_template": "def strength(elem, index):\n    return abs(elem) + index / 2.0\nsorted_arr = sorted($P0, key=lambda x: strength(x[1], x[0]))\nreturn sorted_arr",
    "description": "sort_by_strength (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_strength_115": {
    "name": "stack_strength_115",
    "pattern_type": "string",
    "code_template": "return abs($P0) + $P1 / 2.0",
    "description": "strength (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_can_map_to_square_difference_116": {
    "name": "stack_can_map_to_square_difference_116",
    "pattern_type": "list",
    "code_template": "def is_square_difference(x):\n    for a in $P0:\n        for b in $P0:\n            if a != b and (a - b) * (a + b) == x:\n                return True\n    return False\nfor t in $P1:\n    if not is_square_difference(t):\n        return False\nreturn True",
    "description": "can_map_to_square_difference (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_square_difference_117": {
    "name": "stack_is_square_difference_117",
    "pattern_type": "general",
    "code_template": "for a in source:\n    for b in source:\n        if a != b and (a - b) * (a + b) == $P0:\n            return True\nreturn False",
    "description": "is_square_difference (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_extract_sums_divisible_by_d_118": {
    "name": "stack_extract_sums_divisible_by_d_118",
    "pattern_type": "general",
    "code_template": "elements = [$P0[i] for i in $P1]\nvalid_sums = set()\nfor i in range(len(elements)):\n    for j in range(i + 1, len(elements)):\n        sum_pair = elements[i] + elements[j]\n        if sum_pair % $P2 == 0:\n            valid_sums.add(sum_pair)\nreturn valid_sums",
    "description": "extract_sums_divisible_by_d (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_deposit_119": {
    "name": "stack_deposit_119",
    "pattern_type": "general",
    "code_template": "if $P1 > 0:\n    $P0.__balance += $P1\n    $P0.__transactions.append(f'Deposited: {$P1}')\nelse:\n    raise ValueError('Deposit $P1 must be positive')",
    "description": "deposit (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_withdraw_120": {
    "name": "stack_withdraw_120",
    "pattern_type": "general",
    "code_template": "if $P1 > 0 and $P1 <= $P0.__balance:\n    $P0.__balance -= $P1\n    $P0.__transactions.append(f'Withdrew: {$P1}')\nelif $P1 > $P0.__balance:\n    raise ValueError('Insufficient funds')\nelse:\n    raise ValueError('Withdrawal $P1 must be positive')",
    "description": "withdraw (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_balance_121": {
    "name": "stack_get_balance_121",
    "pattern_type": "general",
    "code_template": "return $P0.__balance",
    "description": "get_balance (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_transactions_122": {
    "name": "stack_get_transactions_122",
    "pattern_type": "general",
    "code_template": "return $P0.__transactions",
    "description": "get_transactions (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_binary_search_123": {
    "name": "stack_binary_search_123",
    "pattern_type": "algorithm",
    "code_template": "(left, right) = (0, len($P0) - 1)\niterations = 0\nwhile left <= right:\n    iterations += 1\n    mid = left + (right - left) // 2\n    if $P0[mid] == $P1:\n        return (mid, iterations)\n    elif $P0[mid] < $P1:\n        left = mid + 1\n    else:\n        right = mid - 1\nreturn (-1, iterations)",
    "description": "binary_search (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_tsp_124": {
    "name": "stack_tsp_124",
    "pattern_type": "general",
    "code_template": "n = len($P0)\ndp = [[float('inf')] * n for _ in range(1 << n)]\ndp[1][0] = 0\nfor mask in range(1 << n):\n    for i in range(n):\n        if mask & 1 << i:\n            for j in range(n):\n                if mask & 1 << j and i != j:\n                    dp[mask][i] = min(dp[mask][i], dp[mask ^ 1 << i][j] + $P0[j][i])\nreturn min((dp[(1 << n) - 1][i] + $P0[i][0] for i in range(1, n)))",
    "description": "tsp (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_maximal_greedy_substring_125": {
    "name": "stack_maximal_greedy_substring_125",
    "pattern_type": "string",
    "code_template": "counter = Counter($P0)\nsorted_chars = sorted(counter.keys(), reverse=True)\nresult = []\nfor char in sorted_chars:\n    result.append(char * counter[char])\nreturn ''.join(result)",
    "description": "maximal_greedy_substring (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_push_126": {
    "name": "stack_push_126",
    "pattern_type": "general",
    "code_template": "$P0.queue2.append($P1)\nwhile $P0.queue1:\n    $P0.queue2.append($P0.queue1.popleft())\n($P0.queue1, $P0.queue2) = ($P0.queue2, $P0.queue1)",
    "description": "push (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_pop_127": {
    "name": "stack_pop_127",
    "pattern_type": "general",
    "code_template": "if $P0.empty():\n    raise IndexError('pop from empty stack')\nreturn $P0.queue1.popleft()",
    "description": "pop (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_top_128": {
    "name": "stack_top_128",
    "pattern_type": "general",
    "code_template": "if $P0.empty():\n    raise IndexError('top from empty stack')\nreturn $P0.queue1[0]",
    "description": "top (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_empty_129": {
    "name": "stack_empty_129",
    "pattern_type": "general",
    "code_template": "return not $P0.queue1",
    "description": "empty (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_edge_130": {
    "name": "stack_add_edge_130",
    "pattern_type": "general",
    "code_template": "if $P1 not in $P0.adjacency_list:\n    $P0.adjacency_list[$P1] = []\nif $P2 not in $P0.adjacency_list:\n    $P0.adjacency_list[$P2] = []\n$P0.adjacency_list[$P1].append($P2)\n$P0.adjacency_list[$P2].append($P1)",
    "description": "add_edge (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_bfs_131": {
    "name": "stack_bfs_131",
    "pattern_type": "general",
    "code_template": "visited_order = []\nvisited = set()\nqueue = []\nqueue.append($P1)\nvisited.add($P1)\nwhile queue:\n    vertex = queue.pop(0)\n    visited_order.append(vertex)\n    for neighbor in $P0.adjacency_list[vertex]:\n        if neighbor not in visited:\n            visited.add(neighbor)\n            queue.append(neighbor)\nreturn visited_order",
    "description": "bfs (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_iaas_cost_132": {
    "name": "stack_iaas_cost_132",
    "pattern_type": "general",
    "code_template": "if $P1 == 'low':\n    instance_type = 'small'\nelif $P1 == 'medium':\n    instance_type = 'medium'\nelse:\n    instance_type = 'large'\ncost = $P0 * IAAS_PRICING[instance_type]\nreturn cost",
    "description": "iaas_cost (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_paas_cost_133": {
    "name": "stack_paas_cost_133",
    "pattern_type": "general",
    "code_template": "transactions = WORKLOAD_PATTERN[$P0]\ncost = transactions * PAAS_PRICING[$P0]\nreturn cost",
    "description": "paas_cost (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_simulate_day_134": {
    "name": "stack_simulate_day_134",
    "pattern_type": "general",
    "code_template": "total_iaas_cost = 0\ntotal_paas_cost = 0\nfor hour in range(24):\n    workload = random.choice(['low', 'medium', 'high'])\n    total_iaas_cost += iaas_cost(1, workload)\n    total_paas_cost += paas_cost(workload)\nreturn (total_iaas_cost, total_paas_cost)",
    "description": "simulate_day (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_generate_random_list_135": {
    "name": "stack_generate_random_list_135",
    "pattern_type": "list",
    "code_template": "return [random.randint(0, 1000) for _ in range($P0)]",
    "description": "generate_random_list (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_measure_time_136": {
    "name": "stack_measure_time_136",
    "pattern_type": "general",
    "code_template": "start_time = time.time()\n$P0($P1)\nend_time = time.time()\nreturn end_time - start_time",
    "description": "measure_time (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_test_hash_function_137": {
    "name": "stack_test_hash_function_137",
    "pattern_type": "general",
    "code_template": "hash_table = [None] * $P2\nkeys = [i for i in range($P1)]\nstart_time = time.time()\ncollisions = 0\nfor key in keys:\n    index = $P0(key, $P2)\n    if hash_table[index] is not None:\n        collisions += 1\n    else:\n        hash_table[index] = key\nend_time = time.time()\ntime_taken = end_time - start_time\nreturn (collisions, time_taken)",
    "description": "test_hash_function (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_run_tests_138": {
    "name": "stack_run_tests_138",
    "pattern_type": "general",
    "code_template": "table_size = 1000\nnum_keys = 10000\n(collisions_mod, time_mod) = test_hash_function(simple_mod_hash, num_keys, table_size)\n(collisions_mult, time_mult) = test_hash_function(multiplication_hash, num_keys, table_size)\nprint(f'Mod Hash - Collisions: {collisions_mod}, Time: {time_mod:.4f}s')\nprint(f'Multiplication Hash - Collisions: {collisions_mult}, Time: {time_mult:.4f}s')",
    "description": "run_tests (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_collect_sensor_data_139": {
    "name": "stack_collect_sensor_data_139",
    "pattern_type": "general",
    "code_template": "soil_moisture = random.uniform(10, 60)\ntemperature = random.uniform(15, 35)\nsunlight = random.uniform(200, 1000)\nreturn (soil_moisture, temperature, sunlight)",
    "description": "collect_sensor_data (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_analyze_data_140": {
    "name": "stack_analyze_data_140",
    "pattern_type": "general",
    "code_template": "irrigation_needed = $P0 < 30\nfertilizer_needed = $P2 > 500 and $P1 > 20\nreturn (irrigation_needed, fertilizer_needed)",
    "description": "analyze_data (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_provide_recommendations_141": {
    "name": "stack_provide_recommendations_141",
    "pattern_type": "general",
    "code_template": "recommendations = []\nif $P0:\n    recommendations.append('\u9700\u8981\u704c\u6e89')\nelse:\n    recommendations.append('\u4e0d\u9700\u8981\u704c\u6e89')\nif $P1:\n    recommendations.append('\u9700\u8981\u65bd\u80a5')\nelse:\n    recommendations.append('\u4e0d\u9700\u8981\u65bd\u80a5')\nreturn recommendations",
    "description": "provide_recommendations (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_simulate_scenarios_142": {
    "name": "stack_simulate_scenarios_142",
    "pattern_type": "general",
    "code_template": "for _ in range(5):\n    (soil_moisture, temperature, sunlight) = collect_sensor_data()\n    (irrigation_needed, fertilizer_needed) = analyze_data(soil_moisture, temperature, sunlight)\n    recommendations = provide_recommendations(irrigation_needed, fertilizer_needed)\n    print(f'\u4f20\u611f\u5668\u6570\u636e: \u571f\u58e4\u6e7f\u5ea6={soil_moisture:.2f}%, \u6c14\u6e29={temperature:.2f}\u00b0C, \u9633\u5149={sunlight:.2f}lux')\n    print('\u5efa\u8bae:', recommendations)\n    print('-' * 40)",
    "description": "simulate_scenarios (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_and_count_143": {
    "name": "stack_merge_and_count_143",
    "pattern_type": "general",
    "code_template": "i = j = 0\nmerged = []\ninversions = 0\nwhile i < len($P0) and j < len($P1):\n    if $P0[i] <= $P1[j]:\n        merged.append($P0[i])\n        i += 1\n    else:\n        merged.append($P1[j])\n        inversions += len($P0) - i\n        j += 1\nmerged.extend($P0[i:])\nmerged.extend($P1[j:])\nreturn (merged, inversions)",
    "description": "merge_and_count (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_query_data_144": {
    "name": "stack_query_data_144",
    "pattern_type": "general",
    "code_template": "indices_expanded = np.expand_dims($P1, axis=-1)\nresult = np.take_along_axis($P0, indices_expanded, axis=1)\nreturn result",
    "description": "query_data (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dijkstra_145": {
    "name": "stack_dijkstra_145",
    "pattern_type": "string",
    "code_template": "shortest_paths = {node: float('inf') for node in $P0}\nshortest_paths[$P1] = 0\npriority_queue = [(0, $P1)]\nwhile priority_queue:\n    (current_distance, current_node) = heapq.heappop(priority_queue)\n    if current_distance > shortest_paths[current_node]:\n        continue\n    for (neighbor, weight) in $P0[current_node]:\n        distance = current_distance + weight\n        if distance < shortest_paths[neighbor]:\n            shortest_paths[neighbor] = distance\n            heapq.heappush(priority_queue, (distance, neighbor))\nreturn shortest_paths",
    "description": "dijkstra (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_findPathsFromRootToLeaf_146": {
    "name": "stack_findPathsFromRootToLeaf_146",
    "pattern_type": "algorithm",
    "code_template": "if $P0 is None:\n    return\n$P2.append($P0.value)\nif $P0.left is None and $P0.right is None and ($P0.value == $P1):\n    $P3.append(list($P2))\nelse:\n    findPathsFromRootToLeaf($P0.left, $P1 - $P0.value, $P2, $P3)\n    findPathsFromRootToLeaf($P0.right, $P1 - $P0.value, $P2, $P3)\n$P2.pop()",
    "description": "findPathsFromRootToLeaf (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_findPaths_147": {
    "name": "stack_findPaths_147",
    "pattern_type": "algorithm",
    "code_template": "all_paths = []\nfindPathsFromRootToLeaf($P0, $P1, [], all_paths)\nreturn all_paths",
    "description": "findPaths (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_create_sample_graph_148": {
    "name": "stack_create_sample_graph_148",
    "pattern_type": "general",
    "code_template": "G = nx.Graph()\npositions = {0: (0, 0), 1: (1, 2), 2: (2, 1), 3: (3, 3), 4: (4, 0)}\nedges = [(0, 1, 1.4), (1, 2, 1), (1, 3, 1.4), (2, 4, 2), (3, 4, 1)]\nfor (node, pos) in positions.items():\n    G.add_node(node, pos=pos)\nfor (u, v, weight) in edges:\n    G.add_edge(u, v, weight=weight)\nreturn G",
    "description": "create_sample_graph (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_floyd_warshall_149": {
    "name": "stack_floyd_warshall_149",
    "pattern_type": "general",
    "code_template": "V = len($P0)\ndist = [[float('inf')] * V for _ in range(V)]\nfor i in range(V):\n    for j in range(V):\n        if i == j:\n            dist[i][j] = 0\n        elif $P0[i][j] != 0:\n            dist[i][j] = $P0[i][j]\nfor k in range(V):\n    for i in range(V):\n        for j in range(V):\n            if dist[i][j] > dist[i][k] + dist[k][j]:\n                dist[i][j] = dist[i][k] + dist[k][j]\nreturn dist",
    "description": "floyd_warshall (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_update_150": {
    "name": "stack_update_150",
    "pattern_type": "general",
    "code_template": "$P0.velocity_y += GRAVITY\n$P0.rect.y += $P0.velocity_y\nif $P0.rect.bottom > SCREEN_HEIGHT:\n    $P0.rect.bottom = SCREEN_HEIGHT\n    $P0.velocity_y = 0\n    $P0.is_jumping = False",
    "description": "update (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_move_left_151": {
    "name": "stack_move_left_151",
    "pattern_type": "general",
    "code_template": "$P0.rect.x -= 5",
    "description": "move_left (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_move_right_152": {
    "name": "stack_move_right_152",
    "pattern_type": "general",
    "code_template": "$P0.rect.x += 5",
    "description": "move_right (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_jump_153": {
    "name": "stack_jump_153",
    "pattern_type": "general",
    "code_template": "if not $P0.is_jumping:\n    $P0.velocity_y = JUMP_STRENGTH\n    $P0.is_jumping = True",
    "description": "jump (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_main_154": {
    "name": "stack_main_154",
    "pattern_type": "general",
    "code_template": "logger1 = Logger.get_instance()\nlogger1.log('This is the first log message.')\nlogger2 = Logger.get_instance()\nlogger2.log('This is the second log message.')\nprint(f'Logger1 and Logger2 are the same: {logger1 is logger2}')",
    "description": "main (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_instance_155": {
    "name": "stack_get_instance_155",
    "pattern_type": "general",
    "code_template": "if Logger._instance is None:\n    with Logger._lock:\n        if Logger._instance is None:\n            Logger._instance = Logger()\nreturn Logger._instance",
    "description": "get_instance (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_log_156": {
    "name": "stack_log_156",
    "pattern_type": "general",
    "code_template": "$P0.log_data.append($P1)\nprint(f'Logged $P1: {$P1}')",
    "description": "log (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_round_robin_157": {
    "name": "stack_round_robin_157",
    "pattern_type": "general",
    "code_template": "queue = deque($P0)\nexecution_order = []\nwhile queue:\n    process = queue.popleft()\n    if process.remaining_time <= $P1:\n        execution_order.append(process.pid)\n        process.remaining_time = 0\n    else:\n        execution_order.append(process.pid)\n        process.remaining_time -= $P1\n        queue.append(process)\nreturn execution_order",
    "description": "round_robin (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_priority_scheduling_158": {
    "name": "stack_priority_scheduling_158",
    "pattern_type": "general",
    "code_template": "execution_order = []\n$P0.sort(key=lambda x: (-x.priority, x.pid))\nfor process in $P0:\n    execution_order.append(process.pid)\nreturn execution_order",
    "description": "priority_scheduling (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_evaluate_expression_159": {
    "name": "stack_evaluate_expression_159",
    "pattern_type": "general",
    "code_template": "ops = {'+': operator.add, '-': operator.sub, '*': operator.mul, '/': operator.truediv}\nnum_stack = []\nop_stack = []\ndef precedence(op):\n    if op == '+' or op == '-':\n        return 1\n    if op == '*' or op == '/':\n        return 2\n    return 0\ndef apply_operator():\n    \"\"\"Apply the operator on the top of the operator stack to the top two numbers in the number stack.\"\"\"\n    if len(num_stack) < 2 or len(op_stack) == 0:\n        return\n    right = num_stack.pop()\n    left = num_stack.pop()\n    op = op_stack.pop()\n    num_stack.append(ops[op](left, right))\ni = 0\nwhile i < len($P0):\n    ch = $P0[i]\n    if ch == ' ':\n        i += 1\n        continue\n    if ch.isdigit() or ch == '.':\n        num_str = []\n        while i < len($P0) and ($P0[i].isdigit() or $P0[i] == '.'):\n            num_str.append($P0[i])\n            i += 1\n        num_stack.append(float(''.join(num_str)))\n        continue\n    elif ch == '(':\n        op_stack.append(ch)\n    elif ch == ')':\n        while len(op_stack) > 0 and op_stack[-1] != '(':\n            apply_operator()\n        op_stack.pop()\n    elif ch in ops:\n        while len(op_stack) > 0 and precedence(op_stack[-1]) >= precedence(ch):\n            apply_operator()\n        op_stack.append(ch)\n    i += 1\nwhile len(op_stack) > 0:\n    apply_operator()\nreturn num_stack[0] if num_stack else 0.0",
    "description": "evaluate_expression (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_precedence_160": {
    "name": "stack_precedence_160",
    "pattern_type": "general",
    "code_template": "if $P0 == '+' or $P0 == '-':\n    return 1\nif $P0 == '*' or $P0 == '/':\n    return 2\nreturn 0",
    "description": "precedence (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_producer_161": {
    "name": "stack_producer_161",
    "pattern_type": "general",
    "code_template": "while True:\n    item = random.randint(1, 100)\n    empty.acquire()\n    mutex.acquire()\n    buffer.append(item)\n    print(f'Producer {$P0} produced {item}. Buffer: {buffer}')\n    mutex.release()\n    full.release()\n    time.sleep(random.uniform(0.1, 1))",
    "description": "producer (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_consumer_162": {
    "name": "stack_consumer_162",
    "pattern_type": "general",
    "code_template": "while True:\n    full.acquire()\n    mutex.acquire()\n    item = buffer.pop(0)\n    print(f'Consumer {$P0} consumed {item}. Buffer: {buffer}')\n    mutex.release()\n    empty.release()\n    time.sleep(random.uniform(0.1, 1))",
    "description": "consumer (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_contains_cycle_163": {
    "name": "stack_contains_cycle_163",
    "pattern_type": "general",
    "code_template": "(UNVISITED, VISITING, VISITED) = (0, 1, 2)\nstate = {node: UNVISITED for node in $P0}\ndef dfs(node):\n    if state[node] == VISITING:\n        return True\n    if state[node] == VISITED:\n        return False\n    state[node] = VISITING\n    for neighbor in $P0[node]:\n        if dfs(neighbor):\n            return True\n    state[node] = VISITED\n    return False\nfor node in $P0:\n    if state[node] == UNVISITED:\n        if dfs(node):\n            return True\nreturn False",
    "description": "contains_cycle (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_164": {
    "name": "stack_dfs_164",
    "pattern_type": "general",
    "code_template": "if state[$P0] == VISITING:\n    return True\nif state[$P0] == VISITED:\n    return False\nstate[$P0] = VISITING\nfor neighbor in graph[$P0]:\n    if dfs(neighbor):\n        return True\nstate[$P0] = VISITED\nreturn False",
    "description": "dfs (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_random_string_165": {
    "name": "stack_random_string_165",
    "pattern_type": "string",
    "code_template": "return ''.join(random.choices(string.ascii_lowercase, k=$P0))",
    "description": "random_string (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_benchmark_query_166": {
    "name": "stack_benchmark_query_166",
    "pattern_type": "general",
    "code_template": "start_time = time.time()\ncursor.execute($P0, $P1)\nend_time = time.time()\nreturn end_time - start_time",
    "description": "benchmark_query (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_task_func_167": {
    "name": "stack_task_func_167",
    "pattern_type": "general",
    "code_template": "sorted_data = quicksort($P0)\nmean_value = statistics.mean(sorted_data)\nmedian_value = statistics.median(sorted_data)\nmode_value = statistics.mode(sorted_data)\nreturn {'mean': mean_value, 'median': median_value, 'mode': mode_value}",
    "description": "task_func (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_insert_168": {
    "name": "stack_insert_168",
    "pattern_type": "general",
    "code_template": "dummy = ListNode(0)\ndummy.next = $P0\ncurrent = dummy\nfor _ in range($P1):\n    if current.next is None:\n        break\n    current = current.next\nnew_node = ListNode($P2)\nnew_node.next = current.next\ncurrent.next = new_node\nreturn dummy.next",
    "description": "insert (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_reverse_169": {
    "name": "stack_reverse_169",
    "pattern_type": "general",
    "code_template": "prev = None\ncurrent = $P0\nwhile current:\n    next_node = current.next\n    current.next = prev\n    prev = current\n    current = next_node\nreturn prev",
    "description": "reverse (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_special_linked_list_operation_170": {
    "name": "stack_special_linked_list_operation_170",
    "pattern_type": "list",
    "code_template": "for operation in $P1:\n    if operation[0] == 'insert':\n        $P0 = insert($P0, operation[1], operation[2])\n    elif operation[0] == 'reverse':\n        $P0 = reverse($P0)\nreturn $P0",
    "description": "special_linked_list_operation (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_greedy_knapsack_171": {
    "name": "stack_greedy_knapsack_171",
    "pattern_type": "general",
    "code_template": "density_values = [(v / w, w, v) for (v, w) in zip($P1, $P0)]\ndensity_values.sort(reverse=True, key=lambda x: x[0])\ntotal_value = 0\ntotal_weight = 0\nfor (density, weight, value) in density_values:\n    if total_weight + weight <= $P2:\n        total_weight += weight\n        total_value += value\n    else:\n        break\nreturn total_value",
    "description": "greedy_knapsack (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dp_knapsack_172": {
    "name": "stack_dp_knapsack_172",
    "pattern_type": "general",
    "code_template": "n = len($P1)\ndp = [[0] * ($P2 + 1) for _ in range(n + 1)]\nfor i in range(1, n + 1):\n    for w in range(1, $P2 + 1):\n        if $P0[i - 1] <= w:\n            dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - $P0[i - 1]] + $P1[i - 1])\n        else:\n            dp[i][w] = dp[i - 1][w]\nreturn dp[n][$P2]",
    "description": "dp_knapsack (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_multi_source_bfs_173": {
    "name": "stack_multi_source_bfs_173",
    "pattern_type": "general",
    "code_template": "queue = deque()\nshortest_distances = {}\nfor source in $P1:\n    queue.append((source, 0))\n    shortest_distances[source] = 0\nwhile queue:\n    (current_node, current_dist) = queue.popleft()\n    for neighbor in $P0[current_node]:\n        new_dist = current_dist + 1\n        if neighbor not in shortest_distances or new_dist < shortest_distances[neighbor]:\n            shortest_distances[neighbor] = new_dist\n            queue.append((neighbor, new_dist))\nreturn shortest_distances",
    "description": "multi_source_bfs (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_setBit_174": {
    "name": "stack_setBit_174",
    "pattern_type": "general",
    "code_template": "part_index = $P1 // 32\nbit_position = $P1 % 32\n$P0.bit_array[part_index] |= 1 << bit_position",
    "description": "setBit (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_shortest_path_175": {
    "name": "stack_find_shortest_path_175",
    "pattern_type": "algorithm",
    "code_template": "graph = defaultdict(lambda : {'red': [], 'blue': []})\nfor (u, v) in $P1:\n    graph[u]['red'].append(v)\nfor (u, v) in $P2:\n    graph[u]['blue'].append(v)\nqueue = deque([($P3, 'none', 0)])\nvisited = defaultdict(lambda : {'red': False, 'blue': False})\nwhile queue:\n    (current_node, prev_color, steps) = queue.popleft()\n    if current_node == $P4:\n        return steps\n    next_color = 'blue' if prev_color == 'red' else 'red'\n    for neighbor in graph[current_node][next_color]:\n        if not visited[neighbor][next_color]:\n            visited[neighbor][next_color] = True\n            queue.append((neighbor, next_color, steps + 1))\nreturn -1",
    "description": "find_shortest_path (5 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_largest_unique_sum_subarray_176": {
    "name": "stack_find_largest_unique_sum_subarray_176",
    "pattern_type": "algorithm",
    "code_template": "if not $P0:\n    return []\nseen_sums = set()\nsum_to_subarray = {}\ncurrent_sum = 0\nstart = 0\nmax_length = 0\nresult_subarray = []\nfor end in range(len($P0)):\n    current_sum += $P0[end]\n    while current_sum in seen_sums and start <= end:\n        current_sum -= $P0[start]\n        start += 1\n    if current_sum not in seen_sums:\n        seen_sums.add(current_sum)\n        sum_to_subarray[current_sum] = $P0[start:end + 1]\n        if end - start + 1 > max_length:\n            max_length = end - start + 1\n            result_subarray = $P0[start:end + 1]\nreturn result_subarray",
    "description": "find_largest_unique_sum_subarray (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_quick_sort_177": {
    "name": "stack_quick_sort_177",
    "pattern_type": "algorithm",
    "code_template": "def partition(low, high):\n    pivot = $P0[high]\n    i = low - 1\n    for j in range(low, high):\n        if abs($P0[j]) <= abs(pivot):\n            i += 1\n            ($P0[i], $P0[j]) = ($P0[j], $P0[i])\n    ($P0[i + 1], $P0[high]) = ($P0[high], $P0[i + 1])\n    return i + 1\ndef quick_sort_recursive(low, high):\n    if low < high:\n        pi = partition(low, high)\n        quick_sort_recursive(low, pi - 1)\n        quick_sort_recursive(pi + 1, high)\nquick_sort_recursive(0, len($P0) - 1)\nreturn $P0",
    "description": "quick_sort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_sort_complex_numbers_by_magnitude_178": {
    "name": "stack_sort_complex_numbers_by_magnitude_178",
    "pattern_type": "algorithm",
    "code_template": "sorted_array = quick_sort($P0)\ntime_complexity = 'Best-case time complexity: O(n log n) when the pivot divides the array evenly. Worst-case time complexity: O(n^2) when the array is already sorted or all elements are the same.'\nreturn (sorted_array, time_complexity)",
    "description": "sort_complex_numbers_by_magnitude (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_partition_179": {
    "name": "stack_partition_179",
    "pattern_type": "general",
    "code_template": "pivot = arr[$P1]\ni = $P0 - 1\nfor j in range($P0, $P1):\n    if abs(arr[j]) <= abs(pivot):\n        i += 1\n        (arr[i], arr[j]) = (arr[j], arr[i])\n(arr[i + 1], arr[$P1]) = (arr[$P1], arr[i + 1])\nreturn i + 1",
    "description": "partition (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_quick_sort_recursive_180": {
    "name": "stack_quick_sort_recursive_180",
    "pattern_type": "algorithm",
    "code_template": "if $P0 < $P1:\n    pi = partition($P0, $P1)\n    quick_sort_recursive($P0, pi - 1)\n    quick_sort_recursive(pi + 1, $P1)",
    "description": "quick_sort_recursive (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_insertUniqueElement_181": {
    "name": "stack_insertUniqueElement_181",
    "pattern_type": "general",
    "code_template": "n = len($P0)\nm = len($P0[0])\nfor row in $P0:\n    if $P1 in row:\n        return $P0\nfor i in range(n):\n    for j in range(m):\n        if $P1 not in $P0[i] and all((row[j] != $P1 for row in $P0)):\n            original_value = $P0[i][j]\n            $P0[i][j] = $P1\n            if all((sum(row) % 2 == 0 for row in $P0)):\n                return $P0\n            $P0[i][j] = original_value\nreturn $P0",
    "description": "insertUniqueElement (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_findMST_182": {
    "name": "stack_findMST_182",
    "pattern_type": "algorithm",
    "code_template": "$P1.sort(key=lambda x: x[2])\nuf = UnionFind($P0)\nmst = []\ntotal_weight = 0\nfor (u, v, w) in $P1:\n    if uf.union(u, v):\n        mst.append((u, v, w))\n        total_weight += w\nreturn (mst, total_weight)",
    "description": "findMST (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_183": {
    "name": "stack_find_183",
    "pattern_type": "algorithm",
    "code_template": "if $P0.parent[$P1] != $P1:\n    $P0.parent[$P1] = $P0.find($P0.parent[$P1])\nreturn $P0.parent[$P1]",
    "description": "find (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_union_184": {
    "name": "stack_union_184",
    "pattern_type": "general",
    "code_template": "root1 = $P0.find($P1)\nroot2 = $P0.find($P2)\nif root1 != root2:\n    if $P0.rank[root1] > $P0.rank[root2]:\n        $P0.parent[root2] = root1\n    elif $P0.rank[root1] < $P0.rank[root2]:\n        $P0.parent[root1] = root2\n    else:\n        $P0.parent[root2] = root1\n        $P0.rank[root1] += 1\n    return True\nreturn False",
    "description": "union (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_coin_change_recursive_185": {
    "name": "stack_coin_change_recursive_185",
    "pattern_type": "general",
    "code_template": "memo = {}\ndef dfs(remaining):\n    if remaining == 0:\n        return 0\n    if remaining < 0:\n        return float('inf')\n    if remaining in memo:\n        return memo[remaining]\n    min_coins = float('inf')\n    for coin in $P0:\n        result = dfs(remaining - coin)\n        if result != float('inf'):\n            min_coins = min(min_coins, result + 1)\n    memo[remaining] = min_coins\n    return memo[remaining]\nresult = dfs($P1)\nreturn result if result != float('inf') else -1",
    "description": "coin_change_recursive (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_coin_change_iterative_186": {
    "name": "stack_coin_change_iterative_186",
    "pattern_type": "general",
    "code_template": "dp = [float('inf')] * ($P1 + 1)\ndp[0] = 0\nfor t in range(1, $P1 + 1):\n    for coin in $P0:\n        if t - coin >= 0:\n            dp[t] = min(dp[t], dp[t - coin] + 1)\nreturn dp[$P1] if dp[$P1] != float('inf') else -1",
    "description": "coin_change_iterative (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_187": {
    "name": "stack_dfs_187",
    "pattern_type": "general",
    "code_template": "if $P0 == 0:\n    return 0\nif $P0 < 0:\n    return float('inf')\nif $P0 in memo:\n    return memo[$P0]\nmin_coins = float('inf')\nfor coin in coins:\n    result = dfs($P0 - coin)\n    if result != float('inf'):\n        min_coins = min(min_coins, result + 1)\nmemo[$P0] = min_coins\nreturn memo[$P0]",
    "description": "dfs (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_count_vowels_188": {
    "name": "stack_count_vowels_188",
    "pattern_type": "general",
    "code_template": "vowels = 'aeiouAEIOU'\nresult = []\nfor string in $P0:\n    count = 0\n    for char in string:\n        if char in vowels:\n            count += 1\n    result.append(count)\nreturn result",
    "description": "count_vowels (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_bubble_sort_189": {
    "name": "stack_bubble_sort_189",
    "pattern_type": "algorithm",
    "code_template": "n = len($P0)\nfor i in range(n):\n    for j in range(0, n - i - 1):\n        if $P0[j] > $P0[j + 1]:\n            ($P0[j], $P0[j + 1]) = ($P0[j + 1], $P0[j])\nreturn $P0",
    "description": "bubble_sort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_user_transaction_190": {
    "name": "stack_user_transaction_190",
    "pattern_type": "general",
    "code_template": "with $P1:\n    for _ in range(5):\n        transaction_amount = random.randint(10, 100)\n        if random.choice([True, False]):\n            $P0.deposit(transaction_amount)\n        else:\n            $P0.withdraw(transaction_amount)\n        time.sleep(random.uniform(0.1, 0.5))",
    "description": "user_transaction (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_simulate_banking_system_191": {
    "name": "stack_simulate_banking_system_191",
    "pattern_type": "general",
    "code_template": "account = BankAccount(1000)\nsemaphore = threading.Semaphore(3)\nthreads = []\nfor _ in range(10):\n    thread = threading.Thread(target=user_transaction, args=(account, semaphore))\n    threads.append(thread)\n    thread.start()\nfor thread in threads:\n    thread.join()\nprint(f'Final account balance: {account.balance}')",
    "description": "simulate_banking_system (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_deposit_192": {
    "name": "stack_deposit_192",
    "pattern_type": "general",
    "code_template": "with $P0.lock:\n    print(f'Depositing {$P1}. Current Balance: {$P0.balance}')\n    time.sleep(random.uniform(0.1, 0.5))\n    $P0.balance += $P1\n    print(f'Balance after deposit: {$P0.balance}')",
    "description": "deposit (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_withdraw_193": {
    "name": "stack_withdraw_193",
    "pattern_type": "general",
    "code_template": "with $P0.lock:\n    if $P0.balance >= $P1:\n        print(f'Withdrawing {$P1}. Current Balance: {$P0.balance}')\n        time.sleep(random.uniform(0.1, 0.5))\n        $P0.balance -= $P1\n        print(f'Balance after withdrawal: {$P0.balance}')\n    else:\n        print(f'Failed withdrawal attempt for {$P1}. Insufficient balance.')",
    "description": "withdraw (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_min_coins_greedy_194": {
    "name": "stack_min_coins_greedy_194",
    "pattern_type": "general",
    "code_template": "$P0.sort(reverse=True)\nnum_coins = 0\nfor coin in $P0:\n    while $P1 >= coin:\n        $P1 -= coin\n        num_coins += 1\nreturn num_coins",
    "description": "min_coins_greedy (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_min_coins_dp_195": {
    "name": "stack_min_coins_dp_195",
    "pattern_type": "general",
    "code_template": "dp = [float('inf')] * ($P1 + 1)\ndp[0] = 0\nfor i in range(1, $P1 + 1):\n    for coin in $P0:\n        if i - coin >= 0:\n            dp[i] = min(dp[i], dp[i - coin] + 1)\nreturn dp[$P1] if dp[$P1] != float('inf') else -1",
    "description": "min_coins_dp (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_collect_demographic_data_196": {
    "name": "stack_collect_demographic_data_196",
    "pattern_type": "general",
    "code_template": "demographics = [{'gender': 'Male', 'age': 25}, {'gender': 'Female', 'age': 27}, {'gender': 'Non-binary', 'age': 22}, {'gender': 'Female', 'age': 30}, {'gender': 'Declined', 'age': None}]\nreturn demographics",
    "description": "collect_demographic_data (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_calculate_iou_197": {
    "name": "stack_calculate_iou_197",
    "pattern_type": "general",
    "code_template": "x_left = max($P0[0], $P1[0])\ny_top = max($P0[1], $P1[1])\nx_right = min($P0[2], $P1[2])\ny_bottom = min($P0[3], $P1[3])\nif x_right < x_left or y_bottom < y_top:\n    return 0.0\nintersection_area = (x_right - x_left) * (y_bottom - y_top)\nbox1_area = ($P0[2] - $P0[0]) * ($P0[3] - $P0[1])\nbox2_area = ($P1[2] - $P1[0]) * ($P1[3] - $P1[1])\niou = intersection_area / float(box1_area + box2_area - intersection_area)\nreturn iou",
    "description": "calculate_iou (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_apply_nonmax_suppression_198": {
    "name": "stack_apply_nonmax_suppression_198",
    "pattern_type": "general",
    "code_template": "indices = np.argsort($P1)[::-1]\nfiltered_bboxes = []\nwhile len(indices) > 0:\n    current_index = indices[0]\n    current_bbox = $P0[current_index]\n    filtered_bboxes.append(current_bbox)\n    remaining_indices = indices[1:]\n    suppressed_indices = []\n    for idx in remaining_indices:\n        iou = calculate_iou(current_bbox, $P0[idx])\n        if iou < $P2:\n            suppressed_indices.append(idx)\n    indices = np.array(suppressed_indices)\nreturn filtered_bboxes",
    "description": "apply_nonmax_suppression (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dijkstra_199": {
    "name": "stack_dijkstra_199",
    "pattern_type": "string",
    "code_template": "pq = [(0, $P1)]\ndistances = {node: float('inf') for node in $P0}\ndistances[$P1] = 0\nwhile pq:\n    (current_distance, current_node) = heapq.heappop(pq)\n    if current_distance > distances[current_node]:\n        continue\n    for (neighbor, weight) in $P0[current_node]:\n        distance = current_distance + weight\n        if distance < distances[neighbor]:\n            distances[neighbor] = distance\n            heapq.heappush(pq, (distance, neighbor))\nreturn distances",
    "description": "dijkstra (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dijkstra_safe_200": {
    "name": "stack_dijkstra_safe_200",
    "pattern_type": "string",
    "code_template": "for edges in $P0.values():\n    for (_, weight) in edges:\n        if weight < 0:\n            raise ValueError(\"Dijkstra's algorithm cannot handle negative weights\")\nreturn dijkstra($P0, $P1)",
    "description": "dijkstra_safe (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_heuristic_201": {
    "name": "stack_heuristic_201",
    "pattern_type": "general",
    "code_template": "return 0",
    "description": "heuristic (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_astar_202": {
    "name": "stack_astar_202",
    "pattern_type": "general",
    "code_template": "pq = [(0, $P1)]\ncame_from = {$P1: None}\ng_score = {node: float('inf') for node in $P0}\ng_score[$P1] = 0\nf_score = {node: float('inf') for node in $P0}\nf_score[$P1] = heuristic($P1, $P2)\nwhile pq:\n    (_, current) = heapq.heappop(pq)\n    if current == $P2:\n        path = []\n        while current:\n            path.append(current)\n            current = came_from[current]\n        return path[::-1]\n    for (neighbor, weight) in $P0[current]:\n        tentative_g_score = g_score[current] + weight\n        if tentative_g_score < g_score[neighbor]:\n            came_from[neighbor] = current\n            g_score[neighbor] = tentative_g_score\n            f_score[neighbor] = tentative_g_score + heuristic(neighbor, $P2)\n            heapq.heappush(pq, (f_score[neighbor], neighbor))\nreturn []",
    "description": "astar (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_max_subset_squares_203": {
    "name": "stack_max_subset_squares_203",
    "pattern_type": "general",
    "code_template": "results = []\nfor query in $P1:\n    (m, squares) = query\n    squares.sort(key=lambda sq: (sq[0], sq[1], sq[2], sq[3]))\n    dp = [1] * m\n    for i in range(m):\n        for j in range(i):\n            if squares[j][0] <= squares[i][0] and squares[j][1] <= squares[i][1] and (squares[j][2] >= squares[i][2]) and (squares[j][3] >= squares[i][3]):\n                dp[i] = max(dp[i], dp[j] + 1)\n    results.append(max(dp))\nreturn results",
    "description": "max_subset_squares (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_test_hash_table_204": {
    "name": "stack_test_hash_table_204",
    "pattern_type": "general",
    "code_template": "hash_table = HashTable()\nhash_table.insert('apple', 1)\nhash_table.insert('banana', 2)\nhash_table.insert('orange', 3)\nassert hash_table.search('apple') == 1, 'Test failed!'\nassert hash_table.search('banana') == 2, 'Test failed!'\nassert hash_table.search('orange') == 3, 'Test failed!'\nassert hash_table.delete('banana') == True, 'Test failed!'\nassert hash_table.search('banana') is None, 'Test failed!'\nprint('All tests passed!')",
    "description": "test_hash_table (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_hash_function_205": {
    "name": "stack_hash_function_205",
    "pattern_type": "general",
    "code_template": "return hash($P1) % $P0.capacity",
    "description": "hash_function (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_insert_206": {
    "name": "stack_insert_206",
    "pattern_type": "general",
    "code_template": "idx = $P0.hash_function($P1)\nif not $P0.table[idx]:\n    $P0.table[idx] = ListNode($P1, $P2)\nelse:\n    current = $P0.table[idx]\n    while True:\n        if current.$P1 == $P1:\n            current.$P2 = $P2\n            return\n        if not current.next:\n            break\n        current = current.next\n    current.next = ListNode($P1, $P2)",
    "description": "insert (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_producer_207": {
    "name": "stack_producer_207",
    "pattern_type": "general",
    "code_template": "while True:\n    item = random.randint(1, 100)\n    empty.acquire()\n    with mutex:\n        buffer.append(item)\n        print(f'Produced {item}, buffer state: {buffer}')\n    full.release()\n    time.sleep(random.uniform(0.1, 1.0))",
    "description": "producer (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_consumer_208": {
    "name": "stack_consumer_208",
    "pattern_type": "general",
    "code_template": "while True:\n    full.acquire()\n    with mutex:\n        item = buffer.pop(0)\n        print(f'Consumed {item}, buffer state: {buffer}')\n    empty.release()\n    time.sleep(random.uniform(0.1, 1.0))",
    "description": "consumer (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_complex_check_209": {
    "name": "stack_complex_check_209",
    "pattern_type": "general",
    "code_template": "segments = $P0.split('|')\nstar_dominant_count = 0\nfor segment in segments:\n    if not segment:\n        continue\n    char_count = {}\n    for char in segment:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    star_count = char_count.get('*', 0)\n    is_star_dominant = True\n    for (char, count) in char_count.items():\n        if char != '*' and count >= star_count:\n            is_star_dominant = False\n            break\n    if is_star_dominant:\n        star_dominant_count += 1\nreturn star_dominant_count % 2 == 1",
    "description": "complex_check (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_reverse_odd_indices_210": {
    "name": "stack_reverse_odd_indices_210",
    "pattern_type": "general",
    "code_template": "odd_index_elements = [$P0[i] for i in range(1, len($P0), 2)]\nodd_index_elements.reverse()\nfor (i, value) in zip(range(1, len($P0), 2), odd_index_elements):\n    $P0[i] = value\nreturn $P0",
    "description": "reverse_odd_indices (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_rollback_211": {
    "name": "stack_rollback_211",
    "pattern_type": "general",
    "code_template": "if 0 <= $P1 < len($P0.version_history):\n    $P0.graph = $P0.version_history[$P1]\nelse:\n    raise IndexError('Invalid version number.')",
    "description": "rollback (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_vertex_212": {
    "name": "stack_add_vertex_212",
    "pattern_type": "general",
    "code_template": "if $P1 not in $P0.graph:\n    $P0.graph[$P1] = set()\n    $P0._save_version()",
    "description": "add_vertex (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_remove_vertex_213": {
    "name": "stack_remove_vertex_213",
    "pattern_type": "general",
    "code_template": "if $P1 in $P0.graph:\n    for v in $P0.graph.values():\n        v.discard($P1)\n    del $P0.graph[$P1]\n    $P0._save_version()",
    "description": "remove_vertex (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_books_214": {
    "name": "stack_get_books_214",
    "pattern_type": "general",
    "code_template": "return jsonify({'books': 'List of books'})",
    "description": "get_books (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_reserve_book_215": {
    "name": "stack_reserve_book_215",
    "pattern_type": "general",
    "code_template": "data = request.json\nreturn jsonify({'status': 'book reserved'})",
    "description": "reserve_book (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_create_user_216": {
    "name": "stack_create_user_216",
    "pattern_type": "general",
    "code_template": "data = request.json\nreturn jsonify({'status': 'user created'})",
    "description": "create_user (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_user_217": {
    "name": "stack_get_user_217",
    "pattern_type": "general",
    "code_template": "return jsonify({'$P0': $P0, 'account': 'User account details'})",
    "description": "get_user (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_sort_218": {
    "name": "stack_merge_sort_218",
    "pattern_type": "algorithm",
    "code_template": "if $P2 - $P1 <= 1:\n    return\nmid = ($P1 + $P2) // 2\nmerge_sort($P0, $P1, mid)\nmerge_sort($P0, mid, $P2)\nmerge($P0, $P1, mid, $P2)",
    "description": "merge_sort (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_219": {
    "name": "stack_merge_219",
    "pattern_type": "general",
    "code_template": "left = $P1\nright = $P2\nwhile left < right and right < $P3:\n    if $P0[left] <= $P0[right]:\n        left += 1\n    else:\n        temp = $P0[right]\n        for i in range(right, left, -1):\n            $P0[i] = $P0[i - 1]\n        $P0[left] = temp\n        left += 1\n        right += 1",
    "description": "merge (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_evaluate_expression_220": {
    "name": "stack_evaluate_expression_220",
    "pattern_type": "general",
    "code_template": "stack = []\nfor token in $P0:\n    if token.isdigit() or (token[0] == '-' and token[1:].isdigit()):\n        stack.append(int(token))\n    else:\n        if len(stack) < 2:\n            raise ValueError('\u975e\u6cd5\u8868\u8fbe\u5f0f')\n        b = stack.pop()\n        a = stack.pop()\n        if token == '+':\n            stack.append(a + b)\n        elif token == '-':\n            stack.append(a - b)\n        elif token == '*':\n            stack.append(a * b)\n        elif token == '/':\n            if b == 0:\n                raise ZeroDivisionError('\u9664\u4ee5\u96f6\u9519\u8bef')\n            stack.append(int(a / b))\n        else:\n            raise ValueError('\u672a\u77e5\u64cd\u4f5c\u7b26')\nif len(stack) != 1:\n    raise ValueError('\u975e\u6cd5\u8868\u8fbe\u5f0f')\nreturn stack[0]",
    "description": "evaluate_expression (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_detect_cycle_directed_221": {
    "name": "stack_detect_cycle_directed_221",
    "pattern_type": "general",
    "code_template": "in_degree = {node: 0 for node in $P0}\nfor node in $P0:\n    for neighbor in $P0[node]:\n        in_degree[neighbor] += 1\nqueue = [node for node in in_degree if in_degree[node] == 0]\ncount_of_visited_nodes = 0\nwhile queue:\n    node = queue.pop(0)\n    count_of_visited_nodes += 1\n    for neighbor in $P0[node]:\n        in_degree[neighbor] -= 1\n        if in_degree[neighbor] == 0:\n            queue.append(neighbor)\nreturn count_of_visited_nodes != len(in_degree)",
    "description": "detect_cycle_directed (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_max_cars_in_parking_lot_222": {
    "name": "stack_max_cars_in_parking_lot_222",
    "pattern_type": "general",
    "code_template": "$P0.sort()\n$P1.sort()\nentry_index = exit_index = 0\ncurrent_cars = 0\nmax_cars = 0\nwhile entry_index < len($P0) and exit_index < len($P1):\n    if $P0[entry_index] <= $P1[exit_index]:\n        current_cars += 1\n        entry_index += 1\n    else:\n        current_cars -= 1\n        exit_index += 1\n    max_cars = max(max_cars, current_cars)\nreturn max_cars",
    "description": "max_cars_in_parking_lot (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_coin_change_223": {
    "name": "stack_coin_change_223",
    "pattern_type": "general",
    "code_template": "dp = [$P1 + 1] * ($P1 + 1)\ndp[0] = 0\nfor coin in $P0:\n    for j in range(coin, $P1 + 1):\n        dp[j] = min(dp[j], dp[j - coin] + 1)\nreturn dp[$P1] if dp[$P1] != $P1 + 1 else -1",
    "description": "coin_change (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_summarize_word_frequency_224": {
    "name": "stack_summarize_word_frequency_224",
    "pattern_type": "general",
    "code_template": "logging.basicConfig(filename='file_read_errors.log', level=logging.ERROR)\nword_frequency = defaultdict(int)\ntry:\n    text_files = glob(os.path.join($P0, '*.txt'))\nexcept Exception as e:\n    logging.error(f'Error accessing files in $P0 {$P0}: {e}')\n    return None\nfor file_path in text_files:\n    try:\n        with open(file_path, 'r', encoding='utf-8') as file:\n            content = file.read()\n            words = re.findall(\"\\\\b[\\\\w']+\\\\b\", content.lower())\n            for word in words:\n                word_frequency[word] += 1\n    except Exception as e:\n        logging.error(f'Error reading file {file_path}: {e}')\noutput_file_path = os.path.join($P0, 'word_frequency.json')\ntry:\n    with open(output_file_path, 'w', encoding='utf-8') as outfile:\n        json.dump(word_frequency, outfile, indent=4)\nexcept Exception as e:\n    logging.error(f'Error writing to JSON file {output_file_path}: {e}')\n    return None\nreturn output_file_path",
    "description": "summarize_word_frequency (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_matrix_chain_multiplication_225": {
    "name": "stack_matrix_chain_multiplication_225",
    "pattern_type": "general",
    "code_template": "n = len($P0) - 1\nm = np.zeros((n, n), dtype=int)\nfor i in range(n):\n    m[i][i] = 0\nfor L in range(2, n + 1):\n    for i in range(n - L + 1):\n        j = i + L - 1\n        m[i][j] = float('inf')\n        for k in range(i, j):\n            q = m[i][k] + m[k + 1][j] + $P0[i] * $P0[k + 1] * $P0[j + 1]\n            if q < m[i][j]:\n                m[i][j] = q\nreturn m[0][n - 1]",
    "description": "matrix_chain_multiplication (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_increment_226": {
    "name": "stack_increment_226",
    "pattern_type": "general",
    "code_template": "global counter\nlock.acquire()\ntry:\n    for _ in range(1000000):\n        counter += 1\nfinally:\n    lock.release()",
    "description": "increment (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_access_resource_227": {
    "name": "stack_access_resource_227",
    "pattern_type": "general",
    "code_template": "print(f'Thread-{$P0} is waiting to access the resource')\nsemaphore.acquire()\ntry:\n    print(f'Thread-{$P0} has accessed the resource')\n    time.sleep(2)\nfinally:\n    semaphore.release()\n    print(f'Thread-{$P0} has released the resource')",
    "description": "access_resource (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_producer_228": {
    "name": "stack_producer_228",
    "pattern_type": "general",
    "code_template": "global data_ready\nwith condition:\n    print('Producing data...')\n    data_ready = True\n    condition.notify()",
    "description": "producer (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_consumer_229": {
    "name": "stack_consumer_229",
    "pattern_type": "general",
    "code_template": "with condition:\n    while not data_ready:\n        print('Waiting for data to be ready...')\n        condition.wait()\n    print('Consuming data...')",
    "description": "consumer (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_evaluate_postfix_expression_230": {
    "name": "stack_evaluate_postfix_expression_230",
    "pattern_type": "general",
    "code_template": "stack = []\ndef apply_operator(operand1, operand2, operator):\n    if operator == '+':\n        return operand1 + operand2\n    elif operator == '-':\n        return operand1 - operand2\n    elif operator == '*':\n        return operand1 * operand2\n    elif operator == '/':\n        if operand2 == 0:\n            raise ValueError('Division by zero is undefined.')\n        return operand1 / operand2\n    else:\n        raise ValueError(f'Unexpected operator: {operator}')\nfor token in $P0:\n    if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):\n        stack.append(float(token))\n    else:\n        operand2 = stack.pop()\n        operand1 = stack.pop()\n        result = apply_operator(operand1, operand2, token)\n        stack.append(result)\nreturn stack.pop()",
    "description": "evaluate_postfix_expression (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_apply_operator_231": {
    "name": "stack_apply_operator_231",
    "pattern_type": "general",
    "code_template": "if $P2 == '+':\n    return $P0 + $P1\nelif $P2 == '-':\n    return $P0 - $P1\nelif $P2 == '*':\n    return $P0 * $P1\nelif $P2 == '/':\n    if $P1 == 0:\n        raise ValueError('Division by zero is undefined.')\n    return $P0 / $P1\nelse:\n    raise ValueError(f'Unexpected $P2: {$P2}')",
    "description": "apply_operator (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_transform_and_count_232": {
    "name": "stack_transform_and_count_232",
    "pattern_type": "general",
    "code_template": "n = len($P0)\ncount = 0\nfor i in range(n):\n    for j in range(n):\n        if i != j:\n            transformed = $P0[:]\n            transformed[i] *= $P0[j]\n            if all((x > $P1 for x in transformed)):\n                count += 1\nreturn count",
    "description": "transform_and_count (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_quicksort_233": {
    "name": "stack_quicksort_233",
    "pattern_type": "algorithm",
    "code_template": "def _quicksort(items, low, high):\n    if low < high:\n        pivot_index = partition(items, low, high)\n        _quicksort(items, low, pivot_index - 1)\n        _quicksort(items, pivot_index + 1, high)\ndef partition(items, low, high):\n    pivot = items[high]\n    i = low - 1\n    for j in range(low, high):\n        if items[j] < pivot:\n            i += 1\n            (items[i], items[j]) = (items[j], items[i])\n    (items[i + 1], items[high]) = (items[high], items[i + 1])\n    return i + 1\n_quicksort($P0, 0, len($P0) - 1)\nreturn $P0",
    "description": "quicksort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_partition_234": {
    "name": "stack_partition_234",
    "pattern_type": "general",
    "code_template": "pivot = $P0[$P2]\ni = $P1 - 1\nfor j in range($P1, $P2):\n    if $P0[j] < pivot:\n        i += 1\n        ($P0[i], $P0[j]) = ($P0[j], $P0[i])\n($P0[i + 1], $P0[$P2]) = ($P0[$P2], $P0[i + 1])\nreturn i + 1",
    "description": "partition (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_process_data_live_235": {
    "name": "stack_process_data_live_235",
    "pattern_type": "general",
    "code_template": "processor = LiveDataProcessor()\ndef data_reception_thread():\n    for i in range(10):\n        processor.receive_data(i)\n        time.sleep(0.05)\nthreading.Thread(target=data_reception_thread).start()\nthreading.Thread(target=processor.process_data).start()",
    "description": "process_data_live (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_receive_data_236": {
    "name": "stack_receive_data_236",
    "pattern_type": "general",
    "code_template": "with $P0.data_condition:\n    $P0.data_queue.append($P1)\n    $P0.data_condition.notify()",
    "description": "receive_data (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_process_data_237": {
    "name": "stack_process_data_237",
    "pattern_type": "general",
    "code_template": "while True:\n    with $P0.data_condition:\n        while not $P0.data_queue:\n            $P0.data_condition.wait()\n        data = $P0.data_queue.popleft()\n    $P0.handle_data(data)",
    "description": "process_data (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_handle_data_238": {
    "name": "stack_handle_data_238",
    "pattern_type": "general",
    "code_template": "print(f'Processed $P1: {$P1}')\ntime.sleep(0.1)",
    "description": "handle_data (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_binary_search_first_occurrence_239": {
    "name": "stack_binary_search_first_occurrence_239",
    "pattern_type": "algorithm",
    "code_template": "(left, right) = (0, len($P0) - 1)\nresult = -1\nwhile left <= right:\n    mid = left + (right - left) // 2\n    if $P0[mid] == $P1:\n        result = mid\n        right = mid - 1\n    elif $P0[mid] < $P1:\n        left = mid + 1\n    else:\n        right = mid - 1\nreturn result",
    "description": "binary_search_first_occurrence (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_build_expression_tree_240": {
    "name": "stack_build_expression_tree_240",
    "pattern_type": "general",
    "code_template": "stack = []\nfor char in $P0:\n    if char in '0123456789':\n        stack.append(Node(char))\n    elif char in '+-*/':\n        node = Node(char)\n        node.right = stack.pop()\n        node.left = stack.pop()\n        stack.append(node)\nreturn stack.pop()",
    "description": "build_expression_tree (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_inorder_traversal_241": {
    "name": "stack_inorder_traversal_241",
    "pattern_type": "general",
    "code_template": "if $P0 is None:\n    return ''\nleft_expr = inorder_traversal($P0.left)\nright_expr = inorder_traversal($P0.right)\nreturn f'({left_expr}{$P0.value}{right_expr})'",
    "description": "inorder_traversal (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_evaluate_postorder_242": {
    "name": "stack_evaluate_postorder_242",
    "pattern_type": "general",
    "code_template": "if $P0.left is None and $P0.right is None:\n    return int($P0.value)\nleft_value = evaluate_postorder($P0.left)\nright_value = evaluate_postorder($P0.right)\nif $P0.value == '+':\n    return left_value + right_value\nelif $P0.value == '-':\n    return left_value - right_value\nelif $P0.value == '*':\n    return left_value * right_value\nelif $P0.value == '/':\n    return left_value / right_value",
    "description": "evaluate_postorder (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_evaluate_preorder_243": {
    "name": "stack_evaluate_preorder_243",
    "pattern_type": "general",
    "code_template": "if $P0 is None:\n    return ''\nif $P0.value in '+-*/':\n    operation = $P0.value\n    left_value = evaluate_preorder($P0.left)\n    right_value = evaluate_preorder($P0.right)\n    return eval(f'{left_value} {operation} {right_value}')\nelse:\n    return int($P0.value)",
    "description": "evaluate_preorder (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_max_subarray_sum_244": {
    "name": "stack_max_subarray_sum_244",
    "pattern_type": "list",
    "code_template": "max_so_far = float('-inf')\nmax_ending_here = 0\nfor num in $P0:\n    max_ending_here += num\n    if max_ending_here > max_so_far:\n        max_so_far = max_ending_here\n    if max_ending_here < 0:\n        max_ending_here = 0\nreturn max_so_far",
    "description": "max_subarray_sum (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_peak_element_245": {
    "name": "stack_find_peak_element_245",
    "pattern_type": "algorithm",
    "code_template": "def binary_search(low, high):\n    if low == high:\n        return low\n    mid = (low + high) // 2\n    if $P0[mid] < $P0[mid + 1]:\n        return binary_search(mid + 1, high)\n    else:\n        return binary_search(low, mid)\nreturn binary_search(0, len($P0) - 1)",
    "description": "find_peak_element (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_binary_search_246": {
    "name": "stack_binary_search_246",
    "pattern_type": "algorithm",
    "code_template": "if $P0 == $P1:\n    return $P0\nmid = ($P0 + $P1) // 2\nif nums[mid] < nums[mid + 1]:\n    return binary_search(mid + 1, $P1)\nelse:\n    return binary_search($P0, mid)",
    "description": "binary_search (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_bulk_insert_247": {
    "name": "stack_bulk_insert_247",
    "pattern_type": "general",
    "code_template": "for word in $P1:\n    $P0.insert(word)",
    "description": "bulk_insert (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_palindrome_248": {
    "name": "stack_is_palindrome_248",
    "pattern_type": "general",
    "code_template": "(left, right) = (0, len($P0) - 1)\nwhile left < right:\n    if $P0[left] != $P0[right]:\n        return False\n    left += 1\n    right -= 1\nreturn True",
    "description": "is_palindrome (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_reconstruct_path_249": {
    "name": "stack_reconstruct_path_249",
    "pattern_type": "string",
    "code_template": "def dfs(node, path):\n    if len(path) == $P1 and node == len($P0) - 1:\n        return path\n    if len(path) > $P1:\n        return None\n    for neighbor in $P0[node]:\n        new_path = path + [neighbor]\n        result = dfs(neighbor, new_path)\n        if result:\n            return result\n    return None\nresult = dfs(0, [0])\nreturn result if result else []",
    "description": "reconstruct_path (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_250": {
    "name": "stack_dfs_250",
    "pattern_type": "general",
    "code_template": "if len($P1) == k and $P0 == len(graph) - 1:\n    return $P1\nif len($P1) > k:\n    return None\nfor neighbor in graph[$P0]:\n    new_path = $P1 + [neighbor]\n    result = dfs(neighbor, new_path)\n    if result:\n        return result\nreturn None",
    "description": "dfs (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_update_251": {
    "name": "stack_update_251",
    "pattern_type": "general",
    "code_template": "ax.cla()\nx = dropdown_x.value_selected\ny = dropdown_y.value_selected\nscatter = ax.scatter(data[x], data[y], c=data['species'].astype('category').cat.codes, cmap='viridis')\nax.set_xlabel(x.replace('_', ' ').title())\nax.set_ylabel(y.replace('_', ' ').title())\nax.set_title(f\"Scatter Plot of {x.replace('_', ' ').title()} vs {y.replace('_', ' ').title()}\")\nplt.legend(*scatter.legend_elements(), title='Species')\nplt.draw()",
    "description": "update (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_set_252": {
    "name": "stack_set_252",
    "pattern_type": "general",
    "code_template": "index = $P0._hash_function($P1)\nbucket = $P0.table[index]\nfor (i, (k, v)) in enumerate(bucket):\n    if k == $P1:\n        bucket[i] = ($P1, $P2)\n        return\nbucket.append(($P1, $P2))",
    "description": "set (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_253": {
    "name": "stack_get_253",
    "pattern_type": "general",
    "code_template": "index = $P0._hash_function($P1)\nbucket = $P0.table[index]\nfor (k, v) in bucket:\n    if k == $P1:\n        return v\nreturn None",
    "description": "get (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_batteryTest_254": {
    "name": "stack_batteryTest_254",
    "pattern_type": "general",
    "code_template": "battery_level = 100\nfor (time, change) in $P0:\n    battery_level += change\n    if battery_level < $P1:\n        return False\nreturn True",
    "description": "batteryTest (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_enqueue_255": {
    "name": "stack_enqueue_255",
    "pattern_type": "general",
    "code_template": "$P0.stack1.append($P1)\nprint(f'Enqueued: {$P1}')",
    "description": "enqueue (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dequeue_256": {
    "name": "stack_dequeue_256",
    "pattern_type": "general",
    "code_template": "if not $P0.stack2:\n    while $P0.stack1:\n        popped_item = $P0.stack1.pop()\n        $P0.stack2.append(popped_item)\n        print(f'Moved {popped_item} from stack1 to stack2')\nif $P0.stack2:\n    dequeued_item = $P0.stack2.pop()\n    print(f'Dequeued: {dequeued_item}')\n    return dequeued_item\nelse:\n    print('Queue is empty!')\n    return None",
    "description": "dequeue (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_empty_257": {
    "name": "stack_is_empty_257",
    "pattern_type": "general",
    "code_template": "return len($P0.stack1) == 0 and len($P0.stack2) == 0",
    "description": "is_empty (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_longest_good_subarray_258": {
    "name": "stack_longest_good_subarray_258",
    "pattern_type": "list",
    "code_template": "from collections import defaultdict\nleft = 0\nmax_length = 0\nfreq_map = defaultdict(int)\nmax_freq = 0\nfor right in range(len($P0)):\n    freq_map[$P0[right]] += 1\n    max_freq = max(max_freq, freq_map[$P0[right]])\n    while max_freq < $P1:\n        freq_map[$P0[left]] -= 1\n        if freq_map[$P0[left]] == 0:\n            del freq_map[$P0[left]]\n        left += 1\n        max_freq = max(freq_map.values(), default=0)\n    max_length = max(max_length, right - left + 1)\nreturn max_length",
    "description": "longest_good_subarray (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_edit_distance_recursive_259": {
    "name": "stack_edit_distance_recursive_259",
    "pattern_type": "general",
    "code_template": "if $P2 == 0:\n    return $P3\nif $P3 == 0:\n    return $P2\nif $P0[$P2 - 1] == $P1[$P3 - 1]:\n    return edit_distance_recursive($P0, $P1, $P2 - 1, $P3 - 1)\nreturn 1 + min(edit_distance_recursive($P0, $P1, $P2, $P3 - 1), edit_distance_recursive($P0, $P1, $P2 - 1, $P3), edit_distance_recursive($P0, $P1, $P2 - 1, $P3 - 1))",
    "description": "edit_distance_recursive (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_edit_distance_iterative_260": {
    "name": "stack_edit_distance_iterative_260",
    "pattern_type": "general",
    "code_template": "(m, n) = (len($P0), len($P1))\ndp = [[0] * (n + 1) for _ in range(m + 1)]\nfor i in range(m + 1):\n    dp[i][0] = i\nfor j in range(n + 1):\n    dp[0][j] = j\nfor i in range(1, m + 1):\n    for j in range(1, n + 1):\n        if $P0[i - 1] == $P1[j - 1]:\n            dp[i][j] = dp[i - 1][j - 1]\n        else:\n            dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])\nreturn dp[m][n]",
    "description": "edit_distance_iterative (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_generate_large_prime_261": {
    "name": "stack_generate_large_prime_261",
    "pattern_type": "math",
    "code_template": "prime = random.randint(2 ** ($P0 - 1), 2 ** $P0 - 1)\nwhile not isprime(prime):\n    prime = random.randint(2 ** ($P0 - 1), 2 ** $P0 - 1)\nreturn prime",
    "description": "generate_large_prime (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_generate_keys_262": {
    "name": "stack_generate_keys_262",
    "pattern_type": "general",
    "code_template": "p = generate_large_prime($P0)\nq = generate_large_prime($P0)\nn = p * q\nphi = (p - 1) * (q - 1)\ne = 65537\nwhile phi % e == 0:\n    e = random.randint(2 ** ($P0 - 1), 2 ** $P0 - 1)\nd = mod_inverse(e, phi)\nreturn ((e, n), (d, n))",
    "description": "generate_keys (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_encrypt_263": {
    "name": "stack_encrypt_263",
    "pattern_type": "general",
    "code_template": "(e, n) = $P0\nciphertext = [pow(ord(char), e, n) for char in $P1]\nreturn ciphertext",
    "description": "encrypt (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_decrypt_264": {
    "name": "stack_decrypt_264",
    "pattern_type": "general",
    "code_template": "(d, n) = $P0\nplaintext = ''.join([chr(pow(char, d, n)) for char in $P1])\nreturn plaintext",
    "description": "decrypt (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_construct_peak_array_265": {
    "name": "stack_construct_peak_array_265",
    "pattern_type": "list",
    "code_template": "p = $P0 // 2\nheights = [0] * $P0\nheights[0] = $P1[0]\nfor i in range(1, p + 1):\n    heights[i] = max(heights[i - 1] + 1, $P1[i])\n    if heights[i] > $P2[i]:\n        heights[i] = $P2[i]\nheights[$P0 - 1] = $P1[$P0 - 1]\nfor i in range($P0 - 2, p - 1, -1):\n    heights[i] = max(heights[i + 1] + 1, $P1[i])\n    if heights[i] > $P2[i]:\n        heights[i] = $P2[i]\nfor i in range($P0 - 2, p - 1, -1):\n    if heights[i] >= heights[i + 1]:\n        heights[i] = heights[i + 1] - 1\n        if heights[i] < $P1[i]:\n            heights[i] = $P1[i]\ntotal_height = sum(heights)\nreturn (heights, total_height)",
    "description": "construct_peak_array (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_extract_conditional_substrings_266": {
    "name": "stack_extract_conditional_substrings_266",
    "pattern_type": "string",
    "code_template": "vowels = {'a', 'e', 'i', 'o', 'u'}\nresult = []\nfor start in range(len($P0)):\n    if $P0[start].lower() in vowels:\n        for end in range(start + 2, len($P0) + 1, 2):\n            substring = $P0[start:end]\n            result.append(substring)\nreturn result",
    "description": "extract_conditional_substrings (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_binary_search_267": {
    "name": "stack_binary_search_267",
    "pattern_type": "algorithm",
    "code_template": "if $P2:\n    return binary_search_iterative($P0, $P1)\nelse:\n    return binary_search_recursive($P0, $P1, 0, len($P0) - 1)",
    "description": "binary_search (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_binary_search_iterative_268": {
    "name": "stack_binary_search_iterative_268",
    "pattern_type": "algorithm",
    "code_template": "(left, right) = (0, len($P0) - 1)\nwhile left <= right:\n    mid = left + (right - left) // 2\n    if $P0[mid] == $P1:\n        return mid\n    elif $P0[mid] < $P1:\n        left = mid + 1\n    else:\n        right = mid - 1\nreturn -1",
    "description": "binary_search_iterative (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_binary_search_recursive_269": {
    "name": "stack_binary_search_recursive_269",
    "pattern_type": "algorithm",
    "code_template": "if $P2 > $P3:\n    return -1\nmid = $P2 + ($P3 - $P2) // 2\nif $P0[mid] == $P1:\n    return mid\nelif $P0[mid] < $P1:\n    return binary_search_recursive($P0, $P1, mid + 1, $P3)\nelse:\n    return binary_search_recursive($P0, $P1, $P2, mid - 1)",
    "description": "binary_search_recursive (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_ipc_using_pipes_270": {
    "name": "stack_ipc_using_pipes_270",
    "pattern_type": "general",
    "code_template": "(r, w) = os.pipe()\npid = os.fork()\nif pid > 0:\n    os.close(w)\n    r = os.fdopen(r)\n    print('Parent received:', r.read())\n    r.close()\nelse:\n    os.close(r)\n    w = os.fdopen(w, 'w')\n    w.write('Hello from child process')\n    w.close()",
    "description": "ipc_using_pipes (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_simulate_intrusion_detection_271": {
    "name": "stack_simulate_intrusion_detection_271",
    "pattern_type": "general",
    "code_template": "ip_data = {}\nfor request in $P0:\n    ip = request['ip']\n    path = request['path']\n    if ip not in ip_data:\n        ip_data[ip] = {'paths': set(), 'changes': 0}\n    if path not in ip_data[ip]['paths']:\n        ip_data[ip]['paths'].add(path)\n        ip_data[ip]['changes'] += 1\nresult = [ip for (ip, data) in ip_data.items() if data['changes'] > 3]\nreturn result",
    "description": "simulate_intrusion_detection (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_palindrome_recursive_272": {
    "name": "stack_is_palindrome_recursive_272",
    "pattern_type": "general",
    "code_template": "if len($P0) <= 1:\n    return True\nif $P0[0] != $P0[-1]:\n    return False\nreturn is_palindrome_recursive($P0[1:-1])",
    "description": "is_palindrome_recursive (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_enqueue_273": {
    "name": "stack_enqueue_273",
    "pattern_type": "general",
    "code_template": "if $P0.count == $P0.size:\n    raise OverflowError('Buffer is full')\n$P0.buffer[$P0.end] = $P1\n$P0.end = ($P0.end + 1) % $P0.size\n$P0.count += 1",
    "description": "enqueue (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dequeue_274": {
    "name": "stack_dequeue_274",
    "pattern_type": "general",
    "code_template": "if $P0.count == 0:\n    raise ValueError('Buffer is empty')\nitem = $P0.buffer[$P0.start]\n$P0.start = ($P0.start + 1) % $P0.size\n$P0.count -= 1\nreturn item",
    "description": "dequeue (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_empty_275": {
    "name": "stack_is_empty_275",
    "pattern_type": "general",
    "code_template": "return $P0.count == 0",
    "description": "is_empty (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_full_276": {
    "name": "stack_is_full_276",
    "pattern_type": "general",
    "code_template": "return $P0.count == $P0.size",
    "description": "is_full (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dijkstra_277": {
    "name": "stack_dijkstra_277",
    "pattern_type": "string",
    "code_template": "n = len($P0)\ndistances = [float('inf')] * n\ndistances[$P1] = 0\npriority_queue = [(0, $P1)]\nwhile priority_queue:\n    (current_distance, current_node) = heapq.heappop(priority_queue)\n    for (neighbor, weight) in enumerate($P0[current_node]):\n        if weight == 0:\n            continue\n        distance = current_distance + weight\n        if distance < distances[neighbor]:\n            distances[neighbor] = distance\n            heapq.heappush(priority_queue, (distance, neighbor))\nreturn distances",
    "description": "dijkstra (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_selection_sort_278": {
    "name": "stack_selection_sort_278",
    "pattern_type": "algorithm",
    "code_template": "for i in range(len($P0)):\n    min_index = i\n    for j in range(i + 1, len($P0)):\n        if $P0[j] < $P0[min_index]:\n            min_index = j\n    ($P0[i], $P0[min_index]) = ($P0[min_index], $P0[i])\nreturn $P0",
    "description": "selection_sort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_heapify_279": {
    "name": "stack_heapify_279",
    "pattern_type": "general",
    "code_template": "largest = $P2\nleft = 2 * $P2 + 1\nright = 2 * $P2 + 2\nif left < $P1 and $P0[left] > $P0[largest]:\n    largest = left\nif right < $P1 and $P0[right] > $P0[largest]:\n    largest = right\nif largest != $P2:\n    ($P0[$P2], $P0[largest]) = ($P0[largest], $P0[$P2])\n    heapify($P0, $P1, largest)",
    "description": "heapify (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_heap_sort_280": {
    "name": "stack_heap_sort_280",
    "pattern_type": "algorithm",
    "code_template": "n = len($P0)\nfor i in range(n // 2 - 1, -1, -1):\n    heapify($P0, n, i)\nfor i in range(n - 1, 0, -1):\n    ($P0[i], $P0[0]) = ($P0[0], $P0[i])\n    heapify($P0, i, 0)\nreturn $P0",
    "description": "heap_sort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_edge_281": {
    "name": "stack_add_edge_281",
    "pattern_type": "general",
    "code_template": "$P0.adj_list[$P1].append($P2)\n$P0.adj_list[$P2].append($P1)",
    "description": "add_edge (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_util_282": {
    "name": "stack_dfs_util_282",
    "pattern_type": "general",
    "code_template": "$P2.add($P1)\n$P3.append($P1)\nfor neighbour in $P0.adj_list[$P1]:\n    if neighbour not in $P2:\n        $P0.dfs_util(neighbour, $P2, $P3)",
    "description": "dfs_util (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_283": {
    "name": "stack_dfs_283",
    "pattern_type": "general",
    "code_template": "visited = set()\ntraversal = []\n$P0.dfs_util($P1, visited, traversal)\nfor vertex in $P0.adj_list:\n    if vertex not in visited:\n        $P0.dfs_util(vertex, visited, traversal)\nreturn traversal",
    "description": "dfs (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_bfs_284": {
    "name": "stack_bfs_284",
    "pattern_type": "general",
    "code_template": "visited = set()\nqueue = deque([$P1])\ntraversal = []\nvisited.add($P1)\nwhile queue:\n    vertex = queue.popleft()\n    traversal.append(vertex)\n    for neighbour in $P0.adj_list[vertex]:\n        if neighbour not in visited:\n            queue.append(neighbour)\n            visited.add(neighbour)\nfor vertex in $P0.adj_list:\n    if vertex not in visited:\n        queue.append(vertex)\n        visited.add(vertex)\n        while queue:\n            vertex = queue.popleft()\n            traversal.append(vertex)\n            for neighbour in $P0.adj_list[vertex]:\n                if neighbour not in visited:\n                    queue.append(neighbour)\n                    visited.add(neighbour)\nreturn traversal",
    "description": "bfs (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_max_sum_of_minimums_285": {
    "name": "stack_max_sum_of_minimums_285",
    "pattern_type": "general",
    "code_template": "def dfs(node):\n    if not node:\n        return [0] * ($P1 + 1)\n    dp = [-float('inf')] * ($P1 + 1)\n    dp[1] = node.value\n    left_dp = dfs(node.left)\n    right_dp = dfs(node.right)\n    for l in range($P1 + 1):\n        for r in range($P1 + 1 - l):\n            if l + r + 1 <= $P1:\n                dp[l + r + 1] = max(dp[l + r + 1], left_dp[l] + right_dp[r] + node.value)\n    return dp\nresult = dfs($P0)\nreturn result[$P1]",
    "description": "max_sum_of_minimums (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_286": {
    "name": "stack_dfs_286",
    "pattern_type": "general",
    "code_template": "if not $P0:\n    return [0] * (k + 1)\ndp = [-float('inf')] * (k + 1)\ndp[1] = $P0.value\nleft_dp = dfs($P0.left)\nright_dp = dfs($P0.right)\nfor l in range(k + 1):\n    for r in range(k + 1 - l):\n        if l + r + 1 <= k:\n            dp[l + r + 1] = max(dp[l + r + 1], left_dp[l] + right_dp[r] + $P0.value)\nreturn dp",
    "description": "dfs (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_on_created_287": {
    "name": "stack_on_created_287",
    "pattern_type": "general",
    "code_template": "if $P1.is_directory:\n    return\nasyncio.run_coroutine_threadsafe(read_and_print_file($P1.src_path), $P0.loop)",
    "description": "on_created (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_flatten_structure_288": {
    "name": "stack_flatten_structure_288",
    "pattern_type": "string",
    "code_template": "items = []\nif isinstance($P0, dict):\n    for (key, value) in $P0.items():\n        new_key = f'{$P1}{$P2}{key}' if $P1 else key\n        items.extend(flatten_structure(value, new_key, $P2).items())\nelif isinstance($P0, list):\n    for (index, value) in enumerate($P0):\n        new_key = f'{$P1}{$P2}{index}' if $P1 else str(index)\n        items.extend(flatten_structure(value, new_key, $P2).items())\nelse:\n    items.append(($P1, $P0))\nreturn dict(items)",
    "description": "flatten_structure (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_knights_moves_chinese_289": {
    "name": "stack_knights_moves_chinese_289",
    "pattern_type": "general",
    "code_template": "knight_moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]\n(board_width, board_height) = (9, 10)\nvisited_positions = set()\nqueue = [($P0, 0)]\nwhile queue:\n    (position, move_count) = queue.pop(0)\n    if move_count == $P1:\n        visited_positions.add(position)\n        continue\n    for (dx, dy) in knight_moves:\n        new_x = position[0] + dx\n        new_y = position[1] + dy\n        if 0 <= new_x < board_width and 0 <= new_y < board_height:\n            queue.append(((new_x, new_y), move_count + 1))\nreturn visited_positions",
    "description": "knights_moves_chinese (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_pascal_triangle_row_290": {
    "name": "stack_pascal_triangle_row_290",
    "pattern_type": "general",
    "code_template": "row = [1]\nfor _ in range($P0):\n    row = [x + y for (x, y) in zip([0] + row, row + [0])]\nreturn row",
    "description": "pascal_triangle_row (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_factorial_291": {
    "name": "stack_factorial_291",
    "pattern_type": "math",
    "code_template": "fact = [1] * ($P0 + 1)\nfor i in range(2, $P0 + 1):\n    fact[i] = fact[i - 1] * i % MOD\nreturn fact",
    "description": "factorial (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_mod_inverse_292": {
    "name": "stack_mod_inverse_292",
    "pattern_type": "general",
    "code_template": "return pow($P0, $P1 - 2, $P1)",
    "description": "mod_inverse (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_count_arrangements_293": {
    "name": "stack_count_arrangements_293",
    "pattern_type": "general",
    "code_template": "n = sum($P1)\nmax_count = max($P1)\nif max_count > (n + 1) // 2:\n    return 0\nfact = factorial(n)\ninv_fact = [mod_inverse(fact[i], MOD) for i in range(n + 1)]\ndp = [0] * (n + 1)\ndp[0] = 1\nfor c in $P1:\n    for j in range(n, c - 1, -1):\n        dp[j] = dp[j] * fact[j] % MOD * inv_fact[c] % MOD * inv_fact[j - c] % MOD\nreturn dp[n]",
    "description": "count_arrangements (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_compute_probability_294": {
    "name": "stack_compute_probability_294",
    "pattern_type": "general",
    "code_template": "dp = [[0] * ($P0 + 1) for _ in range($P0 + 1)]\ndp[0][0] = 1.0\nfor i in range(1, $P0 + 1):\n    for j in range(0, i + 1):\n        dp[i][j] = dp[i - 1][j] * 0.5 + (dp[i - 1][j - 1] * 0.5 if j > 0 else 0)\nresult = 0.0\nfor k in range($P1 - $P2, $P1 + $P2 + 1):\n    if 0 <= k <= $P0:\n        result += dp[$P0][k]\nreturn round(result, 4)",
    "description": "compute_probability (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_search_tree_helper_295": {
    "name": "stack_search_tree_helper_295",
    "pattern_type": "algorithm",
    "code_template": "if $P1 == $P0.TNULL or $P2 == $P1.data:\n    return $P1\nif $P2 < $P1.data:\n    return $P0.search_tree_helper($P1.left, $P2)\nreturn $P0.search_tree_helper($P1.right, $P2)",
    "description": "search_tree_helper (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_fix_insert_296": {
    "name": "stack_fix_insert_296",
    "pattern_type": "general",
    "code_template": "while $P1.parent.color == 'red':\n    if $P1.parent == $P1.parent.parent.right:\n        u = $P1.parent.parent.left\n        if u.color == 'red':\n            u.color = 'black'\n            $P1.parent.color = 'black'\n            $P1.parent.parent.color = 'red'\n            $P1 = $P1.parent.parent\n        else:\n            if $P1 == $P1.parent.left:\n                $P1 = $P1.parent\n                $P0.right_rotate($P1)\n            $P1.parent.color = 'black'\n            $P1.parent.parent.color = 'red'\n            $P0.left_rotate($P1.parent.parent)\n    else:\n        u = $P1.parent.parent.right\n        if u.color == 'red':\n            u.color = 'black'\n            $P1.parent.color = 'black'\n            $P1.parent.parent.color = 'red'\n            $P1 = $P1.parent.parent\n        else:\n            if $P1 == $P1.parent.right:\n                $P1 = $P1.parent\n                $P0.left_rotate($P1)\n            $P1.parent.color = 'black'\n            $P1.parent.parent.color = 'red'\n            $P0.right_rotate($P1.parent.parent)\n    if $P1 == $P0.root:\n        break\n$P0.root.color = 'black'",
    "description": "fix_insert (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "self___init__": {
    "name": "__init__",
    "pattern_type": "general",
    "code_template": "$P0.$P1 = $P1\n$P0.rules: Dict[str, Rule] = {}\n$P0.inducer = RuleInducer()\n$P0.load()",
    "description": "__init__ (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "self_fact": {
    "name": "fact",
    "pattern_type": "general",
    "code_template": "if $P0 <= 1:\n    return 1\nr = 1\nfor i in range(2, $P0 + 1):\n    r *= i\nreturn r",
    "description": "fact (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "self_fib": {
    "name": "fib",
    "pattern_type": "general",
    "code_template": "if $P0 <= 1:\n    return $P0\n(a, b) = (0, 1)\nfor _ in range(2, $P0 + 1):\n    (a, b) = (b, a + b)\nreturn b",
    "description": "fib (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "self_is_prime": {
    "name": "is_prime",
    "pattern_type": "math",
    "code_template": "if $P0 < 2:\n    return False\nfor i in range(2, int($P0 ** 0.5) + 1):\n    if $P0 % i == 0:\n        return False\nreturn True",
    "description": "is_prime (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "local___init___0": {
    "name": "__init__",
    "pattern_type": "general",
    "code_template": "$P0.$P1 = $P1\n$P0.mu_target = None\n$P0.spec = None",
    "description": "__init__ (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "local___init___1": {
    "name": "__init__",
    "pattern_type": "general",
    "code_template": "$P0.spec = $P1\n$P0.n_dims = $P1.n_dims\n$P0.mu = np.random.randn($P0.n_dims) * 0.1\n$P0.mu_prev = $P0.mu.copy()\n$P0.dt = 0.05\n$P0.precision_obs = 5.0\n$P0.precision_prior = 0.1\n$P0.momentum = 0.4\n$P0.F_history = []\n$P0.distance_history = []",
    "description": "__init__ (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "local___init___2": {
    "name": "__init__",
    "pattern_type": "general",
    "code_template": "$P0.components: Dict[str, Component] = {}\n$P0._build_standard_library()",
    "description": "__init__ (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "local___init___3": {
    "name": "__init__",
    "pattern_type": "general",
    "code_template": "$P0.$P1 = $P1\n$P0.n_levels = len($P1)\n$P0.mu = [np.zeros(d, dtype=np.float32) for d in $P1]\n$P0.library = ComponentLibrary()",
    "description": "__init__ (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "local___init___4": {
    "name": "__init__",
    "pattern_type": "general",
    "code_template": "$P0.node_counts = {}\n$P0.max_depth = 0\n$P0.current_depth = 0\n$P0.total_nodes = 0\n$P0.function_defs = []\n$P0.class_defs = []\n$P0.num_loops = 0\n$P0.num_conditionals = 0\n$P0.num_returns = 0\n$P0.cyclomatic_complexity = 1\n$P0.nesting_depth = 0",
    "description": "__init__ (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "local_visit_5": {
    "name": "visit",
    "pattern_type": "general",
    "code_template": "$P0.current_depth += 1\n$P0.max_depth = max($P0.max_depth, $P0.current_depth)\n$P0.total_nodes += 1\nnode_type = $P1.__class__.__name__\n$P0.node_counts[node_type] = $P0.node_counts.get(node_type, 0) + 1\nif isinstance($P1, ast.FunctionDef):\n    $P0.function_defs.append($P1.name)\nelif isinstance($P1, ast.ClassDef):\n    $P0.class_defs.append($P1.name)\nelif isinstance($P1, (ast.For, ast.While)):\n    $P0.num_loops += 1\n    $P0.cyclomatic_complexity += 1\nelif isinstance($P1, ast.If):\n    $P0.num_conditionals += 1\n    $P0.cyclomatic_complexity += 1\nelif isinstance($P1, ast.Return):\n    $P0.num_returns += 1\n$P0.generic_visit($P1)\n$P0.current_depth -= 1",
    "description": "visit (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "local___init___6": {
    "name": "__init__",
    "pattern_type": "general",
    "code_template": "$P0.project_root = Path(__file__).parent\n$P0.components = $P0._discover_components()",
    "description": "__init__ (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "local___init___7": {
    "name": "__init__",
    "pattern_type": "general",
    "code_template": "$P0.analyzer = SelfAnalysisSystem()\n$P0.modifier = ComponentModifier()\n$P0.verifier = ImprovementVerifier()\n$P0.swapper = SafeSwapper()",
    "description": "__init__ (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "local___init___8": {
    "name": "__init__",
    "pattern_type": "general",
    "code_template": "$P0.modification_system = SelfModificationSystem()\n$P0.iteration_history: List[IterationResult] = []\n$P0.convergence_threshold = 0.01",
    "description": "__init__ (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "local___init___9": {
    "name": "__init__",
    "pattern_type": "general",
    "code_template": "$P0.$P1 = $P1\n$P0.$P2 = $P2 or ['__init__.py', 'setup.py']",
    "description": "__init__ (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "local___init___10": {
    "name": "__init__",
    "pattern_type": "general",
    "code_template": "$P0.$P1 = $P1\n$P0.$P2 = $P2\n$P0.backups = []",
    "description": "__init__ (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "local___init___11": {
    "name": "__init__",
    "pattern_type": "general",
    "code_template": "$P0.test_patterns = ['.*test.*', '.*_test$', '^test_.*']\n$P0.doc_patterns = ['.*\\\\.md$', '.*readme.*', '.*doc.*', '.*guide.*']\n$P0.entry_patterns = ['.*__main__.*', '.*main\\\\.py$', '.*run\\\\.py$', '.*start\\\\.py$']\n$P0.utility_patterns = ['.*util.*', '.*helper.*', '.*tool.*', '.*common.*']\n$P0.config_patterns = ['.*config.*', '.*settings.*', '.*__init__.*', '.*setup.*']",
    "description": "__init__ (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "local___init___12": {
    "name": "__init__",
    "pattern_type": "general",
    "code_template": "$P0.$P1 = $P1\n$P0.patterns: Dict[str, LearnedPattern] = {}\n$P0.load()",
    "description": "__init__ (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_conflict_297": {
    "name": "stack_is_conflict_297",
    "pattern_type": "general",
    "code_template": "for resource in $P0.required_resources:\n    if $P3.get(($P1, resource), 0) < $P0.required_resources[resource]:\n        return True\nreturn False",
    "description": "is_conflict (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_backtrack_298": {
    "name": "stack_backtrack_298",
    "pattern_type": "general",
    "code_template": "if $P4 == len($P1):\n    return True\ntask = $P1[$P4]\nfor time_slot in $P2:\n    if not is_conflict(task, time_slot, $P0, $P3):\n        $P0[task.task_id] = time_slot\n        for resource in task.required_resources:\n            $P3[time_slot, resource] -= task.required_resources[resource]\n        if backtrack($P0, $P1, $P2, $P3, $P4 + 1):\n            return True\n        del $P0[task.task_id]\n        for resource in task.required_resources:\n            $P3[time_slot, resource] += task.required_resources[resource]\nreturn False",
    "description": "backtrack (5 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_solve_scheduling_problem_299": {
    "name": "stack_solve_scheduling_problem_299",
    "pattern_type": "general",
    "code_template": "schedule = {}\n$P0.sort(key=lambda x: len(x.required_resources))\nif backtrack(schedule, $P0, $P1, $P2):\n    return schedule\nelse:\n    return None",
    "description": "solve_scheduling_problem (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_count_unique_intervals_300": {
    "name": "stack_count_unique_intervals_300",
    "pattern_type": "general",
    "code_template": "even_count = 1\nodd_count = 0\ncurrent_prefix_sum = 0\nfor k in range(1, $P0 + 1):\n    current_prefix_sum += k\n    if current_prefix_sum % 2 == 0:\n        even_count += 1\n    else:\n        odd_count += 1\neven_intervals = even_count * (even_count - 1) // 2\nodd_intervals = odd_count * (odd_count - 1) // 2\nreturn even_intervals + odd_intervals",
    "description": "count_unique_intervals (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_generate_new_names_301": {
    "name": "stack_generate_new_names_301",
    "pattern_type": "general",
    "code_template": "def generate_variations(name):\n    variations = set()\n    for i in range(len(name) + 1):\n        for c in 'abcdefghijklmnopqrstuvwxyz':\n            new_name = name[:i] + c + name[i:]\n            variations.add(new_name)\n    for i in range(len(name)):\n        for c in 'abcdefghijklmnopqrstuvwxyz':\n            if name[i] != c:\n                new_name = name[:i] + c + name[i + 1:]\n                variations.add(new_name)\n    return variations\nlongest_names = []\nmax_total_length = 0\nfor name in $P0:\n    variations = generate_variations(name)\n    sorted_variations = sorted(variations, key=len, reverse=True)\n    if len(sorted_variations) >= 2:\n        candidate_names = sorted_variations[:2]\n        candidate_length = len(candidate_names[0]) + len(candidate_names[1])\n        if candidate_length > max_total_length:\n            longest_names = candidate_names\n            max_total_length = candidate_length\nreturn (longest_names, max_total_length)",
    "description": "generate_new_names (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_generate_variations_302": {
    "name": "stack_generate_variations_302",
    "pattern_type": "general",
    "code_template": "variations = set()\nfor i in range(len($P0) + 1):\n    for c in 'abcdefghijklmnopqrstuvwxyz':\n        new_name = $P0[:i] + c + $P0[i:]\n        variations.add(new_name)\nfor i in range(len($P0)):\n    for c in 'abcdefghijklmnopqrstuvwxyz':\n        if $P0[i] != c:\n            new_name = $P0[:i] + c + $P0[i + 1:]\n            variations.add(new_name)\nreturn variations",
    "description": "generate_variations (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_solve_maze_303": {
    "name": "stack_solve_maze_303",
    "pattern_type": "general",
    "code_template": "def find_points($P0):\n    (start, end) = (None, None)\n    for (i, row) in enumerate($P0):\n        for (j, value) in enumerate(row):\n            if value == 'S':\n                start = (i, j)\n            elif value == 'E':\n                end = (i, j)\n    return (start, end)\ndef dfs(current, path):\n    (x, y) = current\n    if current == end:\n        return path\n    visited.add(current)\n    for (dx, dy) in directions:\n        (nx, ny) = (x + dx, y + dy)\n        if 0 <= nx < len($P0) and 0 <= ny < len($P0[0]) and ($P0[nx][ny] != 'X') and ((nx, ny) not in visited):\n            result = dfs((nx, ny), path + [(nx, ny)])\n            if result:\n                return result\n    visited.remove(current)\n    return None\n(start, end) = find_points($P0)\nif not start or not end:\n    return None\ndirections = [(-1, 0), (1, 0), (0, -1), (0, 1)]\nvisited = set()\npath = dfs(start, [start])\nreturn path",
    "description": "solve_maze (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_points_304": {
    "name": "stack_find_points_304",
    "pattern_type": "algorithm",
    "code_template": "(start, end) = (None, None)\nfor (i, row) in enumerate($P0):\n    for (j, value) in enumerate(row):\n        if value == 'S':\n            start = (i, j)\n        elif value == 'E':\n            end = (i, j)\nreturn (start, end)",
    "description": "find_points (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_305": {
    "name": "stack_dfs_305",
    "pattern_type": "general",
    "code_template": "(x, y) = $P0\nif $P0 == end:\n    return $P1\nvisited.add($P0)\nfor (dx, dy) in directions:\n    (nx, ny) = (x + dx, y + dy)\n    if 0 <= nx < len(maze) and 0 <= ny < len(maze[0]) and (maze[nx][ny] != 'X') and ((nx, ny) not in visited):\n        result = dfs((nx, ny), $P1 + [(nx, ny)])\n        if result:\n            return result\nvisited.remove($P0)\nreturn None",
    "description": "dfs (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_filter_strings_by_character_306": {
    "name": "stack_filter_strings_by_character_306",
    "pattern_type": "list",
    "code_template": "filtered_strings = []\nfor string in $P0:\n    if $P1 in string:\n        filtered_strings.append(string)\nif not filtered_strings:\n    return 'No $P0 contain the $P1.'\nreturn filtered_strings",
    "description": "filter_strings_by_character (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_heuristic_307": {
    "name": "stack_heuristic_307",
    "pattern_type": "general",
    "code_template": "return abs($P0[0] - $P1[0]) + abs($P0[1] - $P1[1])",
    "description": "heuristic (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_a_star_search_308": {
    "name": "stack_a_star_search_308",
    "pattern_type": "algorithm",
    "code_template": "(rows, cols) = (len($P0), len($P0[0]))\nopen_set = []\nheapq.heappush(open_set, (0, $P1))\ncame_from = {}\ng_score = {$P1: 0}\nf_score = {$P1: heuristic($P1, $P2)}\nwhile open_set:\n    current = heapq.heappop(open_set)[1]\n    if current == $P2:\n        path = []\n        while current in came_from:\n            path.append(current)\n            current = came_from[current]\n        path.append($P1)\n        path.reverse()\n        return path\n    for direction in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n        neighbor = (current[0] + direction[0], current[1] + direction[1])\n        if 0 <= neighbor[0] < rows and 0 <= neighbor[1] < cols and ($P0[neighbor[0]][neighbor[1]] == 0):\n            tentative_g_score = g_score[current] + 1\n            if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + heuristic(neighbor, $P2)\n                if neighbor not in [i[1] for i in open_set]:\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\nreturn None",
    "description": "a_star_search (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_min_operations_to_equalize_309": {
    "name": "stack_min_operations_to_equalize_309",
    "pattern_type": "general",
    "code_template": "$P0.sort()\nn = len($P0)\nmedian = $P0[n // 2] if n % 2 == 1 else $P0[n // 2 - 1]\noperations = sum((abs(num - median) for num in $P0))\nreturn (operations, [median] * n)",
    "description": "min_operations_to_equalize (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_producer_310": {
    "name": "stack_producer_310",
    "pattern_type": "general",
    "code_template": "for i in range(10):\n    item = f'item-{$P1}-{i}'\n    $P0.put(item)\n    print(f'Producer {$P1} produced {item}')\n    time.sleep(random.uniform(0.1, 0.5))",
    "description": "producer (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_consumer_311": {
    "name": "stack_consumer_311",
    "pattern_type": "general",
    "code_template": "for i in range(10):\n    item = $P0.get()\n    print(f'Consumer {$P1} consumed {item}')\n    time.sleep(random.uniform(0.1, 0.5))",
    "description": "consumer (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_put_312": {
    "name": "stack_put_312",
    "pattern_type": "general",
    "code_template": "with $P0.condition:\n    while $P0.count == $P0.max_size:\n        $P0.condition.wait()\n    $P0.buffer[$P0.tail] = $P1\n    $P0.tail = ($P0.tail + 1) % $P0.max_size\n    $P0.count += 1\n    $P0.condition.notify()",
    "description": "put (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_313": {
    "name": "stack_get_313",
    "pattern_type": "general",
    "code_template": "with $P0.condition:\n    while $P0.count == 0:\n        $P0.condition.wait()\n    item = $P0.buffer[$P0.head]\n    $P0.head = ($P0.head + 1) % $P0.max_size\n    $P0.count -= 1\n    $P0.condition.notify()\n    return item",
    "description": "get (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_longest_common_subsequence_314": {
    "name": "stack_longest_common_subsequence_314",
    "pattern_type": "general",
    "code_template": "m = len($P0)\nn = len($P1)\ndp = [[0] * (n + 1) for _ in range(m + 1)]\nfor i in range(1, m + 1):\n    for j in range(1, n + 1):\n        if $P0[i - 1] == $P1[j - 1]:\n            dp[i][j] = dp[i - 1][j - 1] + 1\n        else:\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\nindex = dp[m][n]\nlcs = [''] * index\n(i, j) = (m, n)\nwhile i > 0 and j > 0:\n    if $P0[i - 1] == $P1[j - 1]:\n        lcs[index - 1] = $P0[i - 1]\n        i -= 1\n        j -= 1\n        index -= 1\n    elif dp[i - 1][j] > dp[i][j - 1]:\n        i -= 1\n    else:\n        j -= 1\nreturn (dp[m][n], ''.join(lcs))",
    "description": "longest_common_subsequence (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_maximum_xor_315": {
    "name": "stack_find_maximum_xor_315",
    "pattern_type": "algorithm",
    "code_template": "trie = Trie()\nmax_xor = 0\nfor num in $P0:\n    trie.insert(num)\nfor num in $P0:\n    max_xor = max(max_xor, trie.find_max_xor(num))\nreturn max_xor",
    "description": "find_maximum_xor (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_insert_316": {
    "name": "stack_insert_316",
    "pattern_type": "general",
    "code_template": "node = $P0.root\nfor i in range(31, -1, -1):\n    bit = $P1 >> i & 1\n    if bit not in node.children:\n        node.children[bit] = TrieNode()\n    node = node.children[bit]",
    "description": "insert (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_max_xor_317": {
    "name": "stack_find_max_xor_317",
    "pattern_type": "algorithm",
    "code_template": "node = $P0.root\nmax_xor = 0\nfor i in range(31, -1, -1):\n    bit = $P1 >> i & 1\n    toggled_bit = 1 - bit\n    if toggled_bit in node.children:\n        max_xor = max_xor << 1 | 1\n        node = node.children[toggled_bit]\n    else:\n        max_xor = max_xor << 1\n        node = node.children[bit]\nreturn max_xor",
    "description": "find_max_xor (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_largest_increasing_area_318": {
    "name": "stack_largest_increasing_area_318",
    "pattern_type": "general",
    "code_template": "if not $P0 or not $P0[0]:\n    return 0\n(rows, cols) = (len($P0), len($P0[0]))\nmemo = [[-1] * cols for _ in range(rows)]\ndef dfs(x, y):\n    if memo[x][y] != -1:\n        return memo[x][y]\n    max_area = 1\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    for (dx, dy) in directions:\n        (nx, ny) = (x + dx, y + dy)\n        if 0 <= nx < rows and 0 <= ny < cols and ($P0[nx][ny] > $P0[x][y]):\n            max_area = max(max_area, 1 + dfs(nx, ny))\n    memo[x][y] = max_area\n    return max_area\nlargest_area = 0\nfor i in range(rows):\n    for j in range(cols):\n        largest_area = max(largest_area, dfs(i, j))\nreturn largest_area",
    "description": "largest_increasing_area (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_319": {
    "name": "stack_dfs_319",
    "pattern_type": "general",
    "code_template": "if memo[$P0][$P1] != -1:\n    return memo[$P0][$P1]\nmax_area = 1\ndirections = [(-1, 0), (1, 0), (0, -1), (0, 1)]\nfor (dx, dy) in directions:\n    (nx, ny) = ($P0 + dx, $P1 + dy)\n    if 0 <= nx < rows and 0 <= ny < cols and (grid[nx][ny] > grid[$P0][$P1]):\n        max_area = max(max_area, 1 + dfs(nx, ny))\nmemo[$P0][$P1] = max_area\nreturn max_area",
    "description": "dfs (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_recursive_dfs_320": {
    "name": "stack_recursive_dfs_320",
    "pattern_type": "general",
    "code_template": "if $P2 is None:\n    $P2 = set()\nif $P3 is None:\n    $P3 = []\ntry:\n    if $P1 not in $P2:\n        $P2.add($P1)\n        $P3.append($P1)\n        for neighbor in $P0[$P1]:\n            recursive_dfs($P0, neighbor, $P2, $P3)\nexcept RecursionError:\n    print('\u9012\u5f52\u6df1\u5ea6\u8d85\u8fc7\u9650\u5236\uff0c\u8bf7\u4fee\u6539\u914d\u7f6e\u6216\u4f18\u5316\u7b97\u6cd5\u3002')\nreturn $P3",
    "description": "recursive_dfs (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_separate_waste_321": {
    "name": "stack_separate_waste_321",
    "pattern_type": "general",
    "code_template": "separated_waste = {'recyclables': [], 'compostables': [], 'landfill': []}\nfor item in $P0:\n    for (category, materials) in waste_types.items():\n        if item in materials:\n            separated_waste[category].append(item)\n            break\nreturn separated_waste",
    "description": "separate_waste (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_optimize_routes_322": {
    "name": "stack_optimize_routes_322",
    "pattern_type": "general",
    "code_template": "(rows, cols) = (len($P0), len($P0[0]))\ndirections = [(0, 1), (1, 0), (0, -1), (-1, 0)]\nstart = (0, 0)\nqueue = deque([(start, 0)])\nvisited = set()\nroutes = []\nwhile queue:\n    ((x, y), dist) = queue.popleft()\n    if (x, y) in visited:\n        continue\n    visited.add((x, y))\n    routes.append(((x, y), dist))\n    for (dx, dy) in directions:\n        (nx, ny) = (x + dx, y + dy)\n        if 0 <= nx < rows and 0 <= ny < cols and ((nx, ny) not in visited):\n            queue.append(((nx, ny), dist + 1))\nreturn routes",
    "description": "optimize_routes (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_composting_schedule_323": {
    "name": "stack_composting_schedule_323",
    "pattern_type": "general",
    "code_template": "composting_log = {'compost_heaps': [], 'monitoring_schedule': [], 'improvement_tips': ['Turn compost regularly to aerate.', 'Maintain moisture levels.', 'Balance green and brown materials.']}\ncomposting_log['compost_heaps'].append('Heap 1: Start Date - Day 1')\ncomposting_log['monitoring_schedule'].append('Check Heap 1: Every 3 days')\nreturn composting_log",
    "description": "composting_schedule (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_identifySlowestCar_324": {
    "name": "stack_identifySlowestCar_324",
    "pattern_type": "general",
    "code_template": "destination = 1000\nn = len($P0)\nslowest_cars = []\nmax_time = float('-inf')\nfor i in range(n - 1, -1, -1):\n    time_to_reach = (destination - $P0[i]) / $P1[i]\n    if time_to_reach > max_time:\n        max_time = time_to_reach\n        slowest_cars.append(i)\nreturn slowest_cars[::-1]",
    "description": "identifySlowestCar (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_book_325": {
    "name": "stack_add_book_325",
    "pattern_type": "general",
    "code_template": "$P0.books[$P1] = Book($P1, $P2)",
    "description": "add_book (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_classify_image_326": {
    "name": "stack_classify_image_326",
    "pattern_type": "general",
    "code_template": "image = Image.open(io.BytesIO($P0))\nimage = image.resize((224, 224))\nimage_array = tf.keras.preprocessing.image.img_to_array(image)\nimage_array = tf.keras.applications.mobilenet_v2.preprocess_input(image_array)\nimage_array = tf.expand_dims(image_array, axis=0)\npredictions = model.predict(image_array)\ndecoded_predictions = tf.keras.applications.mobilenet_v2.decode_predictions(predictions, top=1)\nreturn decoded_predictions[0][0][1]",
    "description": "classify_image (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_classify_327": {
    "name": "stack_classify_327",
    "pattern_type": "general",
    "code_template": "if 'image' not in request.files:\n    return (jsonify({'error': 'No image uploaded'}), 400)\nfile = request.files['image']\nimage_data = file.read()\nresult = classify_image(image_data)\nreturn jsonify({'classification': result})",
    "description": "classify (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_parentheses_balanced_328": {
    "name": "stack_is_parentheses_balanced_328",
    "pattern_type": "general",
    "code_template": "match = {')': '(', ']': '[', '}': '{'}\nstack = ArrayStack()\nfor char in $P0:\n    if char in match.values():\n        stack.push(char)\n    elif char in match:\n        if stack.is_empty() or stack.pop() != match[char]:\n            return False\nreturn stack.is_empty()",
    "description": "is_parentheses_balanced (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_empty_329": {
    "name": "stack_is_empty_329",
    "pattern_type": "general",
    "code_template": "return len($P0.stack) == 0",
    "description": "is_empty (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_push_330": {
    "name": "stack_push_330",
    "pattern_type": "general",
    "code_template": "$P0.stack.append($P1)",
    "description": "push (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_pop_331": {
    "name": "stack_pop_331",
    "pattern_type": "general",
    "code_template": "if not $P0.is_empty():\n    return $P0.stack.pop()\nreturn None",
    "description": "pop (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_generate_subsets_332": {
    "name": "stack_generate_subsets_332",
    "pattern_type": "general",
    "code_template": "memo = {}\ndef subsets_recursive(start):\n    if start in memo:\n        return memo[start]\n    if start == len($P0):\n        return [[]]\n    excl_subsets = subsets_recursive(start + 1)\n    current = $P0[start]\n    incl_subsets = [subset + [current] for subset in excl_subsets]\n    all_subsets = excl_subsets + incl_subsets\n    memo[start] = all_subsets\n    return all_subsets\nreturn subsets_recursive(0)",
    "description": "generate_subsets (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_subsets_recursive_333": {
    "name": "stack_subsets_recursive_333",
    "pattern_type": "general",
    "code_template": "if $P0 in memo:\n    return memo[$P0]\nif $P0 == len(arr):\n    return [[]]\nexcl_subsets = subsets_recursive($P0 + 1)\ncurrent = arr[$P0]\nincl_subsets = [subset + [current] for subset in excl_subsets]\nall_subsets = excl_subsets + incl_subsets\nmemo[$P0] = all_subsets\nreturn all_subsets",
    "description": "subsets_recursive (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_frequent_access_employees_334": {
    "name": "stack_frequent_access_employees_334",
    "pattern_type": "general",
    "code_template": "access_time_map = {}\nfor record in $P0:\n    employee_name = record[0]\n    access_times = record[1:]\n    for time in access_times:\n        if time not in access_time_map:\n            access_time_map[time] = []\n        access_time_map[time].append(employee_name)\nresult = []\nfor query_time in $P1:\n    if query_time in access_time_map:\n        employees_at_time = sorted(access_time_map[query_time])\n        result.append(employees_at_time)\n    else:\n        result.append([])\nreturn result",
    "description": "frequent_access_employees (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_longest_palindrome_335": {
    "name": "stack_longest_palindrome_335",
    "pattern_type": "general",
    "code_template": "n = len($P0)\nif n <= 1:\n    return $P0\ndp = [[False] * n for _ in range(n)]\n(start, max_length) = (0, 1)\nfor i in range(n):\n    dp[i][i] = True\nfor end in range(1, n):\n    for start in range(end):\n        if $P0[start] == $P0[end]:\n            if end - start <= 2 or dp[start + 1][end - 1]:\n                dp[start][end] = True\n                current_length = end - start + 1\n                if current_length > max_length:\n                    max_length = current_length\n                    longest_start = start\nreturn $P0[longest_start:longest_start + max_length]",
    "description": "longest_palindrome (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_measure_performance_336": {
    "name": "stack_measure_performance_336",
    "pattern_type": "general",
    "code_template": "start_time = time.time()\nprimes = segmented_sieve($P0)\nend_time = time.time()\nprint(f'Primes up to {$P0}: {len(primes)} found')\nprint(f'Time taken: {end_time - start_time} seconds')",
    "description": "measure_performance (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_create_document_term_matrix_337": {
    "name": "stack_create_document_term_matrix_337",
    "pattern_type": "general",
    "code_template": "vectorizer = CountVectorizer()\nX = vectorizer.fit_transform($P0)\nreturn pd.DataFrame(X.toarray(), columns=vectorizer.get_feature_names_out())",
    "description": "create_document_term_matrix (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfsMazeSolver_338": {
    "name": "stack_dfsMazeSolver_338",
    "pattern_type": "general",
    "code_template": "start = end = None\nfor i in range(len($P0)):\n    for j in range(len($P0[i])):\n        if $P0[i][j] == 'S':\n            start = (i, j)\n        elif $P0[i][j] == 'E':\n            end = (i, j)\nif not start or not end:\n    return []\n(rows, cols) = (len($P0), len($P0[0]))\nvisited = set()\ndef dfs(x, y, path):\n    if x < 0 or x >= rows or y < 0 or (y >= cols) or ($P0[x][y] == '1'):\n        return []\n    if (x, y) in visited:\n        return []\n    if (x, y) == end:\n        return path + [(x, y)]\n    visited.add((x, y))\n    result = dfs(x + 1, y, path + [(x, y)])\n    if result:\n        return result\n    result = dfs(x - 1, y, path + [(x, y)])\n    if result:\n        return result\n    result = dfs(x, y + 1, path + [(x, y)])\n    if result:\n        return result\n    result = dfs(x, y - 1, path + [(x, y)])\n    if result:\n        return result\n    visited.remove((x, y))\n    return []\nreturn dfs(start[0], start[1], [])",
    "description": "dfsMazeSolver (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_push_339": {
    "name": "stack_push_339",
    "pattern_type": "general",
    "code_template": "if $P0.size >= $P0.capacity:\n    print('\u6808\u6ea2\u51fa\u9519\u8bef\uff1a\u65e0\u6cd5\u6dfb\u52a0\u5143\u7d20')\nelse:\n    $P0.stack.append($P1)\n    $P0.size += 1\n    print(f'\u5143\u7d20 {$P1} \u5df2\u6dfb\u52a0\u5230\u6808')",
    "description": "push (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_pop_340": {
    "name": "stack_pop_340",
    "pattern_type": "general",
    "code_template": "if $P0.size == 0:\n    print('\u6808\u4e0b\u6ea2\u9519\u8bef\uff1a\u6ca1\u6709\u5143\u7d20\u53ef\u79fb\u9664')\n    return None\nelse:\n    item = $P0.stack.pop()\n    $P0.size -= 1\n    print(f'\u5143\u7d20 {item} \u5df2\u4ece\u6808\u4e2d\u79fb\u9664')\n    return item",
    "description": "pop (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_peek_341": {
    "name": "stack_peek_341",
    "pattern_type": "general",
    "code_template": "if $P0.size == 0:\n    print('\u6808\u662f\u7a7a\u7684')\n    return None\nelse:\n    item = $P0.stack[-1]\n    print(f'\u6808\u9876\u5143\u7d20\u662f {item}')\n    return item",
    "description": "peek (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_safe_342": {
    "name": "stack_is_safe_342",
    "pattern_type": "general",
    "code_template": "work = resources.copy()\nfinish = [False] * len(processes)\nsafe_sequence = []\nwhile len(safe_sequence) < len(processes):\n    safe = False\n    for (i, process) in enumerate(processes):\n        if not finish[i] and all((need[i][j] <= work[j] for j in range(len(resources)))):\n            safe_sequence.append(process)\n            finish[i] = True\n            safe = True\n            for j in range(len(resources)):\n                work[j] += allocations[i][j]\n    if not safe:\n        return False\nreturn True",
    "description": "is_safe (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_convertAndValidateTime_343": {
    "name": "stack_convertAndValidateTime_343",
    "pattern_type": "general",
    "code_template": "def convert_to_24_hour_format(time_str):\n    in_time = datetime.strptime(time_str, '%I:%M %p')\n    return in_time.strftime('%H:%M')\nconverted_times = [convert_to_24_hour_format(time) for time in $P0]\nif $P1:\n    converted_times.sort()\nreturn converted_times",
    "description": "convertAndValidateTime (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_convert_to_24_hour_format_344": {
    "name": "stack_convert_to_24_hour_format_344",
    "pattern_type": "general",
    "code_template": "in_time = datetime.strptime($P0, '%I:%M %p')\nreturn in_time.strftime('%H:%M')",
    "description": "convert_to_24_hour_format (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_matrix_mult_345": {
    "name": "stack_matrix_mult_345",
    "pattern_type": "general",
    "code_template": "return [[($P0[0][0] * $P1[0][0] + $P0[0][1] * $P1[1][0]) % $P2, ($P0[0][0] * $P1[0][1] + $P0[0][1] * $P1[1][1]) % $P2], [($P0[1][0] * $P1[0][0] + $P0[1][1] * $P1[1][0]) % $P2, ($P0[1][0] * $P1[0][1] + $P0[1][1] * $P1[1][1]) % $P2]]",
    "description": "matrix_mult (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_matrix_pow_346": {
    "name": "stack_matrix_pow_346",
    "pattern_type": "general",
    "code_template": "result = [[1, 0], [0, 1]]\nbase = $P0\nwhile $P1:\n    if $P1 % 2 == 1:\n        result = matrix_mult(result, base, $P2)\n    base = matrix_mult(base, base, $P2)\n    $P1 //= 2\nreturn result",
    "description": "matrix_pow (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_compute_T_n_347": {
    "name": "stack_compute_T_n_347",
    "pattern_type": "general",
    "code_template": "if $P4 == 0:\n    return $P2 % $P5\nelif $P4 == 1:\n    return $P3 % $P5\nT = [[$P0, $P1], [1, 0]]\nT_n_minus_1 = matrix_pow(T, $P4 - 1, $P5)\nT_n = (T_n_minus_1[0][0] * $P3 + T_n_minus_1[0][1] * $P2) % $P5\nreturn T_n",
    "description": "compute_T_n (6 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_all_topological_sorts_348": {
    "name": "stack_all_topological_sorts_348",
    "pattern_type": "algorithm",
    "code_template": "nodes = $P0.keys()\nin_degree = {u: 0 for u in nodes}\nfor u in nodes:\n    for v in $P0[u]:\n        in_degree[v] += 1\nsorted_order = []\nall_orders = []\ndef backtrack():\n    removable = False\n    for node in nodes:\n        if in_degree[node] == 0 and node not in sorted_order:\n            sorted_order.append(node)\n            for neighbor in $P0[node]:\n                in_degree[neighbor] -= 1\n            backtrack()\n            sorted_order.remove(node)\n            for neighbor in $P0[node]:\n                in_degree[neighbor] += 1\n            removable = True\n    if not removable and len(sorted_order) == len(nodes):\n        all_orders.append(sorted_order.copy())\nbacktrack()\nreturn all_orders",
    "description": "all_topological_sorts (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_backtrack_349": {
    "name": "stack_backtrack_349",
    "pattern_type": "general",
    "code_template": "removable = False\nfor node in nodes:\n    if in_degree[node] == 0 and node not in sorted_order:\n        sorted_order.append(node)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n        backtrack()\n        sorted_order.remove(node)\n        for neighbor in graph[node]:\n            in_degree[neighbor] += 1\n        removable = True\nif not removable and len(sorted_order) == len(nodes):\n    all_orders.append(sorted_order.copy())",
    "description": "backtrack (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_generate_prime_350": {
    "name": "stack_generate_prime_350",
    "pattern_type": "math",
    "code_template": "while True:\n    prime_candidate = random.getrandbits($P0)\n    if isprime(prime_candidate):\n        return prime_candidate",
    "description": "generate_prime (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_generate_keypair_351": {
    "name": "stack_generate_keypair_351",
    "pattern_type": "general",
    "code_template": "p = generate_prime($P0)\nq = generate_prime($P0)\nn = p * q\nphi = (p - 1) * (q - 1)\ne = random.randrange(2, phi)\ng = gcd(e, phi)\nwhile g != 1:\n    e = random.randrange(2, phi)\n    g = gcd(e, phi)\nd = mod_inverse(e, phi)\nreturn ((e, n), (d, n))",
    "description": "generate_keypair (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_encrypt_352": {
    "name": "stack_encrypt_352",
    "pattern_type": "general",
    "code_template": "(key, n) = $P0\ncipher = [pow(ord(char), key, n) for char in $P1]\nreturn cipher",
    "description": "encrypt (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_decrypt_353": {
    "name": "stack_decrypt_353",
    "pattern_type": "general",
    "code_template": "(key, n) = $P0\nplain = [chr(pow(char, key, n)) for char in $P1]\nreturn ''.join(plain)",
    "description": "decrypt (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_rsa_simulation_354": {
    "name": "stack_rsa_simulation_354",
    "pattern_type": "general",
    "code_template": "(public, private) = generate_keypair()\nmessage = input('Enter a message to encrypt: ')\nif not message:\n    print('Invalid message. Please enter a non-empty message.')\n    return\nencrypted_message = encrypt(public, message)\nprint(f'Encrypted message: {encrypted_message}')\ndecrypted_message = decrypt(private, encrypted_message)\nprint(f'Decrypted message: {decrypted_message}')",
    "description": "rsa_simulation (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_compute_task_355": {
    "name": "stack_compute_task_355",
    "pattern_type": "general",
    "code_template": "print(f'Task {$P0} is starting, estimated $P1: {$P1}s')\ntime.sleep($P1)\nresult = f'Task {$P0} completed'\nprint(result)\nreturn result",
    "description": "compute_task (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_schedule_tasks_356": {
    "name": "stack_schedule_tasks_356",
    "pattern_type": "general",
    "code_template": "return sorted($P0, key=lambda x: x[1])",
    "description": "schedule_tasks (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_main_357": {
    "name": "stack_main_357",
    "pattern_type": "general",
    "code_template": "tasks = [(i, random.uniform(0.5, 3.0)) for i in range(10)]\nscheduled_tasks = schedule_tasks(tasks)\nwith concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:\n    futures = {executor.submit(compute_task, task_id, duration): task_id for (task_id, duration) in scheduled_tasks}\n    for future in concurrent.futures.as_completed(futures):\n        task_id = futures[future]\n        try:\n            result = future.result()\n            print(f'Result of Task {task_id}: {result}')\n        except Exception as exc:\n            print(f'Task {task_id} generated an exception: {exc}')",
    "description": "main (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_main_358": {
    "name": "stack_main_358",
    "pattern_type": "general",
    "code_template": "combined_text = read_files($P0)\nword_count = count_words(combined_text)\nsorted_word_count = sort_words_by_frequency(word_count)\nfor (word, count) in sorted_word_count:\n    print(f'{word}: {count}')",
    "description": "main (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_palindrome_359": {
    "name": "stack_is_palindrome_359",
    "pattern_type": "general",
    "code_template": "$P0 = ''.join(filter(str.isalnum, $P0)).lower()\nreturn $P0 == $P0[::-1]",
    "description": "is_palindrome (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_maximize_priority_360": {
    "name": "stack_maximize_priority_360",
    "pattern_type": "general",
    "code_template": "dp = [[[0 for _ in range(max($P3) + 1)] for _ in range($P1 + 1)] for _ in range($P0 + 1)]\nfor i in range(1, $P0 + 1):\n    for j in range(1, $P1 + 1):\n        for k in range($P3[j - 1] + 1):\n            dp[i][j][k] = dp[i - 1][j][k]\n            for x in range(min($P2[i - 1], k) + 1):\n                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - x] + x * $P4[i - 1])\nmax_priority = max((dp[$P0][$P1][k] for k in range(max($P3) + 1)))\ndistribution_plan = [[0 for _ in range($P1)] for _ in range($P0)]\n(i, j, k) = ($P0, $P1, max($P3))\nwhile i > 0 and j > 0:\n    if dp[i][j][k] != dp[i - 1][j][k]:\n        for x in range(min($P2[i - 1], k) + 1):\n            if dp[i][j][k] == dp[i - 1][j][k - x] + x * $P4[i - 1]:\n                distribution_plan[i - 1][j - 1] = x\n                k -= x\n                break\n    i -= 1\nreturn (distribution_plan, max_priority)",
    "description": "maximize_priority (5 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_search_rotated_array_361": {
    "name": "stack_search_rotated_array_361",
    "pattern_type": "algorithm",
    "code_template": "(left, right) = (0, len($P0) - 1)\nwhile left <= right:\n    mid = (left + right) // 2\n    if $P0[mid] == $P1:\n        return mid\n    if $P0[left] <= $P0[mid]:\n        if $P0[left] <= $P1 < $P0[mid]:\n            right = mid - 1\n        else:\n            left = mid + 1\n    elif $P0[mid] < $P1 <= $P0[right]:\n        left = mid + 1\n    else:\n        right = mid - 1\nreturn -1",
    "description": "search_rotated_array (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_insert_362": {
    "name": "stack_insert_362",
    "pattern_type": "general",
    "code_template": "current_node = $P0.root\nfor char in $P1:\n    if char not in current_node.children:\n        current_node.children[char] = TrieNode()\n    current_node = current_node.children[char]\ncurrent_node.is_end_of_word = True",
    "description": "insert (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_search_prefix_363": {
    "name": "stack_search_prefix_363",
    "pattern_type": "algorithm",
    "code_template": "current_node = $P0.root\nfor char in $P1:\n    if char not in current_node.children:\n        return []\n    current_node = current_node.children[char]\nreturn $P0._find_words_from_node(current_node, $P1)",
    "description": "search_prefix (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_even_364": {
    "name": "stack_is_even_364",
    "pattern_type": "general",
    "code_template": "return $P0 % 2 == 0",
    "description": "is_even (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_peak_element_365": {
    "name": "stack_find_peak_element_365",
    "pattern_type": "algorithm",
    "code_template": "if not $P0:\n    return -1\nn = len($P0)\nif n == 1:\n    return 0\nfor i in range(n - 1):\n    if $P0[i] > $P0[i + 1]:\n        return i\nreturn n - 1",
    "description": "find_peak_element (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_transform_strings_366": {
    "name": "stack_transform_strings_366",
    "pattern_type": "string",
    "code_template": "result = []\nfor s in $P0:\n    substrings = {s[i:i + $P1] for i in range(len(s) - $P1 + 1)}\n    if all((any((forbidden in substring for forbidden in $P2)) for substring in substrings)):\n        continue\n    valid_substrings = {substring for substring in substrings if not any((forbidden in substring for forbidden in $P2))}\n    if valid_substrings:\n        result.append(valid_substrings)\nreturn result",
    "description": "transform_strings (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_calculate_hash_367": {
    "name": "stack_calculate_hash_367",
    "pattern_type": "general",
    "code_template": "block_string = f'{$P0.index}{$P0.transactions}{$P0.timestamp}{$P0.previous_hash}{$P0.nonce}'\nreturn hashlib.sha256(block_string.encode()).hexdigest()",
    "description": "calculate_hash (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_mine_block_368": {
    "name": "stack_mine_block_368",
    "pattern_type": "general",
    "code_template": "target = '0' * $P1\nwhile $P0.hash[:$P1] != target:\n    $P0.nonce += 1\n    $P0.hash = $P0.calculate_hash()\nprint(f'Block mined with hash: {$P0.hash}')",
    "description": "mine_block (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_budgetAllocation_369": {
    "name": "stack_budgetAllocation_369",
    "pattern_type": "general",
    "code_template": "dp = [False] * ($P1 + 1)\ndp[0] = True\nfor cost in $P0:\n    for j in range($P1, cost - 1, -1):\n        if dp[j - cost]:\n            dp[j] = True\nreturn dp[$P1]",
    "description": "budgetAllocation (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_370": {
    "name": "stack_merge_370",
    "pattern_type": "general",
    "code_template": "sorted_array = []\ni = j = 0\nwhile i < len($P0) and j < len($P1):\n    if $P0[i] < $P1[j]:\n        sorted_array.append($P0[i])\n        i += 1\n    else:\n        sorted_array.append($P1[j])\n        j += 1\nwhile i < len($P0):\n    sorted_array.append($P0[i])\n    i += 1\nwhile j < len($P1):\n    sorted_array.append($P1[j])\n    j += 1\nreturn sorted_array",
    "description": "merge (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_matrix_multiply_371": {
    "name": "stack_matrix_multiply_371",
    "pattern_type": "general",
    "code_template": "if len($P0[0]) != len($P1):\n    raise ValueError('Cannot multiply: Number of columns in $P0 must be equal to number of rows in $P1.')\nresult = [[0] * len($P1[0]) for _ in range(len($P0))]\nfor i in range(len($P0)):\n    for j in range(len($P1[0])):\n        for k in range(len($P1)):\n            result[i][j] += $P0[i][k] * $P1[k][j]\nreturn result",
    "description": "matrix_multiply (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_rotate_matrix_90_clockwise_372": {
    "name": "stack_rotate_matrix_90_clockwise_372",
    "pattern_type": "general",
    "code_template": "if len($P0) != len($P0[0]):\n    raise ValueError('Cannot rotate: Matrix must be square.')\nn = len($P0)\nfor i in range(n):\n    for j in range(i, n):\n        ($P0[i][j], $P0[j][i]) = ($P0[j][i], $P0[i][j])\nfor i in range(n):\n    $P0[i].reverse()\nreturn $P0",
    "description": "rotate_matrix_90_clockwise (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_handle_edge_cases_substrings_373": {
    "name": "stack_handle_edge_cases_substrings_373",
    "pattern_type": "string",
    "code_template": "if $P1 <= 0:\n    raise ValueError('Expected length must be greater than 0.')\nsubstrings = {}\ndefault_counter = 1\nresult = []\nfor i in range(len($P0) - $P1 + 1):\n    substring = $P0[i:i + $P1]\n    if substring not in substrings:\n        default_id = f'default{default_counter}'\n        substrings[substring] = default_id\n        default_counter += 1\n    result.append(substrings[substring])\ncounts = {default_id: result.count(default_id) for default_id in set(result)}\noutput = [[default_id, count] for (default_id, count) in counts.items()]\nreturn output",
    "description": "handle_edge_cases_substrings (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_deposit_374": {
    "name": "stack_deposit_374",
    "pattern_type": "general",
    "code_template": "if $P1 < 0:\n    raise ValueError('Cannot deposit negative $P1')\n$P0.balance += $P1",
    "description": "deposit (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_withdraw_375": {
    "name": "stack_withdraw_375",
    "pattern_type": "general",
    "code_template": "if $P1 < 0:\n    raise ValueError('Cannot withdraw negative $P1')\nif $P1 > $P0.balance:\n    raise ValueError('Insufficient funds')\n$P0.balance -= $P1",
    "description": "withdraw (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_check_balance_376": {
    "name": "stack_check_balance_376",
    "pattern_type": "general",
    "code_template": "return $P0.balance",
    "description": "check_balance (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_setUp_377": {
    "name": "stack_setUp_377",
    "pattern_type": "general",
    "code_template": "$P0.bank = BankingSystem()",
    "description": "setUp (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_fibonacci_recursive_378": {
    "name": "stack_fibonacci_recursive_378",
    "pattern_type": "math",
    "code_template": "if $P0 <= 1:\n    return $P0\nreturn fibonacci_recursive($P0 - 1) + fibonacci_recursive($P0 - 2)",
    "description": "fibonacci_recursive (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_fibonacci_iterative_379": {
    "name": "stack_fibonacci_iterative_379",
    "pattern_type": "math",
    "code_template": "if $P0 <= 1:\n    return $P0\n(prev, current) = (0, 1)\nfor _ in range(2, $P0 + 1):\n    (prev, current) = (current, prev + current)\nreturn current",
    "description": "fibonacci_iterative (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_gcd_array_iterative_380": {
    "name": "stack_gcd_array_iterative_380",
    "pattern_type": "math",
    "code_template": "if not $P0:\n    return 0\nresult = $P0[0]\nfor num in $P0[1:]:\n    result = math.gcd(result, num)\n    if result == 1:\n        return 1\nreturn result",
    "description": "gcd_array_iterative (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_gcd_recursive_381": {
    "name": "stack_gcd_recursive_381",
    "pattern_type": "math",
    "code_template": "if $P1 == 0:\n    return $P0\nelse:\n    return gcd_recursive($P1, $P0 % $P1)",
    "description": "gcd_recursive (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_gcd_array_recursive_382": {
    "name": "stack_gcd_array_recursive_382",
    "pattern_type": "math",
    "code_template": "if not $P0:\n    return 0\ndef find_gcd($P0, n):\n    if n == 1:\n        return $P0[0]\n    elif n == 2:\n        return gcd_recursive($P0[0], $P0[1])\n    else:\n        return gcd_recursive($P0[n - 1], find_gcd($P0, n - 1))\nreturn find_gcd($P0, len($P0))",
    "description": "gcd_array_recursive (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_gcd_383": {
    "name": "stack_find_gcd_383",
    "pattern_type": "algorithm",
    "code_template": "if $P1 == 1:\n    return $P0[0]\nelif $P1 == 2:\n    return gcd_recursive($P0[0], $P0[1])\nelse:\n    return gcd_recursive($P0[$P1 - 1], find_gcd($P0, $P1 - 1))",
    "description": "find_gcd (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_analyze_health_impact_384": {
    "name": "stack_analyze_health_impact_384",
    "pattern_type": "general",
    "code_template": "if $P0 <= 50:\n    respiratory_issue_percentage = 1\nelif $P0 <= 100:\n    respiratory_issue_percentage = 5\nelif $P0 <= 150:\n    respiratory_issue_percentage = 10\nelif $P0 <= 200:\n    respiratory_issue_percentage = 20\nelif $P0 <= 300:\n    respiratory_issue_percentage = 30\nelse:\n    respiratory_issue_percentage = 50\nif $P1 >= 10:\n    activity_index = 100\nelse:\n    activity_index = $P1 / 10 * 100\nif $P1 < 10:\n    additional_space_needed = (10 - $P1) * $P2\nelse:\n    additional_space_needed = 0\nreturn {'respiratory_issue_percentage': respiratory_issue_percentage, 'activity_index': activity_index, 'additional_space_needed': additional_space_needed}",
    "description": "analyze_health_impact (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_maximize_utilization_385": {
    "name": "stack_maximize_utilization_385",
    "pattern_type": "general",
    "code_template": "used = [[False] * $P1 for _ in range($P0)]\n$P2.sort(key=lambda x: x[0] * x[1], reverse=True)\ncut_plan = []\nfor (tool_width, tool_height) in $P2:\n    placed = False\n    for i in range($P0 - tool_width + 1):\n        for j in range($P1 - tool_height + 1):\n            if all((not used[i + x][j + y] for x in range(tool_width) for y in range(tool_height))):\n                for x in range(tool_width):\n                    for y in range(tool_height):\n                        used[i + x][j + y] = True\n                cut_plan.append((tool_width, tool_height, i, j))\n                placed = True\n                break\n        if placed:\n            break\nused_area = sum((sum(row) for row in used))\nutilization = used_area / ($P0 * $P1)\nreturn (cut_plan, utilization)",
    "description": "maximize_utilization (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_reduce_to_ugly_386": {
    "name": "stack_reduce_to_ugly_386",
    "pattern_type": "general",
    "code_template": "if $P0 <= 0:\n    return -1\nprime_factors = [2, 3, 5]\nfor factor in prime_factors:\n    while $P0 % factor == 0:\n        $P0 //= factor\nreturn $P0",
    "description": "reduce_to_ugly (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_concatenate_last_digits_387": {
    "name": "stack_concatenate_last_digits_387",
    "pattern_type": "general",
    "code_template": "result = ''\nfor i in range(0, len($P0), $P1):\n    substring = $P0[i:i + $P1]\n    result += substring[-1]\nreturn result",
    "description": "concatenate_last_digits (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_selection_sort_388": {
    "name": "stack_selection_sort_388",
    "pattern_type": "algorithm",
    "code_template": "swaps = 0\nn = len($P0)\nfor i in range(n):\n    min_index = i\n    for j in range(i + 1, n):\n        if $P0[j] < $P0[min_index]:\n            min_index = j\n    if min_index != i:\n        ($P0[i], $P0[min_index]) = ($P0[min_index], $P0[i])\n        swaps += 1\nreturn (swaps, $P0)",
    "description": "selection_sort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_bubble_sort_389": {
    "name": "stack_bubble_sort_389",
    "pattern_type": "algorithm",
    "code_template": "swaps = 0\nn = len($P0)\nfor i in range(n):\n    for j in range(0, n - i - 1):\n        if $P0[j] > $P0[j + 1]:\n            ($P0[j], $P0[j + 1]) = ($P0[j + 1], $P0[j])\n            swaps += 1\nreturn (swaps, $P0)",
    "description": "bubble_sort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_countIncreasingPaths_390": {
    "name": "stack_countIncreasingPaths_390",
    "pattern_type": "general",
    "code_template": "if not $P0 or not $P0[0]:\n    return 0\n(m, n) = (len($P0), len($P0[0]))\ndp = [[-1] * n for _ in range(m)]\ndirections = [(0, 1), (1, 0), (0, -1), (-1, 0)]\ndef dfs(x, y):\n    if dp[x][y] != -1:\n        return dp[x][y]\n    count = 1\n    for (dx, dy) in directions:\n        (nx, ny) = (x + dx, y + dy)\n        if 0 <= nx < m and 0 <= ny < n and ($P0[nx][ny] > $P0[x][y]):\n            count += dfs(nx, ny)\n    dp[x][y] = count\n    return count\ntotal_paths = 0\nfor i in range(m):\n    for j in range(n):\n        total_paths += dfs(i, j)\nreturn total_paths",
    "description": "countIncreasingPaths (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_391": {
    "name": "stack_dfs_391",
    "pattern_type": "general",
    "code_template": "if dp[$P0][$P1] != -1:\n    return dp[$P0][$P1]\ncount = 1\nfor (dx, dy) in directions:\n    (nx, ny) = ($P0 + dx, $P1 + dy)\n    if 0 <= nx < m and 0 <= ny < n and (matrix[nx][ny] > matrix[$P0][$P1]):\n        count += dfs(nx, ny)\ndp[$P0][$P1] = count\nreturn count",
    "description": "dfs (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_process_file_392": {
    "name": "stack_process_file_392",
    "pattern_type": "general",
    "code_template": "shifts = generate_shift_pattern($P2)\nshift_length = len(shifts)\nbuffer_size = 4096\nwith open($P0, 'r') as infile, open($P1, 'w') as outfile:\n    buffer = infile.read(buffer_size)\n    position = 0\n    while buffer:\n        processed_buffer = []\n        for char in buffer:\n            shift = shifts[position % shift_length]\n            shifted_char = caesar_shift(char, shift, $P3)\n            processed_buffer.append(shifted_char)\n            position += 1\n        outfile.write(''.join(processed_buffer))\n        buffer = infile.read(buffer_size)",
    "description": "process_file (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_magic_square_393": {
    "name": "stack_is_magic_square_393",
    "pattern_type": "general",
    "code_template": "if not $P0 or not $P0[0]:\n    return False\nn = len($P0)\nfor row in $P0:\n    if len(row) != n:\n        return False\nreference_sum = sum($P0[0])\nfor row in $P0:\n    if sum(row) != reference_sum:\n        return False\nfor col in range(n):\n    if sum(($P0[row][col] for row in range(n))) != reference_sum:\n        return False\nif sum(($P0[i][i] for i in range(n))) != reference_sum:\n    return False\nif sum(($P0[i][n - 1 - i] for i in range(n))) != reference_sum:\n    return False\nreturn True",
    "description": "is_magic_square (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_setup_simple_vpn_394": {
    "name": "stack_setup_simple_vpn_394",
    "pattern_type": "general",
    "code_template": "host = 'localhost'\nport = 12345\ndef vpn_server():\n    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n    context.load_cert_chain(certfile='cert.pem', keyfile='key.pem')\n    bindsocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    bindsocket.bind((host, port))\n    bindsocket.listen(5)\n    print('VPN Server listening on port:', port)\n    while True:\n        (newsocket, fromaddr) = bindsocket.accept()\n        try:\n            with context.wrap_socket(newsocket, server_side=True) as ssock:\n                print('VPN Server: SSL connection established with', fromaddr)\n                data = ssock.recv(1024)\n                print('VPN Server: Encrypted Data Received:', data)\n                print('VPN Server: Decrypted Message:', data.decode('utf-8'))\n                response = f\"Server: You sent '{data.decode('utf-8')}'\"\n                ssock.send(response.encode('utf-8'))\n        except Exception as e:\n            print(f'VPN Server Error: {e}')\n        finally:\n            newsocket.close()\ndef vpn_client():\n    context = ssl.create_default_context()\n    print('VPN Client: Connecting to Server on port:', port)\n    with socket.create_connection((host, port)) as sock:\n        with context.wrap_socket(sock, server_hostname=host) as ssock:\n            message = 'Hello VPN server'\n            print('VPN Client: Sending Encrypted Message:', message)\n            ssock.send(message.encode('utf-8'))\n            response = ssock.recv(1024)\n            print('VPN Client: Encrypted Data Received:', response)\n            print('VPN Client: Decrypted Response:', response.decode('utf-8'))\nimport threading\nserver_thread = threading.Thread(target=vpn_server)\nserver_thread.start()\nimport time\ntime.sleep(1)\nvpn_client()",
    "description": "setup_simple_vpn (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_vpn_server_395": {
    "name": "stack_vpn_server_395",
    "pattern_type": "general",
    "code_template": "context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\ncontext.load_cert_chain(certfile='cert.pem', keyfile='key.pem')\nbindsocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nbindsocket.bind((host, port))\nbindsocket.listen(5)\nprint('VPN Server listening on port:', port)\nwhile True:\n    (newsocket, fromaddr) = bindsocket.accept()\n    try:\n        with context.wrap_socket(newsocket, server_side=True) as ssock:\n            print('VPN Server: SSL connection established with', fromaddr)\n            data = ssock.recv(1024)\n            print('VPN Server: Encrypted Data Received:', data)\n            print('VPN Server: Decrypted Message:', data.decode('utf-8'))\n            response = f\"Server: You sent '{data.decode('utf-8')}'\"\n            ssock.send(response.encode('utf-8'))\n    except Exception as e:\n        print(f'VPN Server Error: {e}')\n    finally:\n        newsocket.close()",
    "description": "vpn_server (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_vpn_client_396": {
    "name": "stack_vpn_client_396",
    "pattern_type": "general",
    "code_template": "context = ssl.create_default_context()\nprint('VPN Client: Connecting to Server on port:', port)\nwith socket.create_connection((host, port)) as sock:\n    with context.wrap_socket(sock, server_hostname=host) as ssock:\n        message = 'Hello VPN server'\n        print('VPN Client: Sending Encrypted Message:', message)\n        ssock.send(message.encode('utf-8'))\n        response = ssock.recv(1024)\n        print('VPN Client: Encrypted Data Received:', response)\n        print('VPN Client: Decrypted Response:', response.decode('utf-8'))",
    "description": "vpn_client (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_k_largest_elements_397": {
    "name": "stack_find_k_largest_elements_397",
    "pattern_type": "algorithm",
    "code_template": "max_heap = [-x for x in $P0]\nheapq.heapify(max_heap)\nk_largest = []\nfor _ in range($P1):\n    max_element = -heapq.heappop(max_heap)\n    k_largest.append(max_element)\nreturn k_largest",
    "description": "find_k_largest_elements (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_sentiment_analysis_398": {
    "name": "stack_sentiment_analysis_398",
    "pattern_type": "general",
    "code_template": "words = $P0.lower().split()\nscore = 0\ni = 0\nwhile i < len(words):\n    word = words[i]\n    if word in negations and i + 1 < len(words) and (words[i + 1] in lexicon):\n        score -= lexicon[words[i + 1]]\n        i += 2\n    elif word in intensifiers and i + 1 < len(words) and (words[i + 1] in lexicon):\n        score += 2 * lexicon[words[i + 1]]\n        i += 2\n    else:\n        if word in lexicon:\n            score += lexicon[word]\n        i += 1\nreturn score",
    "description": "sentiment_analysis (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_tower_of_hanoi_399": {
    "name": "stack_tower_of_hanoi_399",
    "pattern_type": "general",
    "code_template": "if $P0 == 1:\n    print(f'Move disk 1 from pole {$P1} to pole {$P2}')\n    return 1\nmoves = 0\nmoves += tower_of_hanoi($P0 - 1, $P1, $P3, $P2)\nprint(f'Move disk {$P0} from pole {$P1} to pole {$P2}')\nmoves += 1\nmoves += tower_of_hanoi($P0 - 1, $P3, $P2, $P1)\nreturn moves",
    "description": "tower_of_hanoi (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_edge_400": {
    "name": "stack_add_edge_400",
    "pattern_type": "general",
    "code_template": "$P0.edges.append(($P1, $P2, $P3))",
    "description": "add_edge (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_bellman_ford_401": {
    "name": "stack_bellman_ford_401",
    "pattern_type": "general",
    "code_template": "dist = [float('Inf')] * $P0.V\ndist[$P1] = 0\nfor i in range($P0.V - 1):\n    for (u, v, weight) in $P0.edges:\n        if dist[u] != float('Inf') and dist[u] + weight < dist[v]:\n            dist[v] = dist[u] + weight\nfor (u, v, weight) in $P0.edges:\n    if dist[u] != float('Inf') and dist[u] + weight < dist[v]:\n        print('Graph contains negative weight cycle')\n        return\n$P0._print_distances(dist)",
    "description": "bellman_ford (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_402": {
    "name": "stack_find_402",
    "pattern_type": "algorithm",
    "code_template": "if $P1 != $P0.root[$P1]:\n    $P0.root[$P1] = $P0.find($P0.root[$P1])\nreturn $P0.root[$P1]",
    "description": "find (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_union_403": {
    "name": "stack_union_403",
    "pattern_type": "general",
    "code_template": "rootX = $P0.find($P1)\nrootY = $P0.find($P2)\nif rootX != rootY:\n    if $P0.size[rootX] > $P0.size[rootY]:\n        $P0.root[rootY] = rootX\n        $P0.size[rootX] += $P0.size[rootY]\n    else:\n        $P0.root[rootX] = rootY\n        $P0.size[rootY] += $P0.size[rootX]",
    "description": "union (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_size_404": {
    "name": "stack_get_size_404",
    "pattern_type": "general",
    "code_template": "rootX = $P0.find($P1)\nreturn $P0.size[rootX]",
    "description": "get_size (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_insert_405": {
    "name": "stack_insert_405",
    "pattern_type": "general",
    "code_template": "if $P0.size / $P0.capacity >= $P0.load_factor:\n    $P0._resize()\nhashed_key = $P0._hash($P1)\ni = 0\nwhile True:\n    index = $P0._probe(hashed_key, i)\n    if $P0.storage[index] is None or $P0.storage[index] == 'TOMBSTONE':\n        $P0.storage[index] = ($P1, $P2)\n        $P0.size += 1\n        return\n    i += 1",
    "description": "insert (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_file_operations_406": {
    "name": "stack_file_operations_406",
    "pattern_type": "general",
    "code_template": "try:\n    print('Opening a non-existent file...')\n    with open('non_existent_file.txt', 'r') as file:\n        data = file.read()\n    print('Processing file content...')\n    result = 10 / 0\nexcept FileNotFoundError as e:\n    print(f'Caught an error: {e}')\n    print('Error type: FileNotFoundError.')\n    print('This error occurred because the file does not exist.')\nexcept ZeroDivisionError as e:\n    print(f'Caught an error: {e}')\n    print('Error type: ZeroDivisionError.')\n    print('An attempt was made to divide by zero, which is not allowed.')\nexcept Exception as e:\n    print(f'Caught an unexpected error: {e}')\n    print('A general error was caught.')\nelse:\n    print('File processed successfully, with no errors encountered.')\nfinally:\n    print('Cleanup actions can be taken here, like closing files or releasing resources.')",
    "description": "file_operations (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_compute_similarity_407": {
    "name": "stack_compute_similarity_407",
    "pattern_type": "general",
    "code_template": "feedback_matrix = np.array(users_data['feedback'].tolist())\nsimilarity_matrix = cosine_similarity(feedback_matrix)\nuser_index = users_data[users_data['$P0'] == $P0].index[0]\nsimilar_users = np.argsort(-similarity_matrix[user_index])\nreturn similar_users",
    "description": "compute_similarity (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_recommend_workouts_408": {
    "name": "stack_recommend_workouts_408",
    "pattern_type": "general",
    "code_template": "similar_users = compute_similarity($P0)\nrecommended_ratings = np.zeros(len(workout_plans))\nfor sim_user in similar_users[1:]:\n    recommended_ratings += np.array(users_data.iloc[sim_user]['feedback'])\ntarget_user = users_data[users_data['$P0'] == $P0]\nfitness_preference = target_user['goal_strength'].values[0]\nadjusted_ratings = recommended_ratings * fitness_preference\nrecommended_workouts_indices = np.argsort(-adjusted_ratings)\nreturn [workout_plans[i] for i in recommended_workouts_indices[:4]]",
    "description": "recommend_workouts (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_sumUniqueDigits_409": {
    "name": "stack_sumUniqueDigits_409",
    "pattern_type": "general",
    "code_template": "unique_digits = set()\nfor num in $P0:\n    for digit in str(num):\n        unique_digits.add(int(digit))\nreturn sum(unique_digits)",
    "description": "sumUniqueDigits (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_initialize_environment_410": {
    "name": "stack_initialize_environment_410",
    "pattern_type": "general",
    "code_template": "return chess.Board()",
    "description": "initialize_environment (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_legal_moves_411": {
    "name": "stack_get_legal_moves_411",
    "pattern_type": "general",
    "code_template": "return list($P0.legal_moves)",
    "description": "get_legal_moves (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_reinforcement_chess_strategy_412": {
    "name": "stack_reinforcement_chess_strategy_412",
    "pattern_type": "string",
    "code_template": "learning_rate = 0.1\ndiscount_factor = 0.95\nexploration_rate = 0.2\nq_table = {}\ncurrent_state = $P0.fen()\nif current_state not in q_table:\n    q_table[current_state] = {move: 0 for move in get_legal_moves($P0)}\nfor _ in range($P1):\n    if random.uniform(0, 1) < exploration_rate:\n        action = random.choice(get_legal_moves($P0))\n    else:\n        state_actions = q_table[current_state]\n        action = max(state_actions, key=state_actions.get)\n    $P0.push(action)\n    reward = 1 if $P0.is_checkmate() else 0\n    new_state = $P0.fen()\n    if new_state not in q_table:\n        q_table[new_state] = {move: 0 for move in get_legal_moves($P0)}\n    future_rewards = max(q_table[new_state].values()) if q_table[new_state] else 0\n    q_table[current_state][action] += learning_rate * (reward + discount_factor * future_rewards - q_table[current_state][action])\n    current_state = new_state\nbest_move = max(q_table[current_state], key=q_table[current_state].get)\nreturn best_move",
    "description": "reinforcement_chess_strategy (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_adjust_resources_413": {
    "name": "stack_adjust_resources_413",
    "pattern_type": "general",
    "code_template": "if $P0 > 100:\n    autoscaling.update_auto_scaling_group(AutoScalingGroupName='GameServerGroup', DesiredCapacity=5)\nelif $P0 < 50:\n    autoscaling.update_auto_scaling_group(AutoScalingGroupName='GameServerGroup', DesiredCapacity=2)",
    "description": "adjust_resources (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_detect_cheating_414": {
    "name": "stack_detect_cheating_414",
    "pattern_type": "general",
    "code_template": "prediction = anti_cheat_model.predict([$P0])\nif prediction == 1:\n    return 'Suspicious activity detected'\nreturn 'No suspicious activity'",
    "description": "detect_cheating (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_dynamic_content_415": {
    "name": "stack_get_dynamic_content_415",
    "pattern_type": "general",
    "code_template": "content = ['Basic Quest']\nif $P0 > 10:\n    content.append('Unlock Special Quest')\nif $P0 > 20:\n    content.append('Unlock Elite Arena')\nreturn content",
    "description": "get_dynamic_content (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_knapsack_416": {
    "name": "stack_knapsack_416",
    "pattern_type": "general",
    "code_template": "n = len($P0)\ndp = [[0 for _ in range($P2 + 1)] for _ in range(n + 1)]\nfor i in range(1, n + 1):\n    for w in range($P2 + 1):\n        if $P0[i - 1] <= w:\n            dp[i][w] = max($P1[i - 1] + dp[i - 1][w - $P0[i - 1]], dp[i - 1][w])\n        else:\n            dp[i][w] = dp[i - 1][w]\nreturn dp[n][$P2]",
    "description": "knapsack (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_compare_algorithms_417": {
    "name": "stack_compare_algorithms_417",
    "pattern_type": "general",
    "code_template": "data = random.sample(range($P0 * 10), $P0)\nstart = time.time()\nquicksort(data.copy())\nquicksort_time = time.time() - start\nstart = time.time()\nmergesort(data.copy())\nmergesort_time = time.time() - start\nprint(f'QuickSort time: {quicksort_time:.5f} seconds')\nprint(f'MergeSort time: {mergesort_time:.5f} seconds')",
    "description": "compare_algorithms (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_extract_substrings_418": {
    "name": "stack_extract_substrings_418",
    "pattern_type": "string",
    "code_template": "result = []\ni = 0\nn = len($P0)\nwhile i < n:\n    if $P0[i] == '1':\n        start = i\n        i += 1\n        while i < n and $P0[i] != '1':\n            i += 1\n        if i < n and $P0[i] == '1':\n            end = i\n            result.append($P0[start:end + 1])\n    i += 1\nreturn result",
    "description": "extract_substrings (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_modular_exponentiation_419": {
    "name": "stack_modular_exponentiation_419",
    "pattern_type": "general",
    "code_template": "result = 1\n$P0 = $P0 % $P2\nwhile $P1 > 0:\n    if $P1 % 2 == 1:\n        result = result * $P0 % $P2\n    $P1 = $P1 >> 1\n    $P0 = $P0 * $P0 % $P2\nreturn result",
    "description": "modular_exponentiation (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_odd_modulo_combination_420": {
    "name": "stack_find_odd_modulo_combination_420",
    "pattern_type": "algorithm",
    "code_template": "for a in $P0:\n    for b in $P0:\n        result1 = modular_exponentiation(a, b, $P2)\n        for c in $P1:\n            for d in $P1:\n                result2 = modular_exponentiation(c, d, $P2)\n                final_result = result1 * result2 % $P2\n                if final_result % 2 == 1:\n                    return True\nreturn False",
    "description": "find_odd_modulo_combination (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_longest_common_prefix_421": {
    "name": "stack_longest_common_prefix_421",
    "pattern_type": "general",
    "code_template": "if not $P0:\n    return ''\nshortest_str = min($P0, key=len)\nfor (i, char) in enumerate(shortest_str):\n    for string in $P0:\n        if string[i] != char:\n            return shortest_str[:i]\nreturn shortest_str",
    "description": "longest_common_prefix (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_sum_of_squares_range_422": {
    "name": "stack_sum_of_squares_range_422",
    "pattern_type": "general",
    "code_template": "return sum((i * i for i in range($P0, $P1)))",
    "description": "sum_of_squares_range (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_calculate_sum_of_squares_serial_423": {
    "name": "stack_calculate_sum_of_squares_serial_423",
    "pattern_type": "general",
    "code_template": "return sum_of_squares_range(1, $P0 + 1)",
    "description": "calculate_sum_of_squares_serial (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_calculate_sum_of_squares_parallel_424": {
    "name": "stack_calculate_sum_of_squares_parallel_424",
    "pattern_type": "general",
    "code_template": "pool = Pool(processes=$P1)\nchunk_size = $P0 // $P1\nranges = [(i * chunk_size + 1, (i + 1) * chunk_size + 1) for i in range($P1)]\nif ranges[-1][1] < $P0 + 1:\n    ranges[-1] = (ranges[-1][0], $P0 + 1)\nresults = pool.starmap(sum_of_squares_range, ranges)\npool.close()\npool.join()\nreturn sum(results)",
    "description": "calculate_sum_of_squares_parallel (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_match_sort_425": {
    "name": "stack_match_sort_425",
    "pattern_type": "algorithm",
    "code_template": "if not $P0 or not $P1:\n    return []\npairs = []\nfor num1 in $P0:\n    for num2 in $P1:\n        difference = abs(num1 - num2)\n        pairs.append(((num1, num2), difference))\npairs.sort(key=lambda x: x[1])\nresult = [pair for (pair, _) in pairs]\nreturn result",
    "description": "match_sort (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_detectCycleDFS_426": {
    "name": "stack_detectCycleDFS_426",
    "pattern_type": "general",
    "code_template": "$P2[$P1] = True\n$P3[$P1] = True\nfor neighbour in $P0[$P1]:\n    if not $P2[neighbour]:\n        if detectCycleDFS($P0, neighbour, $P2, $P3):\n            return True\n    elif $P3[neighbour]:\n        return True\n$P3[$P1] = False\nreturn False",
    "description": "detectCycleDFS (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_detectCycleBFS_427": {
    "name": "stack_detectCycleBFS_427",
    "pattern_type": "general",
    "code_template": "in_degree = [0] * $P1\nfor i in range($P1):\n    for j in $P0[i]:\n        in_degree[j] += 1\nqueue = []\nfor i in range($P1):\n    if in_degree[i] == 0:\n        queue.append(i)\ncount = 0\nwhile queue:\n    current = queue.pop(0)\n    for neighbour in $P0[current]:\n        in_degree[neighbour] -= 1\n        if in_degree[neighbour] == 0:\n            queue.append(neighbour)\n    count += 1\nreturn count != $P1",
    "description": "detectCycleBFS (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_detectCycleHybrid_428": {
    "name": "stack_detectCycleHybrid_428",
    "pattern_type": "general",
    "code_template": "graph = $P0.graph\nvertices = $P0.V\nif vertices < 100:\n    print('Using DFS for cycle detection')\n    visited = [False] * vertices\n    recStack = [False] * vertices\n    for node in range(vertices):\n        if not visited[node]:\n            if detectCycleDFS(graph, node, visited, recStack):\n                return True\n    return False\nelse:\n    print('Using BFS for cycle detection')\n    return detectCycleBFS(graph, vertices)",
    "description": "detectCycleHybrid (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_edge_429": {
    "name": "stack_add_edge_429",
    "pattern_type": "general",
    "code_template": "$P0.graph[$P1].append($P2)",
    "description": "add_edge (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_insert_430": {
    "name": "stack_insert_430",
    "pattern_type": "general",
    "code_template": "if not $P1:\n    return TreeNode($P2, $P3)\nelif $P2 < $P1.$P2:\n    $P1.left = $P0.insert($P1.left, $P2, $P3)\nelse:\n    $P1.right = $P0.insert($P1.right, $P2, $P3)\n$P1.height = 1 + max($P0.get_height($P1.left), $P0.get_height($P1.right))\nbalance = $P0.get_balance($P1)\nif balance > 1 and $P2 < $P1.left.$P2:\n    return $P0.right_rotate($P1)\nif balance < -1 and $P2 > $P1.right.$P2:\n    return $P0.left_rotate($P1)\nif balance > 1 and $P2 > $P1.left.$P2:\n    $P1.left = $P0.left_rotate($P1.left)\n    return $P0.right_rotate($P1)\nif balance < -1 and $P2 < $P1.right.$P2:\n    $P1.right = $P0.right_rotate($P1.right)\n    return $P0.left_rotate($P1)\nreturn $P1",
    "description": "insert (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_left_rotate_431": {
    "name": "stack_left_rotate_431",
    "pattern_type": "general",
    "code_template": "y = $P1.right\nT2 = y.left\ny.left = $P1\n$P1.right = T2\n$P1.height = 1 + max($P0.get_height($P1.left), $P0.get_height($P1.right))\ny.height = 1 + max($P0.get_height(y.left), $P0.get_height(y.right))\nreturn y",
    "description": "left_rotate (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_right_rotate_432": {
    "name": "stack_right_rotate_432",
    "pattern_type": "general",
    "code_template": "y = $P1.left\nT3 = y.right\ny.right = $P1\n$P1.left = T3\n$P1.height = 1 + max($P0.get_height($P1.left), $P0.get_height($P1.right))\ny.height = 1 + max($P0.get_height(y.left), $P0.get_height(y.right))\nreturn y",
    "description": "right_rotate (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_height_433": {
    "name": "stack_get_height_433",
    "pattern_type": "general",
    "code_template": "if not $P1:\n    return 0\nreturn $P1.height",
    "description": "get_height (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_count_even_numbers_in_sublist_434": {
    "name": "stack_count_even_numbers_in_sublist_434",
    "pattern_type": "list",
    "code_template": "even_counts = []\nfor sublist in $P0:\n    even_count = 0\n    for number in sublist:\n        if number % 2 == 0:\n            even_count += 1\n    even_counts.append(even_count)\nreturn even_counts",
    "description": "count_even_numbers_in_sublist (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_push_435": {
    "name": "stack_push_435",
    "pattern_type": "general",
    "code_template": "while $P0.primary:\n    $P0.secondary.append($P0.primary.popleft())\n$P0.primary.append($P1)\nwhile $P0.secondary:\n    $P0.primary.append($P0.secondary.popleft())",
    "description": "push (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_pop_436": {
    "name": "stack_pop_436",
    "pattern_type": "general",
    "code_template": "if $P0.primary:\n    return $P0.primary.popleft()\nelse:\n    raise IndexError('pop from empty stack')",
    "description": "pop (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_top_437": {
    "name": "stack_top_437",
    "pattern_type": "general",
    "code_template": "if $P0.primary:\n    return $P0.primary[0]\nelse:\n    raise IndexError('top from empty stack')",
    "description": "top (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_count_inversions_438": {
    "name": "stack_count_inversions_438",
    "pattern_type": "general",
    "code_template": "def merge_count_split_inv($P0, temp_arr, left, mid, right):\n    i = left\n    j = mid + 1\n    k = left\n    inv_count = 0\n    while i <= mid and j <= right:\n        if $P0[i] <= $P0[j]:\n            temp_arr[k] = $P0[i]\n            i += 1\n        else:\n            temp_arr[k] = $P0[j]\n            inv_count += mid - i + 1\n            j += 1\n        k += 1\n    while i <= mid:\n        temp_arr[k] = $P0[i]\n        i += 1\n        k += 1\n    while j <= right:\n        temp_arr[k] = $P0[j]\n        j += 1\n        k += 1\n    for i in range(left, right + 1):\n        $P0[i] = temp_arr[i]\n    return inv_count\ndef merge_sort_and_count($P0, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n        inv_count += merge_sort_and_count($P0, temp_arr, left, mid)\n        inv_count += merge_sort_and_count($P0, temp_arr, mid + 1, right)\n        inv_count += merge_count_split_inv($P0, temp_arr, left, mid, right)\n    return inv_count\ntemp_arr = [0] * len($P0)\nreturn merge_sort_and_count($P0, temp_arr, 0, len($P0) - 1)",
    "description": "count_inversions (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_determine_method_439": {
    "name": "stack_determine_method_439",
    "pattern_type": "general",
    "code_template": "inversions = count_inversions($P1)\nthreshold = 5 * $P0 * ($P0 - 1) // 4\nif inversions < threshold:\n    return 'Maria1'\nelse:\n    return 'Maria2'",
    "description": "determine_method (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_count_split_inv_440": {
    "name": "stack_merge_count_split_inv_440",
    "pattern_type": "general",
    "code_template": "i = $P2\nj = $P3 + 1\nk = $P2\ninv_count = 0\nwhile i <= $P3 and j <= $P4:\n    if $P0[i] <= $P0[j]:\n        $P1[k] = $P0[i]\n        i += 1\n    else:\n        $P1[k] = $P0[j]\n        inv_count += $P3 - i + 1\n        j += 1\n    k += 1\nwhile i <= $P3:\n    $P1[k] = $P0[i]\n    i += 1\n    k += 1\nwhile j <= $P4:\n    $P1[k] = $P0[j]\n    j += 1\n    k += 1\nfor i in range($P2, $P4 + 1):\n    $P0[i] = $P1[i]\nreturn inv_count",
    "description": "merge_count_split_inv (5 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_sort_and_count_441": {
    "name": "stack_merge_sort_and_count_441",
    "pattern_type": "algorithm",
    "code_template": "inv_count = 0\nif $P2 < $P3:\n    mid = ($P2 + $P3) // 2\n    inv_count += merge_sort_and_count($P0, $P1, $P2, mid)\n    inv_count += merge_sort_and_count($P0, $P1, mid + 1, $P3)\n    inv_count += merge_count_split_inv($P0, $P1, $P2, mid, $P3)\nreturn inv_count",
    "description": "merge_sort_and_count (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_push_442": {
    "name": "stack_push_442",
    "pattern_type": "general",
    "code_template": "if $P0.top >= $P0.capacity - 1:\n    print('Stack Overflow Error!')\n    return\n$P0.top += 1\n$P0.stack[$P0.top] = $P1\nprint(f'Pushed {$P1} to stack.')",
    "description": "push (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_pop_443": {
    "name": "stack_pop_443",
    "pattern_type": "general",
    "code_template": "if $P0.top == -1:\n    print('Stack Underflow Error!')\n    return None\npop_value = $P0.stack[$P0.top]\n$P0.stack[$P0.top] = None\n$P0.top -= 1\nprint(f'Popped {pop_value} from stack.')\nreturn pop_value",
    "description": "pop (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_display_444": {
    "name": "stack_display_444",
    "pattern_type": "general",
    "code_template": "if $P0.top == -1:\n    print('Stack is empty.')\nelse:\n    print('Current stack elements:', $P0.stack[:$P0.top + 1])",
    "description": "display (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_calculate_compound_interest_445": {
    "name": "stack_calculate_compound_interest_445",
    "pattern_type": "general",
    "code_template": "df = pd.read_csv($P0)\nprincipals = df['Principal'].to_numpy()\nrates = df['Rate'].to_numpy() / 100\ntimes = df['Time'].to_numpy()\nfuture_values = principals * (1 + rates) ** times\nresults_df = pd.DataFrame({'Principal': principals, 'Rate': rates * 100, 'Time': times, 'Future Value': future_values})\nprint(results_df)",
    "description": "calculate_compound_interest (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_max_subarray_sum_circular_446": {
    "name": "stack_max_subarray_sum_circular_446",
    "pattern_type": "list",
    "code_template": "n = len($P0)\nmax_sum = float('-inf')\ncurrent_sum = 0\nleft = 0\nfor right in range(2 * n):\n    current_sum += $P0[right % n]\n    if right - left + 1 > $P1:\n        current_sum -= $P0[left % n]\n        left += 1\n    if right - left + 1 == $P1:\n        max_sum = max(max_sum, current_sum)\nreturn max_sum",
    "description": "max_subarray_sum_circular (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_longestIncreasingSubsequence_447": {
    "name": "stack_longestIncreasingSubsequence_447",
    "pattern_type": "general",
    "code_template": "if not $P0:\n    return 0\nn = len($P0)\ndp = [1] * n\nfor i in range(1, n):\n    for j in range(i):\n        if $P0[j] < $P0[i]:\n            dp[i] = max(dp[i], dp[j] + 1)\nreturn max(dp)",
    "description": "longestIncreasingSubsequence (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_insert_448": {
    "name": "stack_insert_448",
    "pattern_type": "general",
    "code_template": "index = $P0._hash($P1)\nnew_node = Node($P1, $P2)\nif not $P0.table[index]:\n    $P0.table[index] = new_node\nelse:\n    current = $P0.table[index]\n    while current.next:\n        current = current.next\n    current.next = new_node",
    "description": "insert (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_search_449": {
    "name": "stack_search_449",
    "pattern_type": "algorithm",
    "code_template": "index = $P0._hash($P1)\ncurrent = $P0.table[index]\nwhile current:\n    if current.$P1 == $P1:\n        return current.value\n    current = current.next\nreturn None",
    "description": "search (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_echoPalindrome_450": {
    "name": "stack_echoPalindrome_450",
    "pattern_type": "general",
    "code_template": "from collections import Counter\ncount = Counter($P0)\nodd_count = sum((1 for freq in count.values() if freq % 2 != 0))\nif odd_count > 1:\n    return False\nreturn True",
    "description": "echoPalindrome (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_edge_451": {
    "name": "stack_add_edge_451",
    "pattern_type": "general",
    "code_template": "$P0.graph[$P1][$P2] = $P3",
    "description": "add_edge (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_floyd_warshall_452": {
    "name": "stack_floyd_warshall_452",
    "pattern_type": "general",
    "code_template": "dist = [row[:] for row in $P0.graph]\nfor k in range($P0.V):\n    for i in range($P0.V):\n        for j in range($P0.V):\n            if dist[i][j] > dist[i][k] + dist[k][j]:\n                dist[i][j] = dist[i][k] + dist[k][j]\nreturn dist",
    "description": "floyd_warshall (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_max_profit_453": {
    "name": "stack_max_profit_453",
    "pattern_type": "general",
    "code_template": "if not $P0:\n    return 0\nn = len($P0)\nprofit_one = [0] * n\nprofit_two = [0] * n\nmin_price = $P0[0]\nfor i in range(1, n):\n    min_price = min(min_price, $P0[i])\n    profit_one[i] = max(profit_one[i - 1], $P0[i] - min_price)\nmax_price = $P0[-1]\nfor i in range(n - 2, -1, -1):\n    max_price = max(max_price, $P0[i])\n    profit_two[i] = max(profit_two[i + 1], max_price - $P0[i] + profit_one[i])\nreturn max(profit_two)",
    "description": "max_profit (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_put_454": {
    "name": "stack_put_454",
    "pattern_type": "general",
    "code_template": "if $P0.head is None:\n    $P0.head = SingleListNode($P1, $P2)\nelse:\n    current = $P0.head\n    while current:\n        if current.$P1 == $P1:\n            current.$P2 = $P2\n            return\n        if current.next is None:\n            break\n        current = current.next\n    current.next = SingleListNode($P1, $P2)",
    "description": "put (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_update_455": {
    "name": "stack_update_455",
    "pattern_type": "general",
    "code_template": "current_value = $P0.data[$P1]\n$P0.data[$P1] += $P2\n$P1 += 1\nwhile $P1 <= $P0.size:\n    $P0.tree[$P1] += $P2\n    $P1 += $P1 & -$P1",
    "description": "update (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_query_456": {
    "name": "stack_query_456",
    "pattern_type": "general",
    "code_template": "total = 0\n$P1 += 1\nwhile $P1 > 0:\n    total += $P0.tree[$P1]\n    $P1 -= $P1 & -$P1\nreturn total",
    "description": "query (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_range_query_457": {
    "name": "stack_range_query_457",
    "pattern_type": "general",
    "code_template": "if $P1 > 0:\n    return $P0.query($P2) - $P0.query($P1 - 1)\nelse:\n    return $P0.query($P2)",
    "description": "range_query (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_construct_tree_458": {
    "name": "stack_construct_tree_458",
    "pattern_type": "string",
    "code_template": "if $P1 >= len($P0) or $P0[$P1] is None:\n    return None\nnode = TreeNode($P0[$P1])\nnode.left = construct_tree($P0, 2 * $P1 + 1)\nnode.right = construct_tree($P0, 2 * $P1 + 2)\nreturn node",
    "description": "construct_tree (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_healthy_tree_459": {
    "name": "stack_is_healthy_tree_459",
    "pattern_type": "general",
    "code_template": "if $P0 is None:\n    return (True, False)\nif $P0.left is None and $P0.right is None:\n    return (True, True)\n(left_healthy, left_has_leaf) = is_healthy_tree($P0.left)\n(right_healthy, right_has_leaf) = is_healthy_tree($P0.right)\nchildren_sum = 0\nif $P0.left:\n    children_sum += $P0.left.value\nif $P0.right:\n    children_sum += $P0.right.value\nis_healthy = $P0.value > children_sum and left_healthy and right_healthy\nhas_leaf = left_has_leaf or right_has_leaf\nreturn (is_healthy, has_leaf)",
    "description": "is_healthy_tree (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_check_tree_health_460": {
    "name": "stack_check_tree_health_460",
    "pattern_type": "general",
    "code_template": "root = construct_tree($P0)\n(is_healthy, has_leaf) = is_healthy_tree(root)\nif is_healthy and has_leaf:\n    return 'Healthy'\nelse:\n    return 'Unhealthy'",
    "description": "check_tree_health (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_461": {
    "name": "stack_dfs_461",
    "pattern_type": "general",
    "code_template": "$P2.append($P1)\nif $P1 not in $P0 or not $P0[$P1]:\n    if $P2[0] == $P2[-1]:\n        valid = True\n        for i in range(len($P2) - 1):\n            if abs(ord($P2[i]) - ord($P2[i + 1])) > 1:\n                valid = False\n                break\n        if valid:\n            $P3.append(list($P2))\nelse:\n    for child in $P0[$P1]:\n        dfs($P0, child, $P2, $P3)\n$P2.pop()",
    "description": "dfs (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_valid_paths_462": {
    "name": "stack_find_valid_paths_462",
    "pattern_type": "algorithm",
    "code_template": "result = []\ndfs($P0, $P1, [], result)\nreturn result",
    "description": "find_valid_paths (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_regex_wildcard_matching_463": {
    "name": "stack_regex_wildcard_matching_463",
    "pattern_type": "general",
    "code_template": "def wildcard_to_regex(pattern):\n    escaped_pattern = re.escape(pattern)\n    regex_pattern = '^' + escaped_pattern.replace('\\\\?', '.').replace('\\\\*', '.*') + '$'\n    return regex_pattern\nregex_patterns = [re.compile(wildcard_to_regex(pattern)) for pattern in $P1]\nmatched_strings = set()\nfor string in $P0:\n    for regex_pattern in regex_patterns:\n        if regex_pattern.match(string):\n            matched_strings.add(string)\n            break\nreturn list(matched_strings)",
    "description": "regex_wildcard_matching (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_wildcard_to_regex_464": {
    "name": "stack_wildcard_to_regex_464",
    "pattern_type": "general",
    "code_template": "escaped_pattern = re.escape($P0)\nregex_pattern = '^' + escaped_pattern.replace('\\\\?', '.').replace('\\\\*', '.*') + '$'\nreturn regex_pattern",
    "description": "wildcard_to_regex (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_shortest_path_dijkstra_465": {
    "name": "stack_shortest_path_dijkstra_465",
    "pattern_type": "string",
    "code_template": "min_heap = [(0, $P1)]\nshortest_paths = {$P1: (None, 0)}\nwhile min_heap:\n    (current_weight, current_node) = heapq.heappop(min_heap)\n    if current_node == $P2:\n        path = []\n        while current_node is not None:\n            path.insert(0, current_node)\n            current_node = shortest_paths[current_node][0]\n        return (path, current_weight)\n    for (neighbor, weight) in $P0[current_node]:\n        total_weight = current_weight + weight\n        if neighbor not in shortest_paths or total_weight < shortest_paths[neighbor][1]:\n            shortest_paths[neighbor] = (current_node, total_weight)\n            heapq.heappush(min_heap, (total_weight, neighbor))\nreturn (None, float('inf'))",
    "description": "shortest_path_dijkstra (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_insert_466": {
    "name": "stack_insert_466",
    "pattern_type": "general",
    "code_template": "$P1 = $P1.lower()\nnode = $P0.root\nfor char in $P1:\n    if char not in node.children:\n        node.children[char] = TrieNode()\n    node = node.children[char]\nnode.is_end_of_word = True",
    "description": "insert (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_split_message_467": {
    "name": "stack_split_message_467",
    "pattern_type": "general",
    "code_template": "if $P1 < 5:\n    return '\u9519\u8bef\uff1amax_length\u592a\u5c0f\uff0c\u65e0\u6cd5\u6dfb\u52a0\u540e\u7f00\u3002'\nn = 1\nsuffix_length = 5\nmax_content_length = $P1 - suffix_length\nwhile True:\n    n = (len($P0) + max_content_length - 1) // max_content_length\n    new_suffix_length = len(str(n)) * 2 + 3\n    if new_suffix_length == suffix_length:\n        break\n    suffix_length = new_suffix_length\n    max_content_length = $P1 - suffix_length\n    if max_content_length < 1:\n        return '\u9519\u8bef\uff1amax_length\u592a\u5c0f\uff0c\u65e0\u6cd5\u5206\u5272\u6d88\u606f\u3002'\nparts = []\nindex = 0\nfor i in range(1, n + 1):\n    part_length = min(max_content_length, len($P0) - index)\n    part = $P0[index:index + part_length]\n    parts.append(f'{part}({i}/{n})')\n    index += part_length\nreturn parts",
    "description": "split_message (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_valid_associations_468": {
    "name": "stack_find_valid_associations_468",
    "pattern_type": "algorithm",
    "code_template": "def backtrack(node, available_elements, current_association):\n    if node is None:\n        return [current_association.copy()]\n    valid_associations = []\n    for (i, element) in enumerate(available_elements):\n        current_association[node] = element\n        new_available_elements = available_elements[:i] + available_elements[i + 1:]\n        left_sum = calculate_subtree_sum(node.left, current_association)\n        right_sum = calculate_subtree_sum(node.right, current_association)\n        if left_sum <= right_sum:\n            valid_associations.extend(backtrack(node.left, new_available_elements, current_association))\n            valid_associations.extend(backtrack(node.right, new_available_elements, current_association))\n        del current_association[node]\n    return valid_associations\ndef calculate_subtree_sum(node, association):\n    if node is None:\n        return 0\n    return association.get(node, 0) + calculate_subtree_sum(node.left, association) + calculate_subtree_sum(node.right, association)\nreturn backtrack($P0, $P1, {})",
    "description": "find_valid_associations (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_backtrack_469": {
    "name": "stack_backtrack_469",
    "pattern_type": "general",
    "code_template": "if $P0 is None:\n    return [$P2.copy()]\nvalid_associations = []\nfor (i, element) in enumerate($P1):\n    $P2[$P0] = element\n    new_available_elements = $P1[:i] + $P1[i + 1:]\n    left_sum = calculate_subtree_sum($P0.left, $P2)\n    right_sum = calculate_subtree_sum($P0.right, $P2)\n    if left_sum <= right_sum:\n        valid_associations.extend(backtrack($P0.left, new_available_elements, $P2))\n        valid_associations.extend(backtrack($P0.right, new_available_elements, $P2))\n    del $P2[$P0]\nreturn valid_associations",
    "description": "backtrack (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_calculate_subtree_sum_470": {
    "name": "stack_calculate_subtree_sum_470",
    "pattern_type": "general",
    "code_template": "if $P0 is None:\n    return 0\nreturn $P1.get($P0, 0) + calculate_subtree_sum($P0.left, $P1) + calculate_subtree_sum($P0.right, $P1)",
    "description": "calculate_subtree_sum (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_count_ones_471": {
    "name": "stack_count_ones_471",
    "pattern_type": "general",
    "code_template": "count = 0\nwhile $P0:\n    $P0 = $P0 & $P0 - 1\n    count += 1\nreturn count",
    "description": "count_ones (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_minimum_theater_halls_472": {
    "name": "stack_minimum_theater_halls_472",
    "pattern_type": "general",
    "code_template": "time_slot_counts = [0] * 5\nfor schedule in $P1:\n    for i in range(5):\n        if schedule[i] == '1':\n            time_slot_counts[i] += 1\nreturn max(time_slot_counts)",
    "description": "minimum_theater_halls (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_process_transactions_473": {
    "name": "stack_process_transactions_473",
    "pattern_type": "general",
    "code_template": "valid_transactions = filter(lambda t: t.amount > 0, $P0)\namounts = map(lambda t: t.amount, valid_transactions)\ntotal_value = functools.reduce(lambda acc, amount: acc + amount, amounts, 0.0)\nreturn total_value",
    "description": "process_transactions (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_replace_placeholder_474": {
    "name": "stack_replace_placeholder_474",
    "pattern_type": "general",
    "code_template": "placeholder = $P0.group(1)\nif placeholder in values:\n    return str(values[placeholder])\nelse:\n    raise ValueError(f'\u7f3a\u5c11\u5360\u4f4d\u7b26\u7684\u503c: {placeholder}')",
    "description": "replace_placeholder (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_generate_subsets_475": {
    "name": "stack_generate_subsets_475",
    "pattern_type": "general",
    "code_template": "$P0.sort()\nresult = []\ndef backtrack(start, path):\n    result.append(path.copy())\n    for i in range(start, len($P0)):\n        path.append($P0[i])\n        backtrack(i + 1, path)\n        path.pop()\nbacktrack(0, [])\nreturn result",
    "description": "generate_subsets (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_backtrack_476": {
    "name": "stack_backtrack_476",
    "pattern_type": "general",
    "code_template": "result.append($P1.copy())\nfor i in range($P0, len(nums)):\n    $P1.append(nums[i])\n    backtrack(i + 1, $P1)\n    $P1.pop()",
    "description": "backtrack (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_has_opposite_rows_477": {
    "name": "stack_has_opposite_rows_477",
    "pattern_type": "general",
    "code_template": "if not $P0 or len($P0) < 2:\n    return '\u5426'\nseen_rows = set()\nfor row in $P0:\n    row_tuple = tuple(row)\n    opposite_row_tuple = tuple((-x for x in row))\n    if opposite_row_tuple in seen_rows:\n        return '\u662f'\n    seen_rows.add(row_tuple)\nreturn '\u5426'",
    "description": "has_opposite_rows (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_insert_478": {
    "name": "stack_insert_478",
    "pattern_type": "general",
    "code_template": "if not $P1:\n    return AVLNode($P2)\nelif $P2 < $P1.$P2:\n    $P1.left = $P0.insert($P1.left, $P2)\nelse:\n    $P1.right = $P0.insert($P1.right, $P2)\n$P1.height = 1 + max($P0.getHeight($P1.left), $P0.getHeight($P1.right))\nbalance = $P0.getBalance($P1)\nif balance > 1 and $P2 < $P1.left.$P2:\n    return $P0.rightRotate($P1)\nif balance < -1 and $P2 > $P1.right.$P2:\n    return $P0.leftRotate($P1)\nif balance > 1 and $P2 > $P1.left.$P2:\n    $P1.left = $P0.leftRotate($P1.left)\n    return $P0.rightRotate($P1)\nif balance < -1 and $P2 < $P1.right.$P2:\n    $P1.right = $P0.rightRotate($P1.right)\n    return $P0.leftRotate($P1)\nreturn $P1",
    "description": "insert (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_delete_479": {
    "name": "stack_delete_479",
    "pattern_type": "general",
    "code_template": "if not $P1:\n    return $P1\nelif $P2 < $P1.$P2:\n    $P1.left = $P0.delete($P1.left, $P2)\nelif $P2 > $P1.$P2:\n    $P1.right = $P0.delete($P1.right, $P2)\nelse:\n    if $P1.left is None:\n        temp = $P1.right\n        $P1 = None\n        return temp\n    elif $P1.right is None:\n        temp = $P1.left\n        $P1 = None\n        return temp\n    temp = $P0.getMinValueNode($P1.right)\n    $P1.$P2 = temp.$P2\n    $P1.right = $P0.delete($P1.right, temp.$P2)\nif $P1 is None:\n    return $P1\n$P1.height = 1 + max($P0.getHeight($P1.left), $P0.getHeight($P1.right))\nbalance = $P0.getBalance($P1)\nif balance > 1 and $P0.getBalance($P1.left) >= 0:\n    return $P0.rightRotate($P1)\nif balance > 1 and $P0.getBalance($P1.left) < 0:\n    $P1.left = $P0.leftRotate($P1.left)\n    return $P0.rightRotate($P1)\nif balance < -1 and $P0.getBalance($P1.right) <= 0:\n    return $P0.leftRotate($P1)\nif balance < -1 and $P0.getBalance($P1.right) > 0:\n    $P1.right = $P0.rightRotate($P1.right)\n    return $P0.leftRotate($P1)\nreturn $P1",
    "description": "delete (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_search_480": {
    "name": "stack_search_480",
    "pattern_type": "algorithm",
    "code_template": "if $P1 is None or $P1.$P2 == $P2:\n    return $P1\nif $P2 < $P1.$P2:\n    return $P0.search($P1.left, $P2)\nreturn $P0.search($P1.right, $P2)",
    "description": "search (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_481": {
    "name": "stack_merge_481",
    "pattern_type": "general",
    "code_template": "sorted_array = []\n(left_index, right_index) = (0, 0)\nwhile left_index < len($P0) and right_index < len($P1):\n    if $P0[left_index] < $P1[right_index]:\n        sorted_array.append($P0[left_index])\n        left_index += 1\n    else:\n        sorted_array.append($P1[right_index])\n        right_index += 1\nsorted_array.extend($P0[left_index:])\nsorted_array.extend($P1[right_index:])\nreturn sorted_array",
    "description": "merge (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_minimize_maximum_sum_482": {
    "name": "stack_minimize_maximum_sum_482",
    "pattern_type": "general",
    "code_template": "def can_divide(max_sum):\n    current_sum = 0\n    subarrays = 1\n    for weight in $P0:\n        if current_sum + weight > max_sum:\n            subarrays += 1\n            current_sum = weight\n            if subarrays > $P1:\n                return False\n        else:\n            current_sum += weight\n    return True\n(left, right) = (max($P0), sum($P0))\nwhile left < right:\n    mid = (left + right) // 2\n    if can_divide(mid):\n        right = mid\n    else:\n        left = mid + 1\nreturn left",
    "description": "minimize_maximum_sum (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_can_divide_483": {
    "name": "stack_can_divide_483",
    "pattern_type": "general",
    "code_template": "current_sum = 0\nsubarrays = 1\nfor weight in A:\n    if current_sum + weight > $P0:\n        subarrays += 1\n        current_sum = weight\n        if subarrays > k:\n            return False\n    else:\n        current_sum += weight\nreturn True",
    "description": "can_divide (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_calculate_letter_frequency_484": {
    "name": "stack_calculate_letter_frequency_484",
    "pattern_type": "general",
    "code_template": "return Counter($P0)",
    "description": "calculate_letter_frequency (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_build_graph_485": {
    "name": "stack_build_graph_485",
    "pattern_type": "general",
    "code_template": "graph = nx.DiGraph()\nfrequency_map = {}\nfor string in $P0:\n    freq = calculate_letter_frequency(string)\n    freq_tuple = tuple(sorted(freq.items()))\n    graph.add_node(string)\n    if freq_tuple in frequency_map:\n        for other_string in frequency_map[freq_tuple]:\n            graph.add_edge(string, other_string)\n            graph.add_edge(other_string, string)\n        frequency_map[freq_tuple].append(string)\n    else:\n        frequency_map[freq_tuple] = [string]\nreturn graph",
    "description": "build_graph (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_print_graph_486": {
    "name": "stack_print_graph_486",
    "pattern_type": "general",
    "code_template": "for node in $P0.nodes:\n    print(f'{node}: {list($P0.successors(node))}')",
    "description": "print_graph (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_permute_unique_487": {
    "name": "stack_permute_unique_487",
    "pattern_type": "general",
    "code_template": "def backtrack(start=0):\n    if start == len(arr):\n        permutations.add(''.join(arr))\n        return\n    for i in range(start, len(arr)):\n        (arr[start], arr[i]) = (arr[i], arr[start])\n        backtrack(start + 1)\n        (arr[start], arr[i]) = (arr[i], arr[start])\narr = list($P0)\npermutations = set()\nbacktrack()\nreturn permutations",
    "description": "permute_unique (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_backtrack_488": {
    "name": "stack_backtrack_488",
    "pattern_type": "general",
    "code_template": "if $P0 == len(arr):\n    permutations.add(''.join(arr))\n    return\nfor i in range($P0, len(arr)):\n    (arr[$P0], arr[i]) = (arr[i], arr[$P0])\n    backtrack($P0 + 1)\n    (arr[$P0], arr[i]) = (arr[i], arr[$P0])",
    "description": "backtrack (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_sum_of_odd_fibonacci_489": {
    "name": "stack_sum_of_odd_fibonacci_489",
    "pattern_type": "math",
    "code_template": "fibonacci_sequence = [0, 1]\nfor i in range(2, $P0):\n    next_fib = fibonacci_sequence[i - 1] + fibonacci_sequence[i - 2]\n    fibonacci_sequence.append(next_fib)\nodd_sum = 0\nfor num in fibonacci_sequence:\n    if num % 2 != 0:\n        odd_sum += num\nreturn odd_sum",
    "description": "sum_of_odd_fibonacci (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_isDiagonalNonZero_490": {
    "name": "stack_isDiagonalNonZero_490",
    "pattern_type": "general",
    "code_template": "n = len($P0)\nfor i in range(n):\n    if $P0[i][i] == 0:\n        return False\nreturn True",
    "description": "isDiagonalNonZero (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_run_491": {
    "name": "stack_run_491",
    "pattern_type": "general",
    "code_template": "filename = os.path.basename(urlparse($P0.url).path)\nfile_path = os.path.join($P0.dest_dir, filename)\ntry:\n    response = requests.get($P0.url, stream=True)\n    response.raise_for_status()\n    with open(file_path, 'wb') as file:\n        for chunk in response.iter_content(chunk_size=1024):\n            $P0._pause_event.wait()\n            if chunk:\n                file.write(chunk)\n    print(f'Finished downloading {filename}')\nexcept Exception as e:\n    print(f'An error occurred while downloading {$P0.url}: {e}')",
    "description": "run (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_pause_492": {
    "name": "stack_pause_492",
    "pattern_type": "general",
    "code_template": "$P0._pause_event.clear()",
    "description": "pause (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_resume_493": {
    "name": "stack_resume_493",
    "pattern_type": "general",
    "code_template": "$P0._pause_event.set()",
    "description": "resume (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_commonality_graph_494": {
    "name": "stack_commonality_graph_494",
    "pattern_type": "general",
    "code_template": "graph = {}\nfor array in $P0:\n    for i in range(len(array)):\n        for j in range(i + 1, len(array)):\n            (a, b) = (array[i], array[j])\n            if a not in graph:\n                graph[a] = []\n            if b not in graph[a]:\n                graph[a].append(b)\n            if b not in graph:\n                graph[b] = []\n            if a not in graph[b]:\n                graph[b].append(a)\nreturn graph",
    "description": "commonality_graph (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_max_nesting_depth_495": {
    "name": "stack_max_nesting_depth_495",
    "pattern_type": "general",
    "code_template": "current_depth = 0\nmax_depth = 0\nfor char in $P0:\n    if char == '(':\n        current_depth += 1\n        max_depth = max(max_depth, current_depth)\n    elif char == ')':\n        current_depth -= 1\nreturn max_depth",
    "description": "max_nesting_depth (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_graham_scan_convex_hull_496": {
    "name": "stack_graham_scan_convex_hull_496",
    "pattern_type": "general",
    "code_template": "$P0.sort(key=lambda x: (x[0], x[1]))\ndef cross(o, a, b):\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\nlower = []\nfor p in $P0:\n    while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n        lower.pop()\n    lower.append(p)\nupper = []\nfor p in reversed($P0):\n    while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n        upper.pop()\n    upper.append(p)\nreturn lower[:-1] + upper[:-1]",
    "description": "graham_scan_convex_hull (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_cross_497": {
    "name": "stack_cross_497",
    "pattern_type": "general",
    "code_template": "return ($P1[0] - $P0[0]) * ($P2[1] - $P0[1]) - ($P1[1] - $P0[1]) * ($P2[0] - $P0[0])",
    "description": "cross (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_reverse_iteratively_498": {
    "name": "stack_reverse_iteratively_498",
    "pattern_type": "general",
    "code_template": "current = $P0\ntemp = None\nwhile current:\n    temp = current.prev\n    current.prev = current.next\n    current.next = temp\n    current = current.prev\nif temp:\n    $P0 = temp.prev\nreturn $P0",
    "description": "reverse_iteratively (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_reverse_recursively_499": {
    "name": "stack_reverse_recursively_499",
    "pattern_type": "general",
    "code_template": "if not $P0:\n    return None\ntemp = $P0.next\n$P0.next = $P0.prev\n$P0.prev = temp\nif not $P0.prev:\n    return $P0\nreturn reverse_recursively($P0.prev)",
    "description": "reverse_recursively (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_reverseKGroup_500": {
    "name": "stack_reverseKGroup_500",
    "pattern_type": "general",
    "code_template": "def reverseLinkedList(start: ListNode, end: ListNode) -> ListNode:\n    \"\"\" Helper function to reverse the linked list from start to end \"\"\"\n    (prev, curr) = (None, start)\n    while curr != end:\n        next_node = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_node\n    return prev\ndummy = ListNode(0)\ndummy.next = $P0\ngroup_prev = dummy\nwhile True:\n    kth = group_prev\n    for i in range($P1):\n        kth = kth.next\n        if not kth:\n            return dummy.next\n    group_next = kth.next\n    (prev, curr) = (group_prev.next, group_prev.next.next)\n    for i in range($P1 - 1):\n        temp = curr.next\n        curr.next = prev\n        prev = curr\n        curr = temp\n    first_node = group_prev.next\n    group_prev.next = prev\n    first_node.next = group_next\n    group_prev = first_node",
    "description": "reverseKGroup (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_generate_symmetric_key_501": {
    "name": "stack_generate_symmetric_key_501",
    "pattern_type": "general",
    "code_template": "return os.urandom(32)",
    "description": "generate_symmetric_key (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_encrypt_data_502": {
    "name": "stack_encrypt_data_502",
    "pattern_type": "general",
    "code_template": "iv = os.urandom(16)\ncipher = Cipher(algorithms.AES($P1), modes.CFB(iv), backend=default_backend())\nencryptor = cipher.encryptor()\nreturn iv + encryptor.update($P0) + encryptor.finalize()",
    "description": "encrypt_data (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_generate_asymmetric_keys_503": {
    "name": "stack_generate_asymmetric_keys_503",
    "pattern_type": "general",
    "code_template": "private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048, backend=default_backend())\npublic_key = private_key.public_key()\nreturn (private_key, public_key)",
    "description": "generate_asymmetric_keys (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_encrypt_symmetric_key_504": {
    "name": "stack_encrypt_symmetric_key_504",
    "pattern_type": "general",
    "code_template": "return $P1.encrypt($P0, padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None))",
    "description": "encrypt_symmetric_key (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_insert_505": {
    "name": "stack_insert_505",
    "pattern_type": "general",
    "code_template": "if $P0.root is None:\n    $P0.root = Node($P1)\nelse:\n    $P0._insert_recursively($P0.root, $P1)",
    "description": "insert (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_character_frequency_in_range_506": {
    "name": "stack_character_frequency_in_range_506",
    "pattern_type": "general",
    "code_template": "if not 0 <= $P1 <= $P2 < len($P0):\n    raise ValueError('Invalid range specified.')\nfrequency = {}\nfor i in range($P1, $P2 + 1):\n    char = $P0[i]\n    if char in frequency:\n        frequency[char] += 1\n    else:\n        frequency[char] = 1\nreturn frequency",
    "description": "character_frequency_in_range (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_balanced_elements_507": {
    "name": "stack_find_balanced_elements_507",
    "pattern_type": "algorithm",
    "code_template": "balanced_elements = []\nfor i in range(len($P0)):\n    for j in range(len($P0[i])):\n        if (i + j) % $P1 == $P0[i][j]:\n            balanced_elements.append(($P0[i][j], i, j))\nreturn balanced_elements",
    "description": "find_balanced_elements (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_hash_password_508": {
    "name": "stack_hash_password_508",
    "pattern_type": "general",
    "code_template": "if not $P1:\n    $P1 = os.urandom(16)\npassword_bytes = $P0.encode('utf-8') + $P1\nhashed = hashlib.sha256(password_bytes).hexdigest()\nreturn (hashed, $P1)",
    "description": "hash_password (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_register_user_509": {
    "name": "stack_register_user_509",
    "pattern_type": "general",
    "code_template": "if $P0 in $P2:\n    print(f'User {$P0} already exists!')\n    return False\n(hashed_password, salt) = hash_password($P1)\n$P2[$P0] = {'$P1': hashed_password, 'salt': salt.hex()}\nprint(f'User {$P0} registered successfully.')\nreturn True",
    "description": "register_user (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_login_user_510": {
    "name": "stack_login_user_510",
    "pattern_type": "general",
    "code_template": "if $P0 not in $P2:\n    print('User does not exist!')\n    return False\nstored_data = $P2[$P0]\nstored_password = stored_data['$P1']\nstored_salt = bytes.fromhex(stored_data['salt'])\n(hashed_input_password, _) = hash_password($P1, stored_salt)\nif hashed_input_password == stored_password:\n    print('Login successful!')\n    return True\nelse:\n    print('Incorrect $P1!')\n    return False",
    "description": "login_user (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_save_user_db_511": {
    "name": "stack_save_user_db_511",
    "pattern_type": "general",
    "code_template": "with open($P1, 'w') as f:\n    json.dump($P0, f)",
    "description": "save_user_db (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_load_user_db_512": {
    "name": "stack_load_user_db_512",
    "pattern_type": "general",
    "code_template": "try:\n    with open($P0, 'r') as f:\n        return json.load(f)\nexcept FileNotFoundError:\n    return {}",
    "description": "load_user_db (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_edit_distance_513": {
    "name": "stack_edit_distance_513",
    "pattern_type": "general",
    "code_template": "(m, n) = (len($P0), len($P1))\ndp = [[0] * (n + 1) for _ in range(m + 1)]\nfor i in range(m + 1):\n    dp[i][0] = i\nfor j in range(n + 1):\n    dp[0][j] = j\nfor i in range(1, m + 1):\n    for j in range(1, n + 1):\n        if $P0[i - 1] == $P1[j - 1]:\n            dp[i][j] = dp[i - 1][j - 1]\n        else:\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1)\n(i, j) = (m, n)\nsteps = []\nwhile i > 0 or j > 0:\n    if i > 0 and j > 0 and ($P0[i - 1] == $P1[j - 1]):\n        (i, j) = (i - 1, j - 1)\n    elif i > 0 and j > 0 and (dp[i][j] == dp[i - 1][j - 1] + 1):\n        steps.append(f'Replace {$P0[i - 1]} with {$P1[j - 1]} at position {i - 1}')\n        (i, j) = (i - 1, j - 1)\n    elif i > 0 and dp[i][j] == dp[i - 1][j] + 1:\n        steps.append(f'Delete {$P0[i - 1]} from position {i - 1}')\n        i -= 1\n    elif j > 0 and dp[i][j] == dp[i][j - 1] + 1:\n        steps.append(f'Insert {$P1[j - 1]} at position {i}')\n        j -= 1\nsteps.reverse()\nreturn (dp[m][n], steps)",
    "description": "edit_distance (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_reverse_list_recursive_514": {
    "name": "stack_reverse_list_recursive_514",
    "pattern_type": "list",
    "code_template": "if not $P0 or not $P0.next:\n    return $P0\nreversed_head = reverse_list_recursive($P0.next)\n$P0.next.next = $P0\n$P0.next = None\nreturn reversed_head",
    "description": "reverse_list_recursive (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_generate_sensor_data_515": {
    "name": "stack_generate_sensor_data_515",
    "pattern_type": "general",
    "code_template": "temperature = 20 + random.normalvariate(0, 0.5)\ndistance = 100 + random.normalvariate(0, 1)\nreturn (temperature, distance)",
    "description": "generate_sensor_data (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_process_sensor_data_516": {
    "name": "stack_process_sensor_data_516",
    "pattern_type": "general",
    "code_template": "if len($P0) >= 60:\n    $P0.popleft()\n$P0.append($P1)\navg_temperature = np.mean([data[0] for data in $P0])\navg_distance = np.mean([data[1] for data in $P0])\nreturn (avg_temperature, avg_distance)",
    "description": "process_sensor_data (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_main_517": {
    "name": "stack_main_517",
    "pattern_type": "general",
    "code_template": "temperature_queue = deque()\ndistance_queue = deque()\navg_temperatures = []\navg_distances = []\nfor _ in range(120):\n    new_data = generate_sensor_data()\n    (avg_temp, avg_dist) = process_sensor_data(zip(temperature_queue, distance_queue), new_data)\n    avg_temperatures.append(avg_temp)\n    avg_distances.append(avg_dist)\nplot_data(avg_temperatures, avg_distances)",
    "description": "main (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_quicksort_lomuto_518": {
    "name": "stack_quicksort_lomuto_518",
    "pattern_type": "algorithm",
    "code_template": "if $P1 < $P2:\n    pi = partition_lomuto($P0, $P1, $P2)\n    quicksort_lomuto($P0, $P1, pi - 1)\n    quicksort_lomuto($P0, pi + 1, $P2)",
    "description": "quicksort_lomuto (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_partition_lomuto_519": {
    "name": "stack_partition_lomuto_519",
    "pattern_type": "general",
    "code_template": "pivot = $P0[$P2]\ni = $P1 - 1\nfor j in range($P1, $P2):\n    if $P0[j] <= pivot:\n        i += 1\n        ($P0[i], $P0[j]) = ($P0[j], $P0[i])\n($P0[i + 1], $P0[$P2]) = ($P0[$P2], $P0[i + 1])\nreturn i + 1",
    "description": "partition_lomuto (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_quicksort_hoare_520": {
    "name": "stack_quicksort_hoare_520",
    "pattern_type": "algorithm",
    "code_template": "if $P1 < $P2:\n    pi = partition_hoare($P0, $P1, $P2)\n    quicksort_hoare($P0, $P1, pi)\n    quicksort_hoare($P0, pi + 1, $P2)",
    "description": "quicksort_hoare (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_partition_hoare_521": {
    "name": "stack_partition_hoare_521",
    "pattern_type": "general",
    "code_template": "pivot = $P0[$P1]\ni = $P1 - 1\nj = $P2 + 1\nwhile True:\n    i += 1\n    while $P0[i] < pivot:\n        i += 1\n    j -= 1\n    while $P0[j] > pivot:\n        j -= 1\n    if i >= j:\n        return j\n    ($P0[i], $P0[j]) = ($P0[j], $P0[i])",
    "description": "partition_hoare (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_on_epoch_end_522": {
    "name": "stack_on_epoch_end_522",
    "pattern_type": "general",
    "code_template": "print(f\"Epoch {$P1 + 1}, Loss: {$P2['loss']:.4f}\")",
    "description": "on_epoch_end (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_reduce_matrix_523": {
    "name": "stack_reduce_matrix_523",
    "pattern_type": "general",
    "code_template": "n = len($P0)\nparticipants = set(range(n))\ndef has_participation(index):\n    return any(($P0[index][j] for j in participants)) or any(($P0[i][index] for i in participants))\nwhile True:\n    to_remove = set((i for i in participants if not has_participation(i)))\n    if not to_remove:\n        break\n    participants.difference_update(to_remove)\nreturn [[$P0[i][j] for j in participants] for i in participants]",
    "description": "reduce_matrix (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_has_participation_524": {
    "name": "stack_has_participation_524",
    "pattern_type": "general",
    "code_template": "return any((matrix[$P0][j] for j in participants)) or any((matrix[i][$P0] for i in participants))",
    "description": "has_participation (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_insert_525": {
    "name": "stack_insert_525",
    "pattern_type": "general",
    "code_template": "new_node = SinglyNode($P1)\nif $P0.head is None:\n    $P0.head = new_node\nelse:\n    current = $P0.head\n    while current.next:\n        current = current.next\n    current.next = new_node",
    "description": "insert (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_generate_id_526": {
    "name": "stack_generate_id_526",
    "pattern_type": "general",
    "code_template": "return len(tasks) + 1",
    "description": "generate_id (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_create_task_527": {
    "name": "stack_create_task_527",
    "pattern_type": "general",
    "code_template": "if not request.json or 'title' not in request.json:\n    abort(400)\ntask = {'id': generate_id(), 'title': request.json['title'], 'description': request.json.get('description', ''), 'done': False}\ntasks.append(task)\nreturn (jsonify({'task': task}), 201)",
    "description": "create_task (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_tasks_528": {
    "name": "stack_get_tasks_528",
    "pattern_type": "general",
    "code_template": "return jsonify({'tasks': tasks})",
    "description": "get_tasks (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_update_task_529": {
    "name": "stack_update_task_529",
    "pattern_type": "general",
    "code_template": "task = next((t for t in tasks if t['id'] == $P0), None)\nif task is None:\n    abort(404)\nif not request.json:\n    abort(400)\ntask['title'] = request.json.get('title', task['title'])\ntask['description'] = request.json.get('description', task['description'])\ntask['done'] = request.json.get('done', task['done'])\nreturn jsonify({'task': task})",
    "description": "update_task (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_delete_task_530": {
    "name": "stack_delete_task_530",
    "pattern_type": "general",
    "code_template": "global tasks\ntasks = [task for task in tasks if task['id'] != $P0]\nreturn jsonify({'result': 'Task deleted'})",
    "description": "delete_task (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_frequency_sort_531": {
    "name": "stack_frequency_sort_531",
    "pattern_type": "algorithm",
    "code_template": "frequency = Counter($P0)\nfreq_list = [(element, freq) for (element, freq) in frequency.items()]\nfreq_list.sort(key=lambda x: (x[1], x[0]))\nresult = []\nfor (element, freq) in freq_list:\n    result.extend([element] * freq)\nreturn result",
    "description": "frequency_sort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_random_walk_532": {
    "name": "stack_random_walk_532",
    "pattern_type": "general",
    "code_template": "visits = {node: 0 for node in $P0}\ncurrent_node = $P1\nvisits[current_node] += 1\nfor step in range($P2):\n    if $P0[current_node]:\n        current_node = random.choice($P0[current_node])\n        visits[current_node] += 1\nreturn visits",
    "description": "random_walk (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_knapsack_533": {
    "name": "stack_knapsack_533",
    "pattern_type": "general",
    "code_template": "n = len($P0)\ndp = [[0 for _ in range($P2 + 1)] for _ in range(n + 1)]\nfor i in range(1, n + 1):\n    for w in range($P2 + 1):\n        if $P1[i - 1] <= w:\n            dp[i][w] = max(dp[i - 1][w], $P0[i - 1] + dp[i - 1][w - $P1[i - 1]])\n        else:\n            dp[i][w] = dp[i - 1][w]\nreturn dp[n][$P2]",
    "description": "knapsack (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_handle_collisions_534": {
    "name": "stack_handle_collisions_534",
    "pattern_type": "general",
    "code_template": "hits = pygame.sprite.spritecollide($P0, $P1, False)\nif hits:\n    $P0.vel_y = 0\n    $P0.rect.bottom = hits[0].rect.top",
    "description": "handle_collisions (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_update_535": {
    "name": "stack_update_535",
    "pattern_type": "general",
    "code_template": "$P0.vel_y += $P0.gravity\n$P0.rect.y += $P0.vel_y\nkeys = pygame.key.get_pressed()\nif keys[pygame.K_LEFT]:\n    $P0.rect.x -= 5\nif keys[pygame.K_RIGHT]:\n    $P0.rect.x += 5\nif keys[pygame.K_SPACE]:\n    $P0.jump()\nif $P0.rect.bottom >= SCREEN_HEIGHT:\n    $P0.rect.bottom = SCREEN_HEIGHT\n    $P0.vel_y = 0",
    "description": "update (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_jump_536": {
    "name": "stack_jump_536",
    "pattern_type": "general",
    "code_template": "if $P0.rect.bottom == SCREEN_HEIGHT:\n    $P0.vel_y = -$P0.jump_power",
    "description": "jump (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_reverse_words_in_sentence_537": {
    "name": "stack_reverse_words_in_sentence_537",
    "pattern_type": "general",
    "code_template": "components = re.findall('[\\\\w\\']+|[.,!?;\\\\\"\u2026]', $P0)\nwords = [comp for comp in components if re.match(\"[\\\\w']+\", comp)]\nword_indices = [i for (i, comp) in enumerate(components) if re.match(\"[\\\\w']+\", comp)]\nwords_reversed = words[::-1]\nresult = []\nword_pointer = 0\nfor (i, comp) in enumerate(components):\n    if i in word_indices:\n        result.append(words_reversed[word_pointer])\n        word_pointer += 1\n    else:\n        result.append(comp)\nreturn ''.join(result)",
    "description": "reverse_words_in_sentence (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_calculate_average_offsets_538": {
    "name": "stack_calculate_average_offsets_538",
    "pattern_type": "general",
    "code_template": "total_offset = 0\nnum_tasks = len($P1)\nfor task in $P1:\n    (time_zone_index, task_index) = task\n    task_index -= 1\n    time_offset = $P0[time_zone_index][task_index]\n    total_offset += time_offset\naverage_offset = total_offset / num_tasks if num_tasks > 0 else 0\nreturn average_offset",
    "description": "calculate_average_offsets (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_split_539": {
    "name": "stack_split_539",
    "pattern_type": "general",
    "code_template": "slow = $P0\nfast = $P0\nprev = None\nwhile fast and fast.next:\n    prev = slow\n    slow = slow.next\n    fast = fast.next.next\nprev.next = None\nreturn ($P0, slow)",
    "description": "split (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_540": {
    "name": "stack_merge_540",
    "pattern_type": "general",
    "code_template": "dummy = ListNode(0)\ntail = dummy\nwhile $P0 and $P1:\n    if $P0.value < $P1.value:\n        tail.next = $P0\n        $P0 = $P0.next\n    else:\n        tail.next = $P1\n        $P1 = $P1.next\n    tail = tail.next\nif $P0:\n    tail.next = $P0\nif $P1:\n    tail.next = $P1\nreturn dummy.next",
    "description": "merge (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_encrypt_file_541": {
    "name": "stack_encrypt_file_541",
    "pattern_type": "general",
    "code_template": "with open($P0, 'rb') as f:\n    plaintext = f.read()\ncipher = Cipher(algorithms.AES($P1), modes.CBC($P2), backend=default_backend())\nencryptor = cipher.encryptor()\npadder = sym_padding.PKCS7(algorithms.AES.block_size).padder()\npadded_plaintext = padder.update(plaintext) + padder.finalize()\nciphertext = encryptor.update(padded_plaintext) + encryptor.finalize()\nreturn ciphertext",
    "description": "encrypt_file (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_encrypt_aes_key_542": {
    "name": "stack_encrypt_aes_key_542",
    "pattern_type": "general",
    "code_template": "encrypted_aes_key = $P1.encrypt($P0, padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None))\nreturn encrypted_aes_key",
    "description": "encrypt_aes_key (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_decrypt_aes_key_543": {
    "name": "stack_decrypt_aes_key_543",
    "pattern_type": "general",
    "code_template": "decrypted_aes_key = $P1.decrypt($P0, padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None))\nreturn decrypted_aes_key",
    "description": "decrypt_aes_key (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_decrypt_file_544": {
    "name": "stack_decrypt_file_544",
    "pattern_type": "general",
    "code_template": "cipher = Cipher(algorithms.AES($P1), modes.CBC($P2), backend=default_backend())\ndecryptor = cipher.decryptor()\npadded_plaintext = decryptor.update($P0) + decryptor.finalize()\nunpadder = sym_padding.PKCS7(algorithms.AES.block_size).unpadder()\nplaintext = unpadder.update(padded_plaintext) + unpadder.finalize()\nreturn plaintext",
    "description": "decrypt_file (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_parse_timestamp_545": {
    "name": "stack_parse_timestamp_545",
    "pattern_type": "string",
    "code_template": "return datetime.strptime($P0, '%Y-%m-%d %H:%M:%S')",
    "description": "parse_timestamp (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_monitor_servers_546": {
    "name": "stack_monitor_servers_546",
    "pattern_type": "general",
    "code_template": "server_logs = defaultdict(list)\nfor change in $P0:\n    (server_id, timestamp, status) = change\n    server_logs[server_id].append((parse_timestamp(timestamp), status))\nactive_servers = []\nfor (server_id, logs) in server_logs.items():\n    logs.sort()\n    change_count = 0\n    start_time = None\n    for i in range(1, len(logs)):\n        (current_time, current_status) = logs[i]\n        (previous_time, previous_status) = logs[i - 1]\n        if current_status != previous_status:\n            if start_time is None:\n                start_time = previous_time\n            time_diff = (current_time - start_time).total_seconds() / 60\n            if time_diff <= $P1:\n                change_count += 1\n            else:\n                change_count = 1\n                start_time = previous_time\n            if change_count >= $P2:\n                active_servers.append(server_id)\n                break\nreturn active_servers",
    "description": "monitor_servers (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_longest_common_subsequence_547": {
    "name": "stack_longest_common_subsequence_547",
    "pattern_type": "general",
    "code_template": "n = len($P0)\nm = len($P1)\ndp = [[0] * (m + 1) for _ in range(n + 1)]\nfor i in range(1, n + 1):\n    for j in range(1, m + 1):\n        if $P0[i - 1] == $P1[j - 1]:\n            dp[i][j] = dp[i - 1][j - 1] + 1\n        else:\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\nreturn dp[n][m]",
    "description": "longest_common_subsequence (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_topologicalSort_548": {
    "name": "stack_topologicalSort_548",
    "pattern_type": "algorithm",
    "code_template": "UNVISITED = 0\nVISITING = 1\nVISITED = 2\nvisit_state = {node: UNVISITED for node in $P0}\ntopological_order = []\ndef dfs(node: int) -> bool:\n    \"\"\"Perform DFS from the given node, returns False if a cycle is detected.\"\"\"\n    if visit_state[node] == VISITING:\n        return False\n    if visit_state[node] == UNVISITED:\n        visit_state[node] = VISITING\n        for neighbor in $P0[node]:\n            if not dfs(neighbor):\n                return False\n        visit_state[node] = VISITED\n        topological_order.append(node)\n    return True\nfor node in $P0:\n    if visit_state[node] == UNVISITED:\n        if not dfs(node):\n            raise ValueError('Graph contains a cycle, topological sort not possible.')\nreturn topological_order[::-1]",
    "description": "topologicalSort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_bubble_sort_steps_549": {
    "name": "stack_bubble_sort_steps_549",
    "pattern_type": "algorithm",
    "code_template": "steps = []\nn = len($P0)\nfor i in range(n):\n    for j in range(0, n - i - 1):\n        if $P0[j] > $P0[j + 1]:\n            ($P0[j], $P0[j + 1]) = ($P0[j + 1], $P0[j])\n        steps.append($P0.copy())\nreturn steps",
    "description": "bubble_sort_steps (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_DFS_550": {
    "name": "stack_DFS_550",
    "pattern_type": "general",
    "code_template": "visited = set()\nstack = [$P1]\nresult = []\nwhile stack:\n    node = stack.pop()\n    if node not in visited:\n        visited.add(node)\n        result.append(node)\n        for neighbor in $P0[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\nreturn result",
    "description": "DFS (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_insert_551": {
    "name": "stack_insert_551",
    "pattern_type": "general",
    "code_template": "$P0.heap.append($P1)\n$P0._bubble_up(len($P0.heap) - 1)",
    "description": "insert (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_extract_min_552": {
    "name": "stack_extract_min_552",
    "pattern_type": "general",
    "code_template": "if not $P0.heap:\n    return None\n$P0._swap(0, len($P0.heap) - 1)\nmin_element = $P0.heap.pop()\n$P0._heapify(0)\nreturn min_element",
    "description": "extract_min (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_areAnagrams_553": {
    "name": "stack_areAnagrams_553",
    "pattern_type": "general",
    "code_template": "$P0 = $P0.replace(' ', '').lower()\n$P1 = $P1.replace(' ', '').lower()\nif len($P0) != len($P1):\n    return False\nfrom collections import Counter\ncount1 = Counter($P0)\ncount2 = Counter($P1)\nreturn count1 == count2",
    "description": "areAnagrams (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_game_loop_554": {
    "name": "stack_game_loop_554",
    "pattern_type": "general",
    "code_template": "engine = GameEngine(ground_y=500)\nengine.add_object(GameObject(x=100, y=100, width=50, height=50))\nlast_time = time.time()\ntry:\n    while True:\n        current_time = time.time()\n        delta_time = current_time - last_time\n        last_time = current_time\n        engine.update(delta_time)\n        engine.render()\n        time.sleep(0.016)\nexcept KeyboardInterrupt:\n    print('Game loop terminated.')",
    "description": "game_loop (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_apply_gravity_555": {
    "name": "stack_apply_gravity_555",
    "pattern_type": "general",
    "code_template": "if not $P0.on_ground:\n    $P0.velocity_y += $P1 * $P2\n$P0.y += $P0.velocity_y * $P2",
    "description": "apply_gravity (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_check_collision_556": {
    "name": "stack_check_collision_556",
    "pattern_type": "general",
    "code_template": "if $P0.y + $P0.height > $P1:\n    $P0.y = $P1 - $P0.height\n    $P0.velocity_y *= -$P2\n    $P0.on_ground = True\nelse:\n    $P0.on_ground = False",
    "description": "check_collision (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_height_557": {
    "name": "stack_get_height_557",
    "pattern_type": "general",
    "code_template": "return $P1.height if $P1 else 0",
    "description": "get_height (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_update_height_558": {
    "name": "stack_update_height_558",
    "pattern_type": "general",
    "code_template": "$P1.height = 1 + max($P0.get_height($P1.left), $P0.get_height($P1.right))",
    "description": "update_height (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_balance_559": {
    "name": "stack_get_balance_559",
    "pattern_type": "general",
    "code_template": "return $P0.get_height($P1.left) - $P0.get_height($P1.right)",
    "description": "get_balance (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_test_rencontres_number_560": {
    "name": "stack_test_rencontres_number_560",
    "pattern_type": "general",
    "code_template": "assert rencontres_number(0, 0) == 1, 'Test case for n = 0, k = 0 failed'\nassert rencontres_number(3, 4) == 0, 'Test case for n = 3, k = 4 failed'\nassert rencontres_number(4, 0) == 9, 'Test case for n = 4, k = 0 failed'\nassert rencontres_number(4, 1) == 6, 'Test case for n = 4, k = 1 failed'\nassert rencontres_number(4, 2) == 3, 'Test case for n = 4, k = 2 failed'\nassert rencontres_number(4, 3) == 1, 'Test case for n = 4, k = 3 failed'\nassert rencontres_number(4, 4) == 1, 'Test case for n = 4, k = 4 failed'\nprint('All test cases passed!')",
    "description": "test_rencontres_number (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_rencontres_number_561": {
    "name": "stack_rencontres_number_561",
    "pattern_type": "general",
    "code_template": "if $P1 > $P0:\n    return 0\nif $P0 == 0:\n    return 1\nrencontres_values = {(0, 0): 1, (3, 4): 0, (4, 0): 9, (4, 1): 6, (4, 2): 3, (4, 3): 1, (4, 4): 1}\nreturn rencontres_values.get(($P0, $P1), 0)",
    "description": "rencontres_number (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_current_token_562": {
    "name": "stack_current_token_562",
    "pattern_type": "general",
    "code_template": "if $P0.current_token_index < len($P0.tokens):\n    return $P0.tokens[$P0.current_token_index]\nelse:\n    return None",
    "description": "current_token (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_heap_sort_k_563": {
    "name": "stack_heap_sort_k_563",
    "pattern_type": "algorithm",
    "code_template": "if $P1 == 0:\n    return []\nmin_heap = []\nfor num in $P0:\n    if len(min_heap) < $P1:\n        heapq.heappush(min_heap, num)\n    elif num > min_heap[0]:\n        heapq.heappushpop(min_heap, num)\nlargest_k = sorted(min_heap, reverse=True)\nremaining_elements = [num for num in $P0 if num not in largest_k]\nreturn largest_k + remaining_elements",
    "description": "heap_sort_k (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_run_length_encode_564": {
    "name": "stack_run_length_encode_564",
    "pattern_type": "general",
    "code_template": "with open($P0, 'r') as file:\n    original_text = file.read()\ndef rle_encode(text):\n    encoded_parts = []\n    for (char, group) in itertools.groupby(text):\n        count = sum((1 for _ in group))\n        encoded_parts.append(f'{count}{char}')\n    return ''.join(encoded_parts)\nencoded_text = rle_encode(original_text)\nwith open($P1, 'w') as file:\n    file.write(encoded_text)\noriginal_size = len(original_text)\nencoded_size = len(encoded_text)\ncompression_efficiency = encoded_size / original_size if original_size > 0 else 0\nreturn (encoded_text, compression_efficiency)",
    "description": "run_length_encode (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_rle_encode_565": {
    "name": "stack_rle_encode_565",
    "pattern_type": "general",
    "code_template": "encoded_parts = []\nfor (char, group) in itertools.groupby($P0):\n    count = sum((1 for _ in group))\n    encoded_parts.append(f'{count}{char}')\nreturn ''.join(encoded_parts)",
    "description": "rle_encode (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_max_distinct_profit_566": {
    "name": "stack_max_distinct_profit_566",
    "pattern_type": "general",
    "code_template": "if not $P0:\n    return 0\ndistinct_elements = set()\nstart = 0\nmax_profit = 0\ncurrent_profit = 0\nfor end in range(len($P0)):\n    while $P0[end] in distinct_elements:\n        distinct_elements.remove($P0[start])\n        current_profit -= $P0[start]\n        start += 1\n    distinct_elements.add($P0[end])\n    current_profit += $P0[end]\n    max_profit = max(max_profit, current_profit)\nreturn max_profit",
    "description": "max_distinct_profit (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_split_by_char_567": {
    "name": "stack_split_by_char_567",
    "pattern_type": "general",
    "code_template": "if not $P0:\n    raise ValueError('String cannot be empty')\nreturn [char for char in $P0]",
    "description": "split_by_char (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_optimized_parity_sum_568": {
    "name": "stack_optimized_parity_sum_568",
    "pattern_type": "general",
    "code_template": "if not $P0 or not $P1:\n    return 0\nevens1 = [x for x in $P0 if x % 2 == 0]\nodds1 = [x for x in $P0 if x % 2 != 0]\nevens2 = [x for x in $P1 if x % 2 == 0]\nodds2 = [x for x in $P1 if x % 2 != 0]\nmax_sum = 0\nif evens1 and odds2:\n    max_sum = max(max_sum, max(evens1) + max(odds2))\nif odds1 and evens2:\n    max_sum = max(max_sum, max(odds1) + max(evens2))\nreturn max_sum",
    "description": "optimized_parity_sum (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_countSubarrays_569": {
    "name": "stack_countSubarrays_569",
    "pattern_type": "list",
    "code_template": "left = 0\ncount = 0\nfreq = defaultdict(int)\nfor right in range(len($P0)):\n    freq[$P0[right]] += 1\n    while max(freq.values()) > $P1:\n        freq[$P0[left]] -= 1\n        if freq[$P0[left]] == 0:\n            del freq[$P0[left]]\n        left += 1\n    count += right - left + 1\nreturn count",
    "description": "countSubarrays (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_generate_names_570": {
    "name": "stack_generate_names_570",
    "pattern_type": "general",
    "code_template": "base_names = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']\nnames = [base_names[i % len(base_names)] + str(i // len(base_names)) for i in range($P0)]\nfor i in range($P0 - $P1 + 1):\n    if $P2[i] == 'BAD':\n        names[i + $P1 - 1] = names[i]\nreturn names",
    "description": "generate_names (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_on_status_571": {
    "name": "stack_on_status_571",
    "pattern_type": "general",
    "code_template": "producer.send('twitter-feed', value=$P1.text.encode('utf-8'))",
    "description": "on_status (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_fibonacci_memo_572": {
    "name": "stack_fibonacci_memo_572",
    "pattern_type": "math",
    "code_template": "if $P0 in $P1:\n    return $P1[$P0]\nif $P0 <= 1:\n    return $P0\n$P1[$P0] = fibonacci_memo($P0 - 1, $P1) + fibonacci_memo($P0 - 2, $P1)\nreturn $P1[$P0]",
    "description": "fibonacci_memo (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_fibonacci_iterative_573": {
    "name": "stack_fibonacci_iterative_573",
    "pattern_type": "math",
    "code_template": "if $P0 <= 1:\n    return $P0\n(prev, curr) = (0, 1)\nfor _ in range(2, $P0 + 1):\n    (prev, curr) = (curr, prev + curr)\nreturn curr",
    "description": "fibonacci_iterative (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_manage_gems_574": {
    "name": "stack_manage_gems_574",
    "pattern_type": "general",
    "code_template": "gems = []\nfor action in $P0:\n    if isinstance(action, int) and action > 0:\n        gems.append(action)\n    elif action == 'prev':\n        if gems:\n            gems.pop()\nreturn gems",
    "description": "manage_gems (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_main_575": {
    "name": "stack_main_575",
    "pattern_type": "general",
    "code_template": "posts_data = [{'title': 'My First Blog Post', 'author': 'John Doe', 'date': '2023-10-01', 'content': \"<p>This is the content of my first blog post. It's amazing!</p>\"}, {'title': 'Learning Python', 'author': 'Jane Smith', 'date': '2023-10-15', 'content': '<p>Python is a versatile language that you can use on the backend, frontend, or full stack.</p>'}]\nhtml_content = generate_blog_html(posts_data)\nwrite_html_file('BlogPosts.html', html_content)",
    "description": "main (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_576": {
    "name": "stack_merge_576",
    "pattern_type": "general",
    "code_template": "sorted_array = []\nleft_index = right_index = 0\nwhile left_index < len($P0) and right_index < len($P1):\n    if $P0[left_index] <= $P1[right_index]:\n        sorted_array.append($P0[left_index])\n        left_index += 1\n    else:\n        sorted_array.append($P1[right_index])\n        right_index += 1\nwhile left_index < len($P0):\n    sorted_array.append($P0[left_index])\n    left_index += 1\nwhile right_index < len($P1):\n    sorted_array.append($P1[right_index])\n    right_index += 1\nreturn sorted_array",
    "description": "merge (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_creative_insertion_577": {
    "name": "stack_creative_insertion_577",
    "pattern_type": "general",
    "code_template": "def has_repeated_pattern(sub):\n    n = len(sub)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            if sub[:i] * (n // i) == sub:\n                return True\n    return False\nexisting_numbers = set((int(char) for char in $P0))\nsmallest_missing = 1\nwhile smallest_missing in existing_numbers:\n    smallest_missing += 1\nsmallest_missing_str = str(smallest_missing)\nfor i in range(len($P0) + 1):\n    new_s = $P0[:i] + smallest_missing_str + $P0[i:]\n    valid = True\n    for j in range(len(new_s) - $P1 + 1):\n        if has_repeated_pattern(new_s[j:j + $P1]):\n            valid = False\n            break\n    if valid:\n        return new_s\nreturn $P0",
    "description": "creative_insertion (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_has_repeated_pattern_578": {
    "name": "stack_has_repeated_pattern_578",
    "pattern_type": "general",
    "code_template": "n = len($P0)\nfor i in range(1, n // 2 + 1):\n    if n % i == 0:\n        if $P0[:i] * (n // i) == $P0:\n            return True\nreturn False",
    "description": "has_repeated_pattern (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_height_579": {
    "name": "stack_get_height_579",
    "pattern_type": "general",
    "code_template": "if not $P0:\n    return 0\nreturn $P0.height",
    "description": "get_height (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_balance_580": {
    "name": "stack_get_balance_580",
    "pattern_type": "general",
    "code_template": "if not $P0:\n    return 0\nreturn get_height($P0.left) - get_height($P0.right)",
    "description": "get_balance (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_right_rotate_581": {
    "name": "stack_right_rotate_581",
    "pattern_type": "general",
    "code_template": "x = $P0.left\nT2 = x.right\nx.right = $P0\n$P0.left = T2\n$P0.height = max(get_height($P0.left), get_height($P0.right)) + 1\nx.height = max(get_height(x.left), get_height(x.right)) + 1\nreturn x",
    "description": "right_rotate (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_left_rotate_582": {
    "name": "stack_left_rotate_582",
    "pattern_type": "general",
    "code_template": "y = $P0.right\nT2 = y.left\ny.left = $P0\n$P0.right = T2\n$P0.height = max(get_height($P0.left), get_height($P0.right)) + 1\ny.height = max(get_height(y.left), get_height(y.right)) + 1\nreturn y",
    "description": "left_rotate (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_insert_583": {
    "name": "stack_insert_583",
    "pattern_type": "general",
    "code_template": "if not $P0:\n    return AVLTreeNode($P1)\nif $P1 < $P0.$P1:\n    $P0.left = insert($P0.left, $P1)\nelif $P1 > $P0.$P1:\n    $P0.right = insert($P0.right, $P1)\nelse:\n    return $P0\n$P0.height = 1 + max(get_height($P0.left), get_height($P0.right))\nbalance = get_balance($P0)\nif balance > 1 and $P1 < $P0.left.$P1:\n    return right_rotate($P0)\nif balance < -1 and $P1 > $P0.right.$P1:\n    return left_rotate($P0)\nif balance > 1 and $P1 > $P0.left.$P1:\n    $P0.left = left_rotate($P0.left)\n    return right_rotate($P0)\nif balance < -1 and $P1 < $P0.right.$P1:\n    $P0.right = right_rotate($P0.right)\n    return left_rotate($P0)\nreturn $P0",
    "description": "insert (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_parse_and_calculate_average_584": {
    "name": "stack_parse_and_calculate_average_584",
    "pattern_type": "string",
    "code_template": "age_groups = defaultdict(list)\ntry:\n    with open($P0, newline='') as csvfile:\n        reader = csv.reader(csvfile)\n        header = next(reader)\n        for (row_number, row) in enumerate(reader, start=2):\n            try:\n                if len(row) != 3:\n                    raise ValueError(f'Row {row_number}: Incorrect number of fields')\n                (name, age, grade) = row\n                age = int(age)\n                grade = float(grade)\n                age_groups[age].append(grade)\n            except ValueError as e:\n                print(f'Error in row {row_number}: {e}')\nexcept FileNotFoundError:\n    print('The file was not found.')\n    return\nprint(f\"{'Age':<10}{'Average Grade':<15}\")\nprint('=' * 25)\nfor (age, grades) in age_groups.items():\n    average_grade = sum(grades) / len(grades)\n    print(f'{age:<10}{average_grade:<15.2f}')",
    "description": "parse_and_calculate_average (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_solve_maze_585": {
    "name": "stack_solve_maze_585",
    "pattern_type": "general",
    "code_template": "def is_valid_move($P0, visited, x, y):\n    return 0 <= x < $P0.shape[0] and 0 <= y < $P0.shape[1] and ($P0[x][y] == 1) and (not visited[x][y])\ndef explore_path($P0, x, y, $P2, visited, path):\n    if (x, y) == $P2:\n        path.append((x, y))\n        return True\n    visited[x][y] = True\n    path.append((x, y))\n    for (move_x, move_y) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n        (new_x, new_y) = (x + move_x, y + move_y)\n        if is_valid_move($P0, visited, new_x, new_y):\n            if explore_path($P0, new_x, new_y, $P2, visited, path):\n                return True\n    path.pop()\n    visited[x][y] = False\n    return False\nvisited = np.zeros_like($P0, dtype=bool)\npath = []\nif explore_path($P0, $P1[0], $P1[1], $P2, visited, path):\n    return path\nelse:\n    return 'No path found'",
    "description": "solve_maze (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_valid_move_586": {
    "name": "stack_is_valid_move_586",
    "pattern_type": "general",
    "code_template": "return 0 <= $P2 < $P0.shape[0] and 0 <= $P3 < $P0.shape[1] and ($P0[$P2][$P3] == 1) and (not $P1[$P2][$P3])",
    "description": "is_valid_move (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_explore_path_587": {
    "name": "stack_explore_path_587",
    "pattern_type": "general",
    "code_template": "if ($P1, $P2) == $P3:\n    $P5.append(($P1, $P2))\n    return True\n$P4[$P1][$P2] = True\n$P5.append(($P1, $P2))\nfor (move_x, move_y) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n    (new_x, new_y) = ($P1 + move_x, $P2 + move_y)\n    if is_valid_move($P0, $P4, new_x, new_y):\n        if explore_path($P0, new_x, new_y, $P3, $P4, $P5):\n            return True\n$P5.pop()\n$P4[$P1][$P2] = False\nreturn False",
    "description": "explore_path (6 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_combinations_588": {
    "name": "stack_find_combinations_588",
    "pattern_type": "algorithm",
    "code_template": "def backtrack(start, $P1, path, result):\n    if $P1 == 0:\n        result.append(path)\n        return\n    for i in range(start, len($P0)):\n        if $P0[i] > $P1:\n            break\n        backtrack(i + 1, $P1 - $P0[i], path + [$P0[i]], result)\n$P0.sort()\nresult = []\nbacktrack(0, $P1, [], result)\nreturn result",
    "description": "find_combinations (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_backtrack_589": {
    "name": "stack_backtrack_589",
    "pattern_type": "general",
    "code_template": "if $P1 == 0:\n    $P3.append($P2)\n    return\nfor i in range($P0, len(coins)):\n    if coins[i] > $P1:\n        break\n    backtrack(i + 1, $P1 - coins[i], $P2 + [coins[i]], $P3)",
    "description": "backtrack (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_peek_590": {
    "name": "stack_peek_590",
    "pattern_type": "general",
    "code_template": "if not $P0.is_empty():\n    return $P0.stack[-1]\nreturn None",
    "description": "peek (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_vertex_591": {
    "name": "stack_add_vertex_591",
    "pattern_type": "general",
    "code_template": "if $P1 not in $P0.adjacency_list:\n    $P0.adjacency_list[$P1] = []\nelse:\n    print(f\"Vertex '{$P1}' already exists.\")",
    "description": "add_vertex (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_edge_592": {
    "name": "stack_add_edge_592",
    "pattern_type": "general",
    "code_template": "if $P1 not in $P0.adjacency_list:\n    print(f\"Start vertex '{$P1}' does not exist.\")\n    return\nif $P2 not in $P0.adjacency_list:\n    print(f\"End vertex '{$P2}' does not exist.\")\n    return\n$P0.adjacency_list[$P1].append($P2)",
    "description": "add_edge (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_display_593": {
    "name": "stack_display_593",
    "pattern_type": "general",
    "code_template": "for (vertex, edges) in $P0.adjacency_list.items():\n    print(f\"{vertex} -> {(', '.join(edges) if edges else 'No outgoing edges')}\")",
    "description": "display (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_divideBinaryString_594": {
    "name": "stack_divideBinaryString_594",
    "pattern_type": "string",
    "code_template": "result = []\ncount_0 = 0\ncount_1 = 0\nstart_index = 0\nfor (i, char) in enumerate($P0):\n    if char == '0':\n        count_0 += 1\n    elif char == '1':\n        count_1 += 1\n    if count_0 == count_1:\n        result.append($P0[start_index:i + 1])\n        count_0 = 0\n        count_1 = 0\n        start_index = i + 1\nreturn result",
    "description": "divideBinaryString (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_has_cycle_595": {
    "name": "stack_has_cycle_595",
    "pattern_type": "general",
    "code_template": "def dfs(v, parent):\n    visited[v] = True\n    for neighbor in $P0[v]:\n        if not visited[neighbor]:\n            if dfs(neighbor, v):\n                return True\n        elif neighbor != parent:\n            return True\n    return False\nvisited = {node: False for node in $P0}\nfor node in $P0:\n    if not visited[node]:\n        if dfs(node, -1):\n            return True\nreturn False",
    "description": "has_cycle (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_596": {
    "name": "stack_dfs_596",
    "pattern_type": "general",
    "code_template": "visited[$P0] = True\nfor neighbor in graph[$P0]:\n    if not visited[neighbor]:\n        if dfs(neighbor, $P0):\n            return True\n    elif neighbor != $P1:\n        return True\nreturn False",
    "description": "dfs (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_split_list_597": {
    "name": "stack_split_list_597",
    "pattern_type": "list",
    "code_template": "(slow, fast) = ($P0, $P0)\nprev = None\nwhile fast and fast.next:\n    prev = slow\n    slow = slow.next\n    fast = fast.next.next\nif prev:\n    prev.next = None\nreturn ($P0, slow)",
    "description": "split_list (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_lists_598": {
    "name": "stack_merge_lists_598",
    "pattern_type": "list",
    "code_template": "dummy = ListNode(0)\ntail = dummy\nwhile $P0 and $P1:\n    if $P0.value < $P1.value:\n        (tail.next, $P0) = ($P0, $P0.next)\n    else:\n        (tail.next, $P1) = ($P1, $P1.next)\n    tail = tail.next\ntail.next = $P0 or $P1\nreturn dummy.next",
    "description": "merge_lists (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_sort_linked_list_599": {
    "name": "stack_merge_sort_linked_list_599",
    "pattern_type": "algorithm",
    "code_template": "if not $P0 or not $P0.next:\n    return $P0\n(left, right) = split_list($P0)\nleft = merge_sort_linked_list(left)\nright = merge_sort_linked_list(right)\nreturn merge_lists(left, right)",
    "description": "merge_sort_linked_list (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_k_closest_elements_600": {
    "name": "stack_find_k_closest_elements_600",
    "pattern_type": "algorithm",
    "code_template": "distance_elements = [(abs(x - $P1), x) for x in $P0]\ndistance_elements.sort(key=lambda elem: (elem[0], elem[1]))\nclosest_k_elements = [elem[1] for elem in distance_elements[:$P2]]\nclosest_k_elements.sort()\nreturn closest_k_elements",
    "description": "find_k_closest_elements (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_transpose_601": {
    "name": "stack_transpose_601",
    "pattern_type": "general",
    "code_template": "rows = len($P0)\ncols = len($P0[0]) if $P0 else 0\ntransposed = [[0] * rows for _ in range(cols)]\nfor i in range(rows):\n    for j in range(cols):\n        transposed[j][i] = $P0[i][j]\nreturn transposed",
    "description": "transpose (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_create_dataset_602": {
    "name": "stack_create_dataset_602",
    "pattern_type": "general",
    "code_template": "return [random.randint(0, $P0) for _ in range($P0)]",
    "description": "create_dataset (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_insert_603": {
    "name": "stack_insert_603",
    "pattern_type": "general",
    "code_template": "if not $P1:\n    return AVLNode($P2)\nif $P2 < $P1.$P2:\n    $P1.left = $P0.insert($P1.left, $P2)\nelse:\n    $P1.right = $P0.insert($P1.right, $P2)\n$P1.height = 1 + max($P0.get_height($P1.left), $P0.get_height($P1.right))\nbalance = $P0.get_balance($P1)\nif balance > 1 and $P2 < $P1.left.$P2:\n    return $P0.right_rotate($P1)\nif balance < -1 and $P2 > $P1.right.$P2:\n    return $P0.left_rotate($P1)\nif balance > 1 and $P2 > $P1.left.$P2:\n    $P1.left = $P0.left_rotate($P1.left)\n    return $P0.right_rotate($P1)\nif balance < -1 and $P2 < $P1.right.$P2:\n    $P1.right = $P0.right_rotate($P1.right)\n    return $P0.left_rotate($P1)\nreturn $P1",
    "description": "insert (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_delete_604": {
    "name": "stack_delete_604",
    "pattern_type": "general",
    "code_template": "if not $P1:\n    return $P1\nif $P2 < $P1.$P2:\n    $P1.left = $P0.delete($P1.left, $P2)\nelif $P2 > $P1.$P2:\n    $P1.right = $P0.delete($P1.right, $P2)\nelse:\n    if not $P1.left:\n        return $P1.right\n    elif not $P1.right:\n        return $P1.left\n    temp = $P0.get_min_value_node($P1.right)\n    $P1.$P2 = temp.$P2\n    $P1.right = $P0.delete($P1.right, temp.$P2)\nif not $P1:\n    return $P1\n$P1.height = 1 + max($P0.get_height($P1.left), $P0.get_height($P1.right))\nbalance = $P0.get_balance($P1)\nif balance > 1 and $P0.get_balance($P1.left) >= 0:\n    return $P0.right_rotate($P1)\nif balance > 1 and $P0.get_balance($P1.left) < 0:\n    $P1.left = $P0.left_rotate($P1.left)\n    return $P0.right_rotate($P1)\nif balance < -1 and $P0.get_balance($P1.right) <= 0:\n    return $P0.left_rotate($P1)\nif balance < -1 and $P0.get_balance($P1.right) > 0:\n    $P1.right = $P0.right_rotate($P1.right)\n    return $P0.left_rotate($P1)\nreturn $P1",
    "description": "delete (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_squares_605": {
    "name": "stack_find_squares_605",
    "pattern_type": "algorithm",
    "code_template": "x_points = defaultdict(list)\ny_points = defaultdict(list)\nfor (x, y) in $P0:\n    x_points[x].append(y)\n    y_points[y].append(x)\nsquares = set()\nfor x1 in x_points:\n    y_list = x_points[x1]\n    for i in range(len(y_list)):\n        for j in range(i + 1, len(y_list)):\n            (y1, y2) = (y_list[i], y_list[j])\n            if y1 != y2:\n                horizontal_length = abs(y1 - y2)\n                for x2 in y_points[y1]:\n                    if x2 != x1 and x2 in y_points[y2]:\n                        if abs(x2 - x1) == horizontal_length:\n                            square = tuple(sorted([(x1, y1), (x1, y2), (x2, y1), (x2, y2)]))\n                            squares.add(square)\nreturn squares",
    "description": "find_squares (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_build_606": {
    "name": "stack_build_606",
    "pattern_type": "general",
    "code_template": "if $P3 == $P4:\n    $P0.tree[$P2] = $P1[$P3]\nelse:\n    mid = ($P3 + $P4) // 2\n    $P0.build($P1, 2 * $P2 + 1, $P3, mid)\n    $P0.build($P1, 2 * $P2 + 2, mid + 1, $P4)\n    $P0.tree[$P2] = gcd($P0.tree[2 * $P2 + 1], $P0.tree[2 * $P2 + 2])",
    "description": "build (5 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_update_607": {
    "name": "stack_update_607",
    "pattern_type": "general",
    "code_template": "if $P4 == $P5:\n    $P0.tree[$P3] = $P2\nelse:\n    mid = ($P4 + $P5) // 2\n    if $P4 <= $P1 <= mid:\n        $P0.update($P1, $P2, 2 * $P3 + 1, $P4, mid)\n    else:\n        $P0.update($P1, $P2, 2 * $P3 + 2, mid + 1, $P5)\n    $P0.tree[$P3] = gcd($P0.tree[2 * $P3 + 1], $P0.tree[2 * $P3 + 2])",
    "description": "update (6 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_range_gcd_608": {
    "name": "stack_range_gcd_608",
    "pattern_type": "math",
    "code_template": "if $P2 < $P4 or $P5 < $P1:\n    return 0\nif $P1 <= $P4 and $P5 <= $P2:\n    return $P0.tree[$P3]\nmid = ($P4 + $P5) // 2\nleft_gcd = $P0.range_gcd($P1, $P2, 2 * $P3 + 1, $P4, mid)\nright_gcd = $P0.range_gcd($P1, $P2, 2 * $P3 + 2, mid + 1, $P5)\nreturn gcd(left_gcd, right_gcd)",
    "description": "range_gcd (6 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_update_index_609": {
    "name": "stack_update_index_609",
    "pattern_type": "general",
    "code_template": "$P0.update($P1, $P2, 0, 0, $P0.n - 1)",
    "description": "update_index (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_610": {
    "name": "stack_dfs_610",
    "pattern_type": "general",
    "code_template": "stack = [($P1, [$P1])]\nwhile stack:\n    (vertex, path) = stack.pop()\n    for next in $P0[vertex] - set(path):\n        if next == $P2:\n            return path + [next]\n        else:\n            stack.append((next, path + [next]))\nreturn None",
    "description": "dfs (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_insert_611": {
    "name": "stack_insert_611",
    "pattern_type": "general",
    "code_template": "new_node = IntervalNode($P1, $P1[1])\n$P0.fix_insert(new_node)",
    "description": "insert (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_delete_612": {
    "name": "stack_delete_612",
    "pattern_type": "general",
    "code_template": "$P0.fix_delete(node_to_delete)",
    "description": "delete (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_search_interval_613": {
    "name": "stack_search_interval_613",
    "pattern_type": "algorithm",
    "code_template": "results = []\ndef search(node):\n    if node is None:\n        return\n    if $P0.overlaps(node.interval, $P1):\n        results.append(node.interval)\n    if node.left is not None and node.left.max_end >= $P1[0]:\n        search(node.left)\n    search(node.right)\nsearch($P0.root)\nreturn results",
    "description": "search_interval (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_search_614": {
    "name": "stack_search_614",
    "pattern_type": "algorithm",
    "code_template": "if $P0 is None:\n    return\nif self.overlaps($P0.interval, search_interval):\n    results.append($P0.interval)\nif $P0.left is not None and $P0.left.max_end >= search_interval[0]:\n    search($P0.left)\nsearch($P0.right)",
    "description": "search (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_valid_pairs_615": {
    "name": "stack_find_valid_pairs_615",
    "pattern_type": "algorithm",
    "code_template": "valid_pairs = []\nn = len($P0)\nfor i in range(n):\n    for j in range(i + 1, n):\n        diff = abs($P0[i] - $P0[j])\n        min_val = min($P0[i], $P0[j])\n        if diff <= min_val:\n            valid_pairs.append(($P0[i], $P0[j]))\nreturn valid_pairs",
    "description": "find_valid_pairs (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_setup_database_616": {
    "name": "stack_setup_database_616",
    "pattern_type": "general",
    "code_template": "connection = sqlite3.connect(':memory:')\ncursor = connection.cursor()\ncursor.execute('CREATE TABLE data (id INTEGER PRIMARY KEY, value TEXT)')\ncursor.executemany('INSERT INTO data (value) VALUES (?)', [(f'Value {i}',) for i in range(100)])\nconnection.commit()\nreturn connection",
    "description": "setup_database (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_execute_query_617": {
    "name": "stack_execute_query_617",
    "pattern_type": "general",
    "code_template": "with $P0:\n    cursor = $P0.cursor()\n    cursor.execute($P1)\n    results = cursor.fetchall()\n    return results",
    "description": "execute_query (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_sequential_execution_618": {
    "name": "stack_sequential_execution_618",
    "pattern_type": "general",
    "code_template": "results = []\nstart_time = time.time()\nfor query in $P1:\n    result = execute_query($P0, query)\n    results.append(result)\nend_time = time.time()\nprint(f'Sequential Execution Time: {end_time - start_time}s')\nreturn results",
    "description": "sequential_execution (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_concurrent_execution_619": {
    "name": "stack_concurrent_execution_619",
    "pattern_type": "general",
    "code_template": "results = []\nstart_time = time.time()\nwith ThreadPoolExecutor(max_workers=5) as executor:\n    future_to_query = {executor.submit(execute_query, $P0, query): query for query in $P1}\n    for future in as_completed(future_to_query):\n        result = future.result()\n        results.append(result)\nend_time = time.time()\nprint(f'Concurrent Execution Time: {end_time - start_time}s')\nreturn results",
    "description": "concurrent_execution (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_main_620": {
    "name": "stack_main_620",
    "pattern_type": "general",
    "code_template": "connection = setup_database()\nqueries = ['SELECT * FROM data WHERE id < 10', 'SELECT * FROM data WHERE id >= 10 AND id < 20', 'SELECT * FROM data WHERE id >= 20 AND id < 30', 'SELECT * FROM data WHERE id >= 30 AND id < 40', 'SELECT * FROM data WHERE id >= 40 AND id < 50']\nprint('Running Sequential Execution')\nsequential_results = sequential_execution(connection, queries)\nprint('\\nRunning Concurrent Execution')\nconcurrent_results = concurrent_execution(connection, queries)\nconnection.close()",
    "description": "main (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_fibonacci_memoization_621": {
    "name": "stack_fibonacci_memoization_621",
    "pattern_type": "math",
    "code_template": "if $P0 < 0:\n    raise ValueError('Fibonacci numbers are not defined for negative integers')\nelif $P0 == 0:\n    return 0\nelif $P0 == 1:\n    return 1\nelse:\n    return fibonacci_memoization($P0 - 1) + fibonacci_memoization($P0 - 2)",
    "description": "fibonacci_memoization (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_measure_performance_622": {
    "name": "stack_measure_performance_622",
    "pattern_type": "general",
    "code_template": "ns = range(0, 500, 50)\ntimes = []\nfor n in ns:\n    start_time = time.time()\n    fibonacci_memoization(n)\n    end_time = time.time()\n    times.append(end_time - start_time)\nplt.plot(ns, times, 'o-')\nplt.xlabel('Fibonacci index n')\nplt.ylabel('Computation Time (seconds)')\nplt.title('Fibonacci Computation Time with Memoization')\nplt.grid(True)\nplt.show()",
    "description": "measure_performance (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_process_strings_623": {
    "name": "stack_process_strings_623",
    "pattern_type": "string",
    "code_template": "result = []\nfor input_string in $P0:\n    sorted_string = clean_and_sort_string(input_string, $P1)\n    encoded_string = encode_base64(sorted_string)\n    if encoded_string is not None:\n        result.append(encoded_string)\nreturn result",
    "description": "process_strings (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_h_index_624": {
    "name": "stack_h_index_624",
    "pattern_type": "general",
    "code_template": "$P0.sort()\nh_index = 0\nn = len($P0)\nfor i in range(n):\n    num_papers_with_at_least_citations = n - i\n    if $P0[i] >= num_papers_with_at_least_citations:\n        h_index = num_papers_with_at_least_citations\nreturn h_index",
    "description": "h_index (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_countFullyConnectedGroups_625": {
    "name": "stack_countFullyConnectedGroups_625",
    "pattern_type": "general",
    "code_template": "from itertools import combinations\nn = len($P0)\ncount = 0\nfor size in range(1, n + 1):\n    for subset in combinations(range(n), size):\n        fully_connected = True\n        for i in range(len(subset)):\n            for j in range(i + 1, len(subset)):\n                if not ($P1[subset[i]][subset[j]] and $P1[subset[j]][subset[i]]):\n                    fully_connected = False\n                    break\n            if not fully_connected:\n                break\n        if fully_connected:\n            count += 1\nreturn count",
    "description": "countFullyConnectedGroups (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_apply_grayscale_626": {
    "name": "stack_apply_grayscale_626",
    "pattern_type": "general",
    "code_template": "gray_image = np.dot($P0[..., :3], [0.299, 0.587, 0.114])\nreturn gray_image.astype(np.uint8)",
    "description": "apply_grayscale (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_apply_sepia_627": {
    "name": "stack_apply_sepia_627",
    "pattern_type": "general",
    "code_template": "sepia_filter = np.array([[0.272, 0.534, 0.131], [0.349, 0.686, 0.168], [0.393, 0.769, 0.189]])\nsepia_image = $P0 @ sepia_filter.T\nsepia_image = np.clip(sepia_image, 0, 255)\nreturn sepia_image.astype(np.uint8)",
    "description": "apply_sepia (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_apply_negative_628": {
    "name": "stack_apply_negative_628",
    "pattern_type": "general",
    "code_template": "negative_image = 255 - $P0\nreturn negative_image",
    "description": "apply_negative (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_display_images_629": {
    "name": "stack_display_images_629",
    "pattern_type": "general",
    "code_template": "combined = np.hstack(($P0, $P1))\ncv2.imshow(f'Original and {$P2} Image', combined)\ncv2.waitKey(0)\ncv2.destroyAllWindows()",
    "description": "display_images (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_main_630": {
    "name": "stack_main_630",
    "pattern_type": "general",
    "code_template": "original_image = cv2.imread($P0)\nif original_image is None:\n    print('Error: Image not found.')\n    return\nif $P1 == 'grayscale':\n    filtered_image = apply_grayscale(original_image)\nelif $P1 == 'sepia':\n    filtered_image = apply_sepia(original_image)\nelif $P1 == 'negative':\n    filtered_image = apply_negative(original_image)\nelse:\n    print('Error: Unknown filter type.')\n    return\ndisplay_images(original_image, filtered_image, $P1)",
    "description": "main (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_main_631": {
    "name": "stack_main_631",
    "pattern_type": "general",
    "code_template": "website = 'example.com'\n(http_status, http_time) = connect_to_website(website, use_https=False)\nprint(f'HTTP Connection to {website}: Status {http_status}, Time {http_time:.6f}s')\n(https_status, https_time) = connect_to_website(website, use_https=True)\nprint(f'HTTPS Connection to {website}: Status {https_status}, Time {https_time:.6f}s')\nprint(analyze_security())",
    "description": "main (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_knapsack_optimized_632": {
    "name": "stack_knapsack_optimized_632",
    "pattern_type": "general",
    "code_template": "dp = [0] * ($P2 + 1)\nfor i in range(len($P0)):\n    for c in range($P2, $P0[i] - 1, -1):\n        dp[c] = max(dp[c], dp[c - $P0[i]] + $P1[i])\nreturn dp[$P2]",
    "description": "knapsack_optimized (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_tsp_with_fuel_constraint_633": {
    "name": "stack_tsp_with_fuel_constraint_633",
    "pattern_type": "string",
    "code_template": "from itertools import combinations\nnum_cities = len($P0)\nALL_VISITED = (1 << num_cities) - 1\ndp = [[float('inf')] * num_cities for _ in range(1 << num_cities)]\ndp[1][0] = 0\nfor mask in range(1 << num_cities):\n    for i in range(num_cities):\n        if mask & 1 << i:\n            for j in range(num_cities):\n                if not mask & 1 << j and dp[mask][i] + $P0[i][j] <= $P1:\n                    new_mask = mask | 1 << j\n                    dp[new_mask][j] = min(dp[new_mask][j], dp[mask][i] + $P0[i][j])\nmin_fuel = min((dp[ALL_VISITED][i] + $P0[i][0] for i in range(1, num_cities)))\nreturn min_fuel if min_fuel <= $P1 else -1",
    "description": "tsp_with_fuel_constraint (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_bellman_ford_634": {
    "name": "stack_bellman_ford_634",
    "pattern_type": "general",
    "code_template": "distance = [float('inf')] * $P1\ndistance[$P2] = 0\nfor _ in range($P1 - 1):\n    for (u, v, w) in $P0:\n        if distance[u] != float('inf') and distance[u] + w < distance[v]:\n            distance[v] = distance[u] + w\nfor (u, v, w) in $P0:\n    if distance[u] != float('inf') and distance[u] + w < distance[v]:\n        print('Graph contains negative weight cycle')\n        return\nprint('Vertex Distance from Source')\nfor i in range($P1):\n    print(f'{i} \\t\\t {distance[i]}')",
    "description": "bellman_ford (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_count_beautiful_subarrays_635": {
    "name": "stack_count_beautiful_subarrays_635",
    "pattern_type": "list",
    "code_template": "n = len($P0)\nbeautiful_count = 0\nfor start in range(n):\n    freq = {}\n    max_freq = 0\n    total_elements = 0\n    for end in range(start, n):\n        element = $P0[end]\n        if element in freq:\n            freq[element] += 1\n        else:\n            freq[element] = 1\n        max_freq = max(max_freq, freq[element])\n        total_elements += 1\n        sum_other_freqs = total_elements - max_freq\n        if max_freq == sum_other_freqs:\n            beautiful_count += 1\nreturn beautiful_count",
    "description": "count_beautiful_subarrays (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_bfs_636": {
    "name": "stack_bfs_636",
    "pattern_type": "general",
    "code_template": "visited = [False] * len($P0)\nqueue = deque([$P1])\nvisited[$P1] = True\nwhile queue:\n    u = queue.popleft()\n    for (v, capacity) in enumerate($P0[u]):\n        if not visited[v] and capacity > 0:\n            queue.append(v)\n            visited[v] = True\n            $P3[v] = u\n            if v == $P2:\n                return True\nreturn False",
    "description": "bfs (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_ford_fulkerson_637": {
    "name": "stack_ford_fulkerson_637",
    "pattern_type": "general",
    "code_template": "residual_graph = [row[:] for row in $P0]\nparent = [-1] * len($P0)\nmax_flow = 0\nwhile bfs(residual_graph, $P1, $P2, parent):\n    path_flow = float('Inf')\n    s = $P2\n    while s != $P1:\n        path_flow = min(path_flow, residual_graph[parent[s]][s])\n        s = parent[s]\n    v = $P2\n    while v != $P1:\n        u = parent[v]\n        residual_graph[u][v] -= path_flow\n        residual_graph[v][u] += path_flow\n        v = parent[v]\n    max_flow += path_flow\nreturn max_flow",
    "description": "ford_fulkerson (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_simulate_traffic_638": {
    "name": "stack_simulate_traffic_638",
    "pattern_type": "general",
    "code_template": "for _ in range($P0):\n    server = load_balancer.get_next_server()\n    print(f\"Redirecting traffic to {server['name']}\")",
    "description": "simulate_traffic (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_simulate_downtime_639": {
    "name": "stack_simulate_downtime_639",
    "pattern_type": "general",
    "code_template": "for server in $P0:\n    if random.random() < $P1:\n        server['status'] = 'down'\n    else:\n        server['status'] = 'up'",
    "description": "simulate_downtime (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_next_server_640": {
    "name": "stack_get_next_server_640",
    "pattern_type": "general",
    "code_template": "while True:\n    server = $P0.servers[$P0.index]\n    $P0.index = ($P0.index + 1) % len($P0.servers)\n    if server['status'] == 'up':\n        return server\n    print(f\"Server {server['name']} is down, switching to next.\")",
    "description": "get_next_server (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_healthy_tree_641": {
    "name": "stack_is_healthy_tree_641",
    "pattern_type": "general",
    "code_template": "if $P1 is None:\n    $P1 = set()\nif $P0 is None:\n    return True\nif $P0 in $P1:\n    return False\n$P1.add($P0)\nleft_healthy = is_healthy_tree($P0.left, $P1)\nright_healthy = is_healthy_tree($P0.right, $P1)\nreturn left_healthy and right_healthy",
    "description": "is_healthy_tree (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_valid_path_642": {
    "name": "stack_find_valid_path_642",
    "pattern_type": "algorithm",
    "code_template": "if not is_healthy_tree($P0):\n    return []\ndef dfs(node, current_sum, path):\n    if node is None:\n        return None\n    current_sum += node.value\n    path.append(node.value)\n    if node.left is None and node.right is None:\n        if current_sum == $P1:\n            return path[:]\n    left_path = dfs(node.left, current_sum, path)\n    if left_path is not None:\n        return left_path\n    right_path = dfs(node.right, current_sum, path)\n    if right_path is not None:\n        return right_path\n    path.pop()\n    return None\nresult = dfs($P0, 0, [])\nreturn result if result is not None else []",
    "description": "find_valid_path (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_643": {
    "name": "stack_dfs_643",
    "pattern_type": "general",
    "code_template": "if $P0 is None:\n    return None\n$P1 += $P0.value\n$P2.append($P0.value)\nif $P0.left is None and $P0.right is None:\n    if $P1 == target:\n        return $P2[:]\nleft_path = dfs($P0.left, $P1, $P2)\nif left_path is not None:\n    return left_path\nright_path = dfs($P0.right, $P1, $P2)\nif right_path is not None:\n    return right_path\n$P2.pop()\nreturn None",
    "description": "dfs (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_bootcamp_ranking_644": {
    "name": "stack_bootcamp_ranking_644",
    "pattern_type": "general",
    "code_template": "from collections import defaultdict\nparticipants = {i: {'solved': 0, 'time': 0, 'problems': set()} for i in range(1, $P1 + 1)}\nfor submission in $P4:\n    (dk, nk, pk, sk) = submission\n    if sk == 0:\n        if pk not in participants[nk]['problems']:\n            participants[nk]['problems'].add(pk)\n            participants[nk]['solved'] += 1\n            participants[nk]['time'] += dk\nranking_list = []\nfor (participant_id, data) in participants.items():\n    ranking_list.append((data['solved'], data['time'], participant_id))\nranking_list.sort(key=lambda x: (-x[0], x[1], x[2]))\nresult = []\ni = 0\nwhile i < len(ranking_list):\n    current_group = [ranking_list[i][2]]\n    while i + 1 < len(ranking_list) and ranking_list[i][:2] == ranking_list[i + 1][:2]:\n        current_group.append(ranking_list[i + 1][2])\n        i += 1\n    result.append('='.join(map(str, current_group)))\n    i += 1\nreturn ','.join(result)",
    "description": "bootcamp_ranking (5 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_fib_memo_645": {
    "name": "stack_fib_memo_645",
    "pattern_type": "general",
    "code_template": "if $P1 is None:\n    $P1 = {}\nif $P0 <= 0:\n    return 0\nelif $P0 == 1:\n    return 1\nif $P0 in $P1:\n    return $P1[$P0]\n$P1[$P0] = fib_memo($P0 - 1, $P1) + fib_memo($P0 - 2, $P1)\nreturn $P1[$P0]",
    "description": "fib_memo (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_fib_iter_646": {
    "name": "stack_fib_iter_646",
    "pattern_type": "general",
    "code_template": "if $P0 <= 0:\n    return 0\nelif $P0 == 1:\n    return 1\n(prev, curr) = (0, 1)\nfor _ in range(2, $P0 + 1):\n    (prev, curr) = (curr, prev + curr)\nreturn curr",
    "description": "fib_iter (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_detect_cycle_647": {
    "name": "stack_detect_cycle_647",
    "pattern_type": "general",
    "code_template": "visited = set()\nrec_stack = set()\ndef dfs(v):\n    visited.add(v)\n    rec_stack.add(v)\n    for neighbor in $P0.get(v, []):\n        if neighbor not in visited:\n            if dfs(neighbor):\n                return True\n        elif neighbor in rec_stack:\n            return True\n    rec_stack.remove(v)\n    return False\nfor node in $P0:\n    if node not in visited:\n        if dfs(node):\n            return True\nreturn False",
    "description": "detect_cycle (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_648": {
    "name": "stack_dfs_648",
    "pattern_type": "general",
    "code_template": "visited.add($P0)\nrec_stack.add($P0)\nfor neighbor in graph.get($P0, []):\n    if neighbor not in visited:\n        if dfs(neighbor):\n            return True\n    elif neighbor in rec_stack:\n        return True\nrec_stack.remove($P0)\nreturn False",
    "description": "dfs (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_generate_permutations_649": {
    "name": "stack_generate_permutations_649",
    "pattern_type": "general",
    "code_template": "def backtrack(start):\n    if start == len($P0):\n        results.append($P0[:])\n        return\n    seen = set()\n    for i in range(start, len($P0)):\n        if $P0[i] not in seen:\n            seen.add($P0[i])\n            ($P0[start], $P0[i]) = ($P0[i], $P0[start])\n            backtrack(start + 1)\n            ($P0[start], $P0[i]) = ($P0[i], $P0[start])\nresults = []\n$P0.sort()\nbacktrack(0)\nreturn results",
    "description": "generate_permutations (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_backtrack_650": {
    "name": "stack_backtrack_650",
    "pattern_type": "general",
    "code_template": "if $P0 == len(nums):\n    results.append(nums[:])\n    return\nseen = set()\nfor i in range($P0, len(nums)):\n    if nums[i] not in seen:\n        seen.add(nums[i])\n        (nums[$P0], nums[i]) = (nums[i], nums[$P0])\n        backtrack($P0 + 1)\n        (nums[$P0], nums[i]) = (nums[i], nums[$P0])",
    "description": "backtrack (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_convertTo2D_651": {
    "name": "stack_convertTo2D_651",
    "pattern_type": "general",
    "code_template": "if $P1 * $P2 != len($P0):\n    return []\nmatrix = []\nfor i in range($P1):\n    row = []\n    for j in range($P2):\n        row.append($P0[i * $P2 + j])\n    matrix.append(row)\nreturn matrix",
    "description": "convertTo2D (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_combinations_652": {
    "name": "stack_find_combinations_652",
    "pattern_type": "algorithm",
    "code_template": "if $P3 is None:\n    $P3 = []\nif $P0 == 0:\n    print($P3)\n    return\nif $P0 < 0 or $P2 >= len($P1):\n    return\nfind_combinations($P0 - $P1[$P2], $P1, $P2 + 1, $P3 + [$P1[$P2]])\nfind_combinations($P0, $P1, $P2 + 1, $P3)",
    "description": "find_combinations (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_generate_powers_of_3_653": {
    "name": "stack_generate_powers_of_3_653",
    "pattern_type": "general",
    "code_template": "powers = []\npower = 1\nwhile power <= $P0:\n    powers.append(power)\n    power *= 3\nreturn powers",
    "description": "generate_powers_of_3 (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_main_654": {
    "name": "stack_main_654",
    "pattern_type": "general",
    "code_template": "powers_of_3 = generate_powers_of_3($P0)\nfind_combinations($P0, powers_of_3)",
    "description": "main (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_serialize_655": {
    "name": "stack_serialize_655",
    "pattern_type": "general",
    "code_template": "def serialize_node(node):\n    if node is None:\n        result.append('#')\n    else:\n        result.append(str(node.value))\n        serialize_node(node.left)\n        serialize_node(node.right)\nresult = []\nserialize_node($P0.root)\nreturn ' '.join(result)",
    "description": "serialize (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_deserialize_656": {
    "name": "stack_deserialize_656",
    "pattern_type": "general",
    "code_template": "def deserialize_node(values):\n    if values[$P0.index] == '#':\n        $P0.index += 1\n        return None\n    node = TreeNode(int(values[$P0.index]))\n    $P0.index += 1\n    node.left = deserialize_node(values)\n    node.right = deserialize_node(values)\n    return node\nvalues = $P1.split()\n$P0.index = 0\n$P0.root = deserialize_node(values)",
    "description": "deserialize (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_serialize_node_657": {
    "name": "stack_serialize_node_657",
    "pattern_type": "general",
    "code_template": "if $P0 is None:\n    result.append('#')\nelse:\n    result.append(str($P0.value))\n    serialize_node($P0.left)\n    serialize_node($P0.right)",
    "description": "serialize_node (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_greedy_coloring_658": {
    "name": "stack_greedy_coloring_658",
    "pattern_type": "general",
    "code_template": "result = [-1] * $P0.V\nresult[0] = 0\navailable = [False] * $P0.V\nfor u in range(1, $P0.V):\n    for i in $P0.adj_list[u]:\n        if result[i] != -1:\n            available[result[i]] = True\n    cr = 0\n    while cr < $P0.V:\n        if not available[cr]:\n            break\n        cr += 1\n    result[u] = cr\n    for i in $P0.adj_list[u]:\n        if result[i] != -1:\n            available[result[i]] = False\nreturn result",
    "description": "greedy_coloring (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_evaluateGraphColoring_659": {
    "name": "stack_evaluateGraphColoring_659",
    "pattern_type": "general",
    "code_template": "graph_sizes = [10, 50, 100, 200]\nfor size in graph_sizes:\n    graph = Graph(size)\n    for _ in range(size * 2):\n        u = random.randint(0, size - 1)\n        v = random.randint(0, size - 1)\n        graph.add_edge(u, v)\n    start_time = time.time()\n    coloring_result = greedy_coloring(graph)\n    end_time = time.time()\n    num_colors = len(set(coloring_result))\n    print(f'Graph size: {size}, Time: {end_time - start_time:.4f}s, Colors used: {num_colors}')",
    "description": "evaluateGraphColoring (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_matrix_chain_order_660": {
    "name": "stack_matrix_chain_order_660",
    "pattern_type": "general",
    "code_template": "n = len($P0) - 1\nm = [[0 for _ in range(n)] for _ in range(n)]\ns = [[0 for _ in range(n)] for _ in range(n)]\nfor l in range(2, n + 1):\n    for i in range(n - l + 1):\n        j = i + l - 1\n        m[i][j] = float('inf')\n        for k in range(i, j):\n            q = m[i][k] + m[k + 1][j] + $P0[i] * $P0[k + 1] * $P0[j + 1]\n            if q < m[i][j]:\n                m[i][j] = q\n                s[i][j] = k\nreturn m[0][n - 1]",
    "description": "matrix_chain_order (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_create_rotated_square_661": {
    "name": "stack_create_rotated_square_661",
    "pattern_type": "general",
    "code_template": "half_diagonal = $P0 * math.sqrt(2) / 2\nsquare = Polygon([(-half_diagonal, -half_diagonal), (half_diagonal, -half_diagonal), (half_diagonal, half_diagonal), (-half_diagonal, half_diagonal)])\nreturn rotate(square, 45, origin=(0, 0))",
    "description": "create_rotated_square (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_calculate_blue_area_662": {
    "name": "stack_calculate_blue_area_662",
    "pattern_type": "general",
    "code_template": "total_blue_area = 0\nfor i in range(1, $P0 + 1, 2):\n    outer_square = create_rotated_square(i + 1)\n    inner_square = create_rotated_square(i)\n    blue_ring = outer_square.difference(inner_square)\n    total_blue_area += blue_ring.area\npolygon_shape = Polygon($P1)\nblue_in_polygon = polygon_shape.intersection(Polygon([(0, 0), ($P0, 0), ($P0, $P0), (0, $P0)]))\nblue_in_polygon_area = 0\nfor i in range(1, $P0 + 1, 2):\n    outer_square = create_rotated_square(i + 1)\n    inner_square = create_rotated_square(i)\n    blue_ring = outer_square.difference(inner_square)\n    blue_in_polygon_area += blue_ring.intersection(polygon_shape).area\nwhite_in_polygon_area = polygon_shape.area - blue_in_polygon_area\ntotal_blue_area += white_in_polygon_area - blue_in_polygon_area\nreturn total_blue_area",
    "description": "calculate_blue_area (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_encrypt_message_663": {
    "name": "stack_encrypt_message_663",
    "pattern_type": "general",
    "code_template": "cipher = AES.new($P0.sym_key, AES.MODE_EAX)\nnonce = cipher.nonce\n(ciphertext, tag) = cipher.encrypt_and_digest($P1.encode('utf-8'))\nreturn base64.b64encode(nonce + ciphertext).decode('utf-8')",
    "description": "encrypt_message (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_decrypt_message_664": {
    "name": "stack_decrypt_message_664",
    "pattern_type": "general",
    "code_template": "raw = base64.b64decode($P1)\nnonce = raw[:16]\nciphertext = raw[16:]\ncipher = AES.new($P0.sym_key, AES.MODE_EAX, nonce=nonce)\nreturn cipher.decrypt(ciphertext).decode('utf-8')",
    "description": "decrypt_message (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_handle_client_665": {
    "name": "stack_handle_client_665",
    "pattern_type": "general",
    "code_template": "while True:\n    try:\n        message = $P1.recv(1024).decode('utf-8')\n        decrypted_message = $P0.decrypt_message(message)\n        print(f'Received: {decrypted_message}')\n    except Exception as e:\n        print('Error:', e)\n        $P1.close()\n        break",
    "description": "handle_client (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_encrypt_key_with_rsa_666": {
    "name": "stack_encrypt_key_with_rsa_666",
    "pattern_type": "general",
    "code_template": "cipher_rsa = PKCS1_OAEP.new($P0.private_key)\nreturn cipher_rsa.encrypt($P1)",
    "description": "encrypt_key_with_rsa (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dijkstra_667": {
    "name": "stack_dijkstra_667",
    "pattern_type": "string",
    "code_template": "priority_queue = []\ndistances = {vertex: float('infinity') for vertex in $P0}\ndistances[$P1] = 0\npaths = {vertex: [] for vertex in $P0}\npaths[$P1] = [$P1]\nheapq.heappush(priority_queue, (0, $P1))\nwhile priority_queue:\n    (current_distance, current_vertex) = heapq.heappop(priority_queue)\n    if current_distance > distances[current_vertex]:\n        continue\n    for (neighbor, weight) in $P0[current_vertex].items():\n        distance = current_distance + weight\n        if distance < distances[neighbor]:\n            distances[neighbor] = distance\n            heapq.heappush(priority_queue, (distance, neighbor))\n            paths[neighbor] = paths[current_vertex] + [neighbor]\nreturn (distances, paths)",
    "description": "dijkstra (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_poly_668": {
    "name": "stack_add_poly_668",
    "pattern_type": "general",
    "code_template": "return [p + q for (p, q) in zip($P0, $P1)]",
    "description": "add_poly (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_subtract_poly_669": {
    "name": "stack_subtract_poly_669",
    "pattern_type": "general",
    "code_template": "return [p - q for (p, q) in zip($P0, $P1)]",
    "description": "subtract_poly (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_minRearrangementsToPalindrome_670": {
    "name": "stack_minRearrangementsToPalindrome_670",
    "pattern_type": "general",
    "code_template": "from collections import Counter\nchar_count = Counter($P0)\nodd_count = sum((1 for count in char_count.values() if count % 2 != 0))\nreturn odd_count // 2",
    "description": "minRearrangementsToPalindrome (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_enqueue_671": {
    "name": "stack_enqueue_671",
    "pattern_type": "general",
    "code_template": "if $P0.rear == $P0.size:\n    print('Queue is full')\n    return\n$P0.queue[$P0.rear] = $P1\n$P0.rear += 1",
    "description": "enqueue (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dequeue_672": {
    "name": "stack_dequeue_672",
    "pattern_type": "general",
    "code_template": "if $P0.is_empty():\n    print('Queue is empty')\n    return None\ntemp = $P0.queue[$P0.front]\n$P0.front += 1\nreturn temp",
    "description": "dequeue (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_empty_673": {
    "name": "stack_is_empty_673",
    "pattern_type": "general",
    "code_template": "return $P0.front == $P0.rear",
    "description": "is_empty (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_frequency_analysis_with_constraints_674": {
    "name": "stack_frequency_analysis_with_constraints_674",
    "pattern_type": "string",
    "code_template": "frequency = [0] * 26\nfor char in $P0:\n    index = ord(char) - ord('a')\n    frequency[index] += 1\nvowels = {'a', 'e', 'i', 'o', 'u'}\nresult = []\nfor i in range(26):\n    char = chr(i + ord('a'))\n    if char in vowels:\n        continue\n    product = (i + 1) * frequency[i]\n    if product % 2 == 0:\n        result.append(frequency[i])\nreturn result",
    "description": "frequency_analysis_with_constraints (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_unicode_palindrome_675": {
    "name": "stack_is_unicode_palindrome_675",
    "pattern_type": "general",
    "code_template": "normalized_str = unicodedata.normalize('NFC', $P0)\nfiltered_chars = [char.lower() for char in normalized_str if char.isalnum()]\nis_palindrome = filtered_chars == filtered_chars[::-1]\nreturn is_palindrome",
    "description": "is_unicode_palindrome (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_maze_path_676": {
    "name": "stack_find_maze_path_676",
    "pattern_type": "algorithm",
    "code_template": "def is_safe(x, y):\n    return 0 <= x < len($P0) and 0 <= y < len($P0[0]) and ($P0[x][y] == 1)\ndef solve(x, y, path):\n    if x == len($P0) - 1 and y == len($P0[0]) - 1:\n        path.append((x, y))\n        return True\n    if is_safe(x, y):\n        path.append((x, y))\n        $P0[x][y] = 0\n        if solve(x, y + 1, path):\n            return True\n        if solve(x + 1, y, path):\n            return True\n        path.pop()\n        $P0[x][y] = 1\n    return False\npath = []\nif solve(0, 0, path):\n    return path\nelse:\n    return []",
    "description": "find_maze_path (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_safe_677": {
    "name": "stack_is_safe_677",
    "pattern_type": "general",
    "code_template": "return 0 <= $P0 < len(maze) and 0 <= $P1 < len(maze[0]) and (maze[$P0][$P1] == 1)",
    "description": "is_safe (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_solve_678": {
    "name": "stack_solve_678",
    "pattern_type": "general",
    "code_template": "if $P0 == len(maze) - 1 and $P1 == len(maze[0]) - 1:\n    $P2.append(($P0, $P1))\n    return True\nif is_safe($P0, $P1):\n    $P2.append(($P0, $P1))\n    maze[$P0][$P1] = 0\n    if solve($P0, $P1 + 1, $P2):\n        return True\n    if solve($P0 + 1, $P1, $P2):\n        return True\n    $P2.pop()\n    maze[$P0][$P1] = 1\nreturn False",
    "description": "solve (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_annotation_679": {
    "name": "stack_add_annotation_679",
    "pattern_type": "general",
    "code_template": "annotation = {'$P1': $P1, '$P2': $P2, '$P3': $P3}\n$P0.annotations.append(annotation)\n$P0.render_annotation(annotation)",
    "description": "add_annotation (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_render_annotation_680": {
    "name": "stack_render_annotation_680",
    "pattern_type": "general",
    "code_template": "print(f\"Rendering $P1 at {$P1['position']} with comment: {$P1['comment']}\")",
    "description": "render_annotation (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_save_annotations_681": {
    "name": "stack_save_annotations_681",
    "pattern_type": "general",
    "code_template": "print('Saving annotations to the database')",
    "description": "save_annotations (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_rotate_right_682": {
    "name": "stack_rotate_right_682",
    "pattern_type": "general",
    "code_template": "if not $P0:\n    return $P0\nn = len($P0)\n$P1 = $P1 % n\nreturn $P0[-$P1:] + $P0[:-$P1]",
    "description": "rotate_right (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_encrypted_transaction_683": {
    "name": "stack_encrypted_transaction_683",
    "pattern_type": "general",
    "code_template": "key = Fernet.generate_key()\ncipher_suite = Fernet(key)\nprint(f'Connecting to payment $P0: {$P0}...')\ntransaction_info = {'$P0': $P0, '$P1': $P1, 'details': $P2}\ntransaction_info_str = json.dumps(transaction_info)\nencrypted_data = cipher_suite.encrypt(transaction_info_str.encode('utf-8'))\nreturn encrypted_data.decode('utf-8')",
    "description": "encrypted_transaction (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_groupAndClassify_684": {
    "name": "stack_groupAndClassify_684",
    "pattern_type": "general",
    "code_template": "string_groups = {}\nfor string in $P0:\n    length = len(string)\n    if length not in string_groups:\n        string_groups[length] = []\n    string_groups[length].append(string)\ngreater_than_10 = []\nless_or_equal_to_10 = []\nfor row in $P1:\n    for element in row:\n        if element > 10:\n            greater_than_10.append(element)\n        else:\n            less_or_equal_to_10.append(element)\nresult = {'string_groups': string_groups, 'greater_than_10': greater_than_10, 'less_or_equal_to_10': less_or_equal_to_10}\nreturn result",
    "description": "groupAndClassify (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_convertTemperatures_685": {
    "name": "stack_convertTemperatures_685",
    "pattern_type": "general",
    "code_template": "converted = []\nfor temp in $P0:\n    try:\n        value = int(temp[:-1])\n        unit = temp[-1].upper()\n        if unit == 'C':\n            converted_value = value * 9 / 5 + 32\n            converted.append(f'{round(converted_value)}F')\n        elif unit == 'F':\n            converted_value = (value - 32) * 5 / 9\n            converted.append(f'{round(converted_value)}C')\n        else:\n            continue\n    except (ValueError, IndexError):\n        continue\nreturn converted",
    "description": "convertTemperatures (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_fibonacci_mod_686": {
    "name": "stack_fibonacci_mod_686",
    "pattern_type": "math",
    "code_template": "if $P0 == 0:\n    return 0\nelif $P0 == 1:\n    return 1\n(a, b) = (0, 1)\nfor _ in range(2, $P0 + 1):\n    (a, b) = (b, (a + b) % $P1)\nreturn b",
    "description": "fibonacci_mod (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_sort_task_scheduler_687": {
    "name": "stack_sort_task_scheduler_687",
    "pattern_type": "algorithm",
    "code_template": "$P0.sort(key=lambda task: (task.priority, task.length))\ntotal_time = 0\ncompletion_order = []\nfor task in $P0:\n    total_time += task.length\n    completion_order.append((task.name, total_time))\nreturn completion_order",
    "description": "sort_task_scheduler (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_insert_688": {
    "name": "stack_insert_688",
    "pattern_type": "general",
    "code_template": "if $P0.root is None:\n    $P0.root = TreeNode($P1)\nelse:\n    $P0._insert($P0.root, $P1)",
    "description": "insert (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_preorderTraversal_689": {
    "name": "stack_preorderTraversal_689",
    "pattern_type": "general",
    "code_template": "result = []\n$P0._preorderTraversal($P0.root, result)\nreturn result",
    "description": "preorderTraversal (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_evacuation_plan_690": {
    "name": "stack_evacuation_plan_690",
    "pattern_type": "general",
    "code_template": "queue = deque([$P1])\nvisited = set([$P1])\nshortest_paths = {$P1: [$P1]}\nevacuation_order = []\nwhile queue:\n    current_room = queue.popleft()\n    evacuation_order.append(current_room)\n    for neighbor in $P0[current_room]:\n        if neighbor not in visited:\n            visited.add(neighbor)\n            shortest_paths[neighbor] = shortest_paths[current_room] + [neighbor]\n            queue.append(neighbor)\nreturn (evacuation_order, shortest_paths)",
    "description": "evacuation_plan (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_calculate_nutritional_intake_691": {
    "name": "stack_calculate_nutritional_intake_691",
    "pattern_type": "general",
    "code_template": "daily_totals = {}\nfor (day, meals) in $P0.items():\n    totals = {'calories': 0, 'carbohydrates': 0, 'proteins': 0, 'fats': 0}\n    for meal in meals:\n        if meal in $P1:\n            totals['calories'] += $P1[meal]['calories']\n            totals['carbohydrates'] += $P1[meal]['carbohydrates']\n            totals['proteins'] += $P1[meal]['proteins']\n            totals['fats'] += $P1[meal]['fats']\n    daily_totals[day] = totals\nreturn daily_totals",
    "description": "calculate_nutritional_intake (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_display_nutritional_intake_692": {
    "name": "stack_display_nutritional_intake_692",
    "pattern_type": "general",
    "code_template": "print('Weekly Nutritional Intake:')\nfor (day, totals) in $P0.items():\n    print(f'\\n{day}:')\n    print(f\"  Calories: {totals['calories']} kcal\")\n    print(f\"  Carbohydrates: {totals['carbohydrates']} g\")\n    print(f\"  Proteins: {totals['proteins']} g\")\n    print(f\"  Fats: {totals['fats']} g\")",
    "description": "display_nutritional_intake (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_lis_memo_693": {
    "name": "stack_lis_memo_693",
    "pattern_type": "general",
    "code_template": "n = len($P0)\nmemo = [-1] * n\ndef lis_ending_at(i):\n    if memo[i] != -1:\n        return memo[i]\n    max_len = 1\n    for j in range(i):\n        if $P0[j] < $P0[i]:\n            max_len = max(max_len, lis_ending_at(j) + 1)\n    memo[i] = max_len\n    return max_len\nmax_lis = 0\nfor i in range(n):\n    max_lis = max(max_lis, lis_ending_at(i))\nreturn max_lis",
    "description": "lis_memo (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_lis_dp_694": {
    "name": "stack_lis_dp_694",
    "pattern_type": "general",
    "code_template": "n = len($P0)\ndp = [1] * n\nfor i in range(1, n):\n    for j in range(i):\n        if $P0[j] < $P0[i]:\n            dp[i] = max(dp[i], dp[j] + 1)\nreturn max(dp)",
    "description": "lis_dp (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_lis_ending_at_695": {
    "name": "stack_lis_ending_at_695",
    "pattern_type": "general",
    "code_template": "if memo[$P0] != -1:\n    return memo[$P0]\nmax_len = 1\nfor j in range($P0):\n    if arr[j] < arr[$P0]:\n        max_len = max(max_len, lis_ending_at(j) + 1)\nmemo[$P0] = max_len\nreturn max_len",
    "description": "lis_ending_at (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_test_lis_dp_696": {
    "name": "stack_test_lis_dp_696",
    "pattern_type": "general",
    "code_template": "$P0.assertEqual(lis_dp([10, 22, 9, 33, 21, 50, 41, 60, 80]), 6)\n$P0.assertEqual(lis_dp([3, 10, 2, 1, 20]), 3)\n$P0.assertEqual(lis_dp([3, 2]), 1)\n$P0.assertEqual(lis_dp([50, 3, 10, 7, 40, 80]), 4)",
    "description": "test_lis_dp (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_test_lis_memo_697": {
    "name": "stack_test_lis_memo_697",
    "pattern_type": "general",
    "code_template": "$P0.assertEqual(lis_memo([10, 22, 9, 33, 21, 50, 41, 60, 80]), 6)\n$P0.assertEqual(lis_memo([3, 10, 2, 1, 20]), 3)\n$P0.assertEqual(lis_memo([3, 2]), 1)\n$P0.assertEqual(lis_memo([50, 3, 10, 7, 40, 80]), 4)",
    "description": "test_lis_memo (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_kmp_search_698": {
    "name": "stack_kmp_search_698",
    "pattern_type": "algorithm",
    "code_template": "def compute_lps($P1):\n    \"\"\"Helper function to preprocess the $P1 to create the LPS (Longest Prefix Suffix) array.\"\"\"\n    lps = [0] * len($P1)\n    length = 0\n    i = 1\n    while i < len($P1):\n        if $P1[i] == $P1[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        elif length != 0:\n            length = lps[length - 1]\n        else:\n            lps[i] = 0\n            i += 1\n    return lps\n(m, n) = (len($P1), len($P0))\nlps = compute_lps($P1)\ni = j = 0\nresult = []\nwhile i < n:\n    if $P1[j] == $P0[i]:\n        i += 1\n        j += 1\n    if j == m:\n        result.append(i - j)\n        j = lps[j - 1]\n    elif i < n and $P1[j] != $P0[i]:\n        if j != 0:\n            j = lps[j - 1]\n        else:\n            i += 1\nreturn result",
    "description": "kmp_search (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_edge_699": {
    "name": "stack_add_edge_699",
    "pattern_type": "general",
    "code_template": "$P0[$P1].append($P2)",
    "description": "add_edge (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_bfs_700": {
    "name": "stack_bfs_700",
    "pattern_type": "general",
    "code_template": "queue = deque()\nfor u in $P0:\n    if $P1[u] == -1:\n        $P3[u] = 0\n        queue.append(u)\n    else:\n        $P3[u] = float('inf')\n$P3[None] = float('inf')\nwhile queue:\n    u = queue.popleft()\n    if $P3[u] < $P3[None]:\n        for v in $P0[u]:\n            if $P3[$P2[v]] == float('inf'):\n                $P3[$P2[v]] = $P3[u] + 1\n                queue.append($P2[v])\nreturn $P3[None] != float('inf')",
    "description": "bfs (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_701": {
    "name": "stack_dfs_701",
    "pattern_type": "general",
    "code_template": "if $P1 is not None:\n    for v in $P0[$P1]:\n        if $P4[$P3[v]] == $P4[$P1] + 1:\n            if dfs($P0, $P3[v], $P2, $P3, $P4):\n                $P3[v] = $P1\n                $P2[$P1] = v\n                return True\n    $P4[$P1] = float('inf')\n    return False\nreturn True",
    "description": "dfs (5 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_hopcroft_karp_702": {
    "name": "stack_hopcroft_karp_702",
    "pattern_type": "general",
    "code_template": "graph = defaultdict(list)\nfor (teacher, class_) in $P2:\n    add_edge(graph, teacher, class_)\nmatch_teacher = {u: -1 for u in $P0}\nmatch_class = {v: -1 for v in $P1}\ndist = {}\nmatching = 0\nwhile bfs(graph, match_teacher, match_class, dist):\n    for u in $P0:\n        if match_teacher[u] == -1:\n            if dfs(graph, u, match_teacher, match_class, dist):\n                matching += 1\nreturn match_teacher",
    "description": "hopcroft_karp (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_rotate_string_and_array_703": {
    "name": "stack_rotate_string_and_array_703",
    "pattern_type": "list",
    "code_template": "if len($P0) != len($P1):\n    raise ValueError('String and array must have the same length')\n$P2 = $P2 % len($P0)\nnew_s = $P0[$P2:] + $P0[:$P2]\nnew_arr = $P1[$P2:] + $P1[:$P2]\nreturn (new_s, new_arr)",
    "description": "rotate_string_and_array (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_max_profit_704": {
    "name": "stack_max_profit_704",
    "pattern_type": "general",
    "code_template": "if not $P0:\n    return 0\nmin_price = float('inf')\nmax_profit = 0\nfor price in $P0:\n    if price < min_price:\n        min_price = price\n    elif price - min_price > max_profit:\n        max_profit = price - min_price\nreturn max_profit",
    "description": "max_profit (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_second_largest_digit_705": {
    "name": "stack_second_largest_digit_705",
    "pattern_type": "general",
    "code_template": "unique_digits = set()\nfor char in $P0:\n    if char.isdigit():\n        unique_digits.add(int(char))\nif len(unique_digits) < 2:\n    return -1\nsorted_digits = sorted(unique_digits)\nreturn sorted_digits[-2]",
    "description": "second_largest_digit (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_f_706": {
    "name": "stack_f_706",
    "pattern_type": "general",
    "code_template": "if $P1 in $P0:\n    $P0[$P1] += 1\nelse:\n    $P0[$P1] = 1\nreturn $P0",
    "description": "f (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_elbow_method_707": {
    "name": "stack_elbow_method_707",
    "pattern_type": "general",
    "code_template": "wcss = []\nfor k in range(1, $P1 + 1):\n    kmeans = KMeans(n_clusters=k)\n    kmeans.fit($P0)\n    wcss.append(np.sum(($P0 - kmeans.centroids[kmeans.predict($P0)]) ** 2))\nplt.plot(range(1, $P1 + 1), wcss, marker='o')\nplt.xlabel('Number of clusters')\nplt.ylabel('WCSS')\nplt.title('Elbow Method')\nplt.show()",
    "description": "elbow_method (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_silhouette_method_708": {
    "name": "stack_silhouette_method_708",
    "pattern_type": "general",
    "code_template": "silhouette_scores = []\nfor k in range(2, $P1 + 1):\n    kmeans = KMeans(n_clusters=k)\n    kmeans.fit($P0)\n    score = silhouette_score($P0, kmeans.predict($P0))\n    silhouette_scores.append(score)\nplt.plot(range(2, $P1 + 1), silhouette_scores, marker='o')\nplt.xlabel('Number of clusters')\nplt.ylabel('Silhouette Score')\nplt.title('Silhouette Method')\nplt.show()",
    "description": "silhouette_method (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_fit_709": {
    "name": "stack_fit_709",
    "pattern_type": "general",
    "code_template": "np.random.seed(42)\nrandom_indices = np.random.permutation($P1.shape[0])\n$P0.centroids = $P1[random_indices[:$P0.n_clusters]]\nfor i in range($P0.max_iter):\n    $P0.labels = $P0._assign_clusters($P1)\n    new_centroids = $P0._compute_centroids($P1)\n    if np.all(np.abs(new_centroids - $P0.centroids) < $P0.tol):\n        break\n    $P0.centroids = new_centroids",
    "description": "fit (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_insert_710": {
    "name": "stack_insert_710",
    "pattern_type": "general",
    "code_template": "current = $P0.root\nfor letter in $P1:\n    if letter not in current.children:\n        current.children[letter] = TrieNode()\n    current = current.children[letter]\ncurrent.is_end_of_word = True",
    "description": "insert (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_search_prefix_711": {
    "name": "stack_search_prefix_711",
    "pattern_type": "algorithm",
    "code_template": "results = []\ncurrent = $P0.root\nfor letter in $P1:\n    if letter not in current.children:\n        return results\n    current = current.children[letter]\n$P0._find_words_from_node(current, $P1, results)\nreturn results",
    "description": "search_prefix (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_reverse_part_712": {
    "name": "stack_reverse_part_712",
    "pattern_type": "general",
    "code_template": "reversed_substring = $P0[$P1:$P2][::-1]\n$P3[$P4] = reversed_substring",
    "description": "reverse_part (5 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_multithreaded_reverse_713": {
    "name": "stack_multithreaded_reverse_713",
    "pattern_type": "general",
    "code_template": "length = len($P0)\npart_size = length // $P1\nthreads = []\nresult = [None] * $P1\nfor i in range($P1):\n    start_index = i * part_size\n    end_index = start_index + part_size if i < $P1 - 1 else length\n    thread = threading.Thread(target=reverse_part, args=($P0, start_index, end_index, result, i))\n    threads.append(thread)\n    thread.start()\nfor thread in threads:\n    thread.join()\nreturn ''.join(result)",
    "description": "multithreaded_reverse (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_single_threaded_reverse_714": {
    "name": "stack_single_threaded_reverse_714",
    "pattern_type": "general",
    "code_template": "return $P0[::-1]",
    "description": "single_threaded_reverse (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_sigmoid_715": {
    "name": "stack_sigmoid_715",
    "pattern_type": "general",
    "code_template": "return 1 / (1 + np.exp(-$P0))",
    "description": "sigmoid (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_sigmoid_derivative_716": {
    "name": "stack_sigmoid_derivative_716",
    "pattern_type": "general",
    "code_template": "return sigmoid($P0) * (1 - sigmoid($P0))",
    "description": "sigmoid_derivative (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_forward_propagation_717": {
    "name": "stack_forward_propagation_717",
    "pattern_type": "general",
    "code_template": "Z1 = np.dot($P0, W1) + b1\nA1 = sigmoid(Z1)\nZ2 = np.dot(A1, W2) + b2\nA2 = sigmoid(Z2)\nreturn (Z1, A1, Z2, A2)",
    "description": "forward_propagation (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_compute_loss_718": {
    "name": "stack_compute_loss_718",
    "pattern_type": "general",
    "code_template": "m = $P0.shape[0]\nreturn -np.sum($P0 * np.log($P1) + (1 - $P0) * np.log(1 - $P1)) / m",
    "description": "compute_loss (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_unique_permutations_719": {
    "name": "stack_unique_permutations_719",
    "pattern_type": "general",
    "code_template": "sorted_s = sorted($P0)\nresult = []\ndef backtrack(path, used):\n    if len(path) == len($P0):\n        result.append(''.join(path))\n        return\n    visited = set()\n    for i in range(len(sorted_s)):\n        if used[i] or sorted_s[i] in visited:\n            continue\n        used[i] = True\n        path.append(sorted_s[i])\n        visited.add(sorted_s[i])\n        backtrack(path, used)\n        path.pop()\n        used[i] = False\nbacktrack([], [False] * len($P0))\nreturn result",
    "description": "unique_permutations (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_backtrack_720": {
    "name": "stack_backtrack_720",
    "pattern_type": "general",
    "code_template": "if len($P0) == len(s):\n    result.append(''.join($P0))\n    return\nvisited = set()\nfor i in range(len(sorted_s)):\n    if $P1[i] or sorted_s[i] in visited:\n        continue\n    $P1[i] = True\n    $P0.append(sorted_s[i])\n    visited.add(sorted_s[i])\n    backtrack($P0, $P1)\n    $P0.pop()\n    $P1[i] = False",
    "description": "backtrack (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_reverse_words_721": {
    "name": "stack_reverse_words_721",
    "pattern_type": "general",
    "code_template": "words = []\ncurrent_word = []\nfor char in $P0:\n    if char.isspace():\n        if current_word:\n            words.append(''.join(current_word))\n            current_word = []\n        current_word.append(char)\n    else:\n        if current_word and current_word[0].isspace():\n            words.append(''.join(current_word))\n            current_word = []\n        current_word.append(char)\nif current_word:\n    words.append(''.join(current_word))\nreversed_sentence = ''.join(words[::-1])\nreturn reversed_sentence",
    "description": "reverse_words (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_quicksort_722": {
    "name": "stack_quicksort_722",
    "pattern_type": "algorithm",
    "code_template": "if len($P0) <= 1:\n    return $P0\npivot_index = random.randint(0, len($P0) - 1)\npivot = $P0[pivot_index]\nless = [x for (i, x) in enumerate($P0) if x <= pivot and i != pivot_index]\ngreater = [x for (i, x) in enumerate($P0) if x > pivot]\nreturn quicksort(less) + [pivot] + quicksort(greater)",
    "description": "quicksort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_test_quicksort_723": {
    "name": "stack_test_quicksort_723",
    "pattern_type": "algorithm",
    "code_template": "import time\ntest_arrays = [[3, 6, 8, 10, 1, 2, 1], [], [1], [2, 1], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [10, 9, 8, 7, 6, 5, 4, 3, 2, 1], list(range(1000)), list(range(1000, 0, -1)), [random.randint(0, 1000) for _ in range(1000)]]\nfor arr in test_arrays:\n    start = time.time()\n    sorted_arr = quicksort(arr)\n    end = time.time()\n    print(f'Original: {arr[:10]}... Sorted: {sorted_arr[:10]}... Time: {end - start:.6f}s')",
    "description": "test_quicksort (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_simulate_weather_724": {
    "name": "stack_simulate_weather_724",
    "pattern_type": "general",
    "code_template": "solar_factor = random.uniform(0.5, 1.0)\nwind_factor = random.uniform(0.3, 1.0)\nreturn (solar_factor, wind_factor)",
    "description": "simulate_weather (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_generate_energy_725": {
    "name": "stack_generate_energy_725",
    "pattern_type": "general",
    "code_template": "(solar_factor, wind_factor) = $P0.simulate_weather()\nsolar_energy = $P0.solar_capacity * solar_factor\nwind_energy = $P0.wind_capacity * wind_factor\n$P0.total_generated_solar += solar_energy\n$P0.total_generated_wind += wind_energy\nreturn (solar_energy, wind_energy)",
    "description": "generate_energy (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_consume_energy_726": {
    "name": "stack_consume_energy_726",
    "pattern_type": "general",
    "code_template": "$P0.total_consumed += $P1\nif $P1 <= $P0.battery_level:\n    $P0.battery_level -= $P1\n    $P0.discharge_cycles += 1\nelse:\n    $P0.battery_level = 0",
    "description": "consume_energy (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_store_energy_727": {
    "name": "stack_store_energy_727",
    "pattern_type": "general",
    "code_template": "if $P0.battery_level + $P1 <= $P0.battery_capacity:\n    $P0.battery_level += $P1\n    $P0.charge_cycles += 1\nelse:\n    $P0.battery_level = $P0.battery_capacity",
    "description": "store_energy (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_process_mixed_data_728": {
    "name": "stack_process_mixed_data_728",
    "pattern_type": "general",
    "code_template": "result_dict = {}\nfor item in $P0:\n    if isinstance(item, str):\n        if item not in result_dict:\n            result_dict[item] = 0\n        current_key = item\n    elif isinstance(item, int):\n        if current_key in result_dict:\n            result_dict[current_key] += item\nreturn result_dict",
    "description": "process_mixed_data (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_edge_729": {
    "name": "stack_add_edge_729",
    "pattern_type": "general",
    "code_template": "$P0.graph[$P1].append(($P2, $P3))\n$P0.graph[$P2].append(($P1, $P3))",
    "description": "add_edge (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_remove_edge_730": {
    "name": "stack_remove_edge_730",
    "pattern_type": "general",
    "code_template": "$P0.graph[$P1] = [item for item in $P0.graph[$P1] if item[0] != $P2]\n$P0.graph[$P2] = [item for item in $P0.graph[$P2] if item[0] != $P1]",
    "description": "remove_edge (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dijkstra_731": {
    "name": "stack_dijkstra_731",
    "pattern_type": "string",
    "code_template": "distances = {vertex: float('inf') for vertex in $P0.graph}\ndistances[$P1] = 0\npriority_queue = [(0, $P1)]\nwhile priority_queue:\n    (current_distance, current_vertex) = heapq.heappop(priority_queue)\n    if current_distance > distances[current_vertex]:\n        continue\n    for (neighbor, weight) in $P0.graph[current_vertex]:\n        distance = current_distance + weight\n        if distance < distances[neighbor]:\n            distances[neighbor] = distance\n            heapq.heappush(priority_queue, (distance, neighbor))\nreturn distances",
    "description": "dijkstra (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_max_beautiful_numbers_732": {
    "name": "stack_max_beautiful_numbers_732",
    "pattern_type": "general",
    "code_template": "$P0.sort()\nnum_beautiful = 0\nn = len($P0)\nfor i in range(n):\n    if i == n - 1 or $P1 == 0:\n        num_beautiful = n - i\n        break\n    diff = $P0[i + 1] - $P0[i]\n    total_increments_needed = diff * (i + 1)\n    if $P1 >= total_increments_needed:\n        $P1 -= total_increments_needed\n    else:\n        remaining_beautifuls = $P1 // (i + 1)\n        num_beautiful = i + 1 + remaining_beautifuls\n        $P1 = 0\nreturn num_beautiful",
    "description": "max_beautiful_numbers (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_push_733": {
    "name": "stack_push_733",
    "pattern_type": "general",
    "code_template": "if len($P0.stack) >= $P0.capacity:\n    $P0._expand_capacity()\n$P0.stack.append($P1)\nprint(f'Element {$P1} pushed to stack.')",
    "description": "push (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_pop_734": {
    "name": "stack_pop_734",
    "pattern_type": "general",
    "code_template": "if not $P0.stack:\n    return 'Stack is empty.'\nreturn $P0.stack.pop()",
    "description": "pop (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_calculate_checksum_735": {
    "name": "stack_calculate_checksum_735",
    "pattern_type": "general",
    "code_template": "return hashlib.sha256($P0).hexdigest()",
    "description": "calculate_checksum (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_handle_client_connection_736": {
    "name": "stack_handle_client_connection_736",
    "pattern_type": "general",
    "code_template": "try:\n    request = $P0.recv(BUFFER_SIZE).decode()\n    (command, filename) = request.split()\n    if command != 'REQ':\n        $P0.sendall(b'ERR Invalid command\\n')\n        return\n    if not os.path.isfile(filename):\n        $P0.sendall(b'ERR File not found\\n')\n        return\n    with open(filename, 'rb') as file:\n        data = file.read()\n        checksum = calculate_checksum(data)\n        $P0.sendall(data + b'\\n' + checksum.encode())\nexcept Exception as e:\n    print(f'Error: {e}')\n    $P0.sendall(b'ERR Internal server error\\n')\nfinally:\n    $P0.close()",
    "description": "handle_client_connection (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_request_file_737": {
    "name": "stack_request_file_737",
    "pattern_type": "general",
    "code_template": "client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nclient_socket.connect((HOST, PORT))\ntry:\n    client_socket.sendall(f'REQ {$P0}'.encode())\n    received_data = b''\n    while True:\n        part = client_socket.recv(BUFFER_SIZE)\n        if not part:\n            break\n        received_data += part\n    (data, received_checksum) = received_data.rsplit(b'\\n', 1)\n    calculated_checksum = calculate_checksum(data)\n    if received_checksum.decode() == calculated_checksum:\n        print('File received successfully and checksum verified.')\n    else:\n        print('Checksum mismatch. Data integrity compromised.')\nexcept Exception as e:\n    print(f'Error: {e}')\nfinally:\n    client_socket.close()",
    "description": "request_file (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_solveHanoi_738": {
    "name": "stack_solveHanoi_738",
    "pattern_type": "general",
    "code_template": "if $P0 == 1:\n    print(f'\u5c06\u76d8\u5b50 1 \u4ece {$P1} \u79fb\u52a8\u5230 {$P2}')\n    return\nsolveHanoi($P0 - 1, $P1, $P3, $P2)\nprint(f'\u5c06\u76d8\u5b50 {$P0} \u4ece {$P1} \u79fb\u52a8\u5230 {$P2}')\nsolveHanoi($P0 - 1, $P3, $P2, $P1)",
    "description": "solveHanoi (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_hash_answer_739": {
    "name": "stack_hash_answer_739",
    "pattern_type": "general",
    "code_template": "if $P1 is None:\n    $P1 = os.urandom(16)\nhash_obj = hashlib.sha256($P1 + $P0.encode())\nreturn ($P1, hash_obj.hexdigest())",
    "description": "hash_answer (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_store_user_security_question_740": {
    "name": "stack_store_user_security_question_740",
    "pattern_type": "general",
    "code_template": "database = {}\n(salt, hashed_answer) = hash_answer($P2)\ndatabase[$P0] = {'$P1': $P1, 'salt': salt, 'hashed_answer': hashed_answer}\nprint(f'Stored data for user {$P0}: {database[$P0]}')\nreturn database",
    "description": "store_user_security_question (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_verify_answer_741": {
    "name": "stack_verify_answer_741",
    "pattern_type": "general",
    "code_template": "user_data = $P2.get($P0)\nif not user_data:\n    print(f'No data found for user {$P0}')\n    return False\nsalt = user_data['salt']\nexpected_hashed_answer = user_data['hashed_answer']\n(_, provided_hashed_answer) = hash_answer($P1, salt)\nis_correct = expected_hashed_answer == provided_hashed_answer\nprint(f\"Verification for user {$P0}: {('Success' if is_correct else 'Failure')}\")\nreturn is_correct",
    "description": "verify_answer (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_insert_at_beginning_742": {
    "name": "stack_insert_at_beginning_742",
    "pattern_type": "general",
    "code_template": "new_node = Node($P1)\nnew_node.next = $P0.head\n$P0.head = new_node",
    "description": "insert_at_beginning (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_insert_at_end_743": {
    "name": "stack_insert_at_end_743",
    "pattern_type": "general",
    "code_template": "new_node = Node($P1)\nif not $P0.head:\n    $P0.head = new_node\n    return\ncurrent = $P0.head\nwhile current.next:\n    current = current.next\ncurrent.next = new_node",
    "description": "insert_at_end (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_delete_by_value_744": {
    "name": "stack_delete_by_value_744",
    "pattern_type": "general",
    "code_template": "if not $P0.head:\n    return\nif $P0.head.$P1 == $P1:\n    $P0.head = $P0.head.next\n    return\ncurrent = $P0.head\nwhile current.next and current.next.$P1 != $P1:\n    current = current.next\nif current.next:\n    current.next = current.next.next",
    "description": "delete_by_value (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_depth_limited_search_745": {
    "name": "stack_depth_limited_search_745",
    "pattern_type": "algorithm",
    "code_template": "visitation_frequency = {}\ndef dls(node, depth):\n    if depth > $P2:\n        return\n    if node in visitation_frequency:\n        visitation_frequency[node] += 1\n    else:\n        visitation_frequency[node] = 1\n    for neighbor in $P0.get(node, []):\n        dls(neighbor, depth + 1)\ndls($P1, 0)\nresult = [node for (node, frequency) in visitation_frequency.items() if frequency > $P3]\nreturn result",
    "description": "depth_limited_search (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dls_746": {
    "name": "stack_dls_746",
    "pattern_type": "general",
    "code_template": "if $P1 > depth_limit:\n    return\nif $P0 in visitation_frequency:\n    visitation_frequency[$P0] += 1\nelse:\n    visitation_frequency[$P0] = 1\nfor neighbor in adjacency_list.get($P0, []):\n    dls(neighbor, $P1 + 1)",
    "description": "dls (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_space_sensitive_sort_747": {
    "name": "stack_space_sensitive_sort_747",
    "pattern_type": "algorithm",
    "code_template": "sorted_list = [sorted(sublist, key=lambda x: x) for sublist in $P0]\nreturn sorted_list",
    "description": "space_sensitive_sort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_area_748": {
    "name": "stack_area_748",
    "pattern_type": "general",
    "code_template": "return math.pi * $P0.radius ** 2",
    "description": "area (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_perimeter_749": {
    "name": "stack_perimeter_749",
    "pattern_type": "general",
    "code_template": "return 2 * math.pi * $P0.radius",
    "description": "perimeter (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_shortest_path_in_maze_750": {
    "name": "stack_shortest_path_in_maze_750",
    "pattern_type": "general",
    "code_template": "if not $P0 or not $P0[0]:\n    return -1\n(n, m) = (len($P0), len($P0[0]))\nif $P0[0][0] == 1 or $P0[n - 1][m - 1] == 1:\n    return -1\ndirections = [(0, 1), (1, 0), (0, -1), (-1, 0)]\nqueue = deque([(0, 0, 1)])\nvisited = set((0, 0))\nwhile queue:\n    (x, y, path_length) = queue.popleft()\n    if x == n - 1 and y == m - 1:\n        return path_length\n    for (dx, dy) in directions:\n        (nx, ny) = (x + dx, y + dy)\n        if 0 <= nx < n and 0 <= ny < m and ($P0[nx][ny] == 0) and ((nx, ny) not in visited):\n            queue.append((nx, ny, path_length + 1))\n            visited.add((nx, ny))\nreturn -1",
    "description": "shortest_path_in_maze (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_generate_random_tree_751": {
    "name": "stack_generate_random_tree_751",
    "pattern_type": "general",
    "code_template": "if $P0 == 0 or random.random() > $P1:\n    return None\nroot = TreeNode(random.randint(1, 100))\nroot.left = generate_random_tree($P0 - 1, $P1)\nroot.right = generate_random_tree($P0 - 1, $P1)\nreturn root",
    "description": "generate_random_tree (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_recursive_752": {
    "name": "stack_dfs_recursive_752",
    "pattern_type": "general",
    "code_template": "if $P0 is None:\n    return []\nreturn [$P0.value] + dfs_recursive($P0.left) + dfs_recursive($P0.right)",
    "description": "dfs_recursive (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_iterative_753": {
    "name": "stack_dfs_iterative_753",
    "pattern_type": "general",
    "code_template": "if $P0 is None:\n    return []\n(stack, result) = ([$P0], [])\nwhile stack:\n    node = stack.pop()\n    result.append(node.value)\n    if node.right:\n        stack.append(node.right)\n    if node.left:\n        stack.append(node.left)\nreturn result",
    "description": "dfs_iterative (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_measure_performance_754": {
    "name": "stack_measure_performance_754",
    "pattern_type": "general",
    "code_template": "start_time = time.time()\ntracemalloc.start()\nresult = $P0(*args)\n(current, peak) = tracemalloc.get_traced_memory()\ntracemalloc.stop()\nend_time = time.time()\nreturn (end_time - start_time, peak)",
    "description": "measure_performance (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_efficiency_test_755": {
    "name": "stack_dfs_efficiency_test_755",
    "pattern_type": "general",
    "code_template": "print('Testing Recursive DFS:')\n(time_taken, memory_peak) = measure_performance(dfs_recursive, $P0)\nprint(f'Time: {time_taken:.4f} seconds, Memory: {memory_peak / 1024:.2f} KB')\nprint('Testing Iterative DFS:')\n(time_taken, memory_peak) = measure_performance(dfs_iterative, $P0)\nprint(f'Time: {time_taken:.4f} seconds, Memory: {memory_peak / 1024:.2f} KB')",
    "description": "dfs_efficiency_test (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_maxReplacementWithUppercase_756": {
    "name": "stack_maxReplacementWithUppercase_756",
    "pattern_type": "general",
    "code_template": "from collections import defaultdict\nchar_count = defaultdict(int)\nstart = 0\nmax_freq = 0\nmax_length = 0\nfor end in range(len($P0)):\n    char_count[$P0[end].upper()] += 1\n    max_freq = max(max_freq, char_count[$P0[end].upper()])\n    if end - start + 1 - max_freq > $P1:\n        char_count[$P0[start].upper()] -= 1\n        start += 1\n    max_length = max(max_length, end - start + 1)\nreturn max_length",
    "description": "maxReplacementWithUppercase (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_build_model_757": {
    "name": "stack_build_model_757",
    "pattern_type": "general",
    "code_template": "model = Sequential()\nmodel.add(Dense(units=64, activation='relu', input_shape=(X_train_scaled.shape[1],)))\nmodel.add(Dense(units=64, activation='relu'))\nmodel.add(Dense(units=1))\nmodel.compile(optimizer=tf.keras.optimizers.Adam($P0=$P0), loss='mean_squared_error', metrics=['mae'])\nreturn model",
    "description": "build_model (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_enqueue_758": {
    "name": "stack_enqueue_758",
    "pattern_type": "general",
    "code_template": "$P0.queue.append($P1)",
    "description": "enqueue (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dequeue_759": {
    "name": "stack_dequeue_759",
    "pattern_type": "general",
    "code_template": "if len($P0.queue) == 0:\n    return None\nreturn $P0.queue.pop(0)",
    "description": "dequeue (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_empty_760": {
    "name": "stack_is_empty_760",
    "pattern_type": "general",
    "code_template": "return len($P0.queue) == 0",
    "description": "is_empty (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_size_761": {
    "name": "stack_size_761",
    "pattern_type": "general",
    "code_template": "return len($P0.queue)",
    "description": "size (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_sorted_arrays_762": {
    "name": "stack_merge_sorted_arrays_762",
    "pattern_type": "algorithm",
    "code_template": "(i, j) = (0, 0)\nmerged_array = []\nwhile i < len($P0) and j < len($P1):\n    if $P0[i] <= $P1[j]:\n        merged_array.append($P0[i])\n        i += 1\n    else:\n        merged_array.append($P1[j])\n        j += 1\nwhile i < len($P0):\n    merged_array.append($P0[i])\n    i += 1\nwhile j < len($P1):\n    merged_array.append($P1[j])\n    j += 1\nreturn merged_array",
    "description": "merge_sorted_arrays (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_knapsack_763": {
    "name": "stack_knapsack_763",
    "pattern_type": "general",
    "code_template": "n = len($P0)\ndp = [[0] * ($P2 + 1) for _ in range(n + 1)]\nfor i in range(1, n + 1):\n    for w in range($P2 + 1):\n        if $P0[i - 1] <= w:\n            dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - $P0[i - 1]] + $P1[i - 1])\n        else:\n            dp[i][w] = dp[i - 1][w]\nreturn dp[n][$P2]",
    "description": "knapsack (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_test_n_queens_764": {
    "name": "stack_test_n_queens_764",
    "pattern_type": "general",
    "code_template": "assert solveNQueens(1) == 1, 'Test case N=1 failed'\nassert solveNQueens(4) == 2, 'Test case N=4 failed'\nassert solveNQueens(8) == 92, 'Test case N=8 failed'\nassert solveNQueens(10) == 724, 'Test case N=10 failed'\nprint('All test cases passed.')",
    "description": "test_n_queens (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_backtrack_765": {
    "name": "stack_backtrack_765",
    "pattern_type": "general",
    "code_template": "if $P0 == n:\n    return 1\ncount = 0\navailable_positions = (1 << n) - 1 & ~($P1 | $P2 | $P3)\nwhile available_positions:\n    position = available_positions & -available_positions\n    count += backtrack($P0 + 1, $P1 | position, ($P2 | position) << 1, ($P3 | position) >> 1)\n    available_positions &= available_positions - 1\nreturn count",
    "description": "backtrack (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_isMatch_766": {
    "name": "stack_isMatch_766",
    "pattern_type": "general",
    "code_template": "(m, n) = (len($P0), len($P1))\ndp = [[False] * (n + 1) for _ in range(m + 1)]\ndp[0][0] = True\nfor j in range(2, n + 1):\n    if $P1[j - 1] == '*':\n        dp[0][j] = dp[0][j - 2]\nfor i in range(1, m + 1):\n    for j in range(1, n + 1):\n        if $P1[j - 1] == '*':\n            dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] if $P1[j - 2] == $P0[i - 1] or $P1[j - 2] == '.' else False)\n        else:\n            dp[i][j] = dp[i - 1][j - 1] if $P1[j - 1] == $P0[i - 1] or $P1[j - 1] == '.' else False\nreturn dp[m][n]",
    "description": "isMatch (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_min_operations_to_non_decreasing_767": {
    "name": "stack_min_operations_to_non_decreasing_767",
    "pattern_type": "general",
    "code_template": "if not $P0:\n    return ($P0, 0)\noperations = 0\nn = len($P0)\nfor i in range(1, n):\n    if $P0[i] < $P0[i - 1]:\n        diff = $P0[i - 1] - $P0[i]\n        $P0[i] += diff\n        operations += diff\nreturn ($P0, operations)",
    "description": "min_operations_to_non_decreasing (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_train_model_768": {
    "name": "stack_train_model_768",
    "pattern_type": "general",
    "code_template": "for epoch in range($P4):\n    total_loss = 0\n    for (features, labels) in $P1:\n        $P3.zero_grad()\n        outputs = $P0(features)\n        loss = $P2(outputs.view(-1, outputs.shape[-1]), labels.view(-1))\n        loss.backward()\n        $P3.step()\n        total_loss += loss.item()\n    print(f'Epoch [{epoch + 1}/{$P4}], Loss: {total_loss:.4f}')",
    "description": "train_model (5 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_custom_limit_palindrome_769": {
    "name": "stack_custom_limit_palindrome_769",
    "pattern_type": "general",
    "code_template": "def expand_around_center(left: int, right: int) -> str:\n    while left >= 0 and right < len($P0) and ($P0[left] == $P0[right]):\n        left -= 1\n        right += 1\n    return $P0[left + 1:right]\nlongest_palindrome = ''\nfor i in range(len($P0)):\n    odd_palindrome = expand_around_center(i, i)\n    even_palindrome = expand_around_center(i, i + 1)\n    if len(odd_palindrome) > len(longest_palindrome) and len(odd_palindrome) <= $P1:\n        longest_palindrome = odd_palindrome\n    if len(even_palindrome) > len(longest_palindrome) and len(even_palindrome) <= $P1:\n        longest_palindrome = even_palindrome\nreturn longest_palindrome",
    "description": "custom_limit_palindrome (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_expand_around_center_770": {
    "name": "stack_expand_around_center_770",
    "pattern_type": "general",
    "code_template": "while $P0 >= 0 and $P1 < len(s) and (s[$P0] == s[$P1]):\n    $P0 -= 1\n    $P1 += 1\nreturn s[$P0 + 1:$P1]",
    "description": "expand_around_center (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_max_k_frequency_substring_771": {
    "name": "stack_max_k_frequency_substring_771",
    "pattern_type": "string",
    "code_template": "from collections import defaultdict\nif $P1 == 0:\n    return 0\nmax_length = 0\nleft = 0\nfreq = defaultdict(int)\nfor right in range(len($P0)):\n    freq[$P0[right]] += 1\n    while any((count > $P1 for count in freq.values())):\n        freq[$P0[left]] -= 1\n        if freq[$P0[left]] == 0:\n            del freq[$P0[left]]\n        left += 1\n    if all((count == $P1 for count in freq.values())):\n        max_length = max(max_length, right - left + 1)\nreturn max_length",
    "description": "max_k_frequency_substring (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dijkstra_772": {
    "name": "stack_dijkstra_772",
    "pattern_type": "string",
    "code_template": "distances = {node: float('inf') for node in $P0}\ndistances[$P1] = 0\npriority_queue = [(0, $P1)]\npredecessors = {node: None for node in $P0}\nwhile priority_queue:\n    (current_distance, current_node) = heapq.heappop(priority_queue)\n    if current_distance > distances[current_node]:\n        continue\n    for (neighbor, weight) in $P0[current_node]:\n        distance = current_distance + weight\n        if distance < distances[neighbor]:\n            distances[neighbor] = distance\n            predecessors[neighbor] = current_node\n            heapq.heappush(priority_queue, (distance, neighbor))\npath = []\nwhile $P2 is not None:\n    path.insert(0, $P2)\n    $P2 = predecessors[$P2]\nif path[0] != $P1:\n    return (None, float('inf'))\nreturn (path, distances[path[-1]])",
    "description": "dijkstra (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_determine_parity_773": {
    "name": "stack_determine_parity_773",
    "pattern_type": "general",
    "code_template": "if $P0 % 2 == 0:\n    return 'Even'\nelse:\n    return 'Odd'",
    "description": "determine_parity (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_max_tower_heights_sum_774": {
    "name": "stack_max_tower_heights_sum_774",
    "pattern_type": "general",
    "code_template": "results = []\nfor case in $P1:\n    (x, d, n) = case\n    total_sum = n * x + d * (n * (n - 1) // 2)\n    results.append(total_sum)\nreturn results",
    "description": "max_tower_heights_sum (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_lcs_top_down_775": {
    "name": "stack_lcs_top_down_775",
    "pattern_type": "general",
    "code_template": "memo = {}\ndef recurse(m, n):\n    if m == 0 or n == 0:\n        return 0\n    if (m, n) in memo:\n        return memo[m, n]\n    if $P0[m - 1] == $P1[n - 1]:\n        memo[m, n] = 1 + recurse(m - 1, n - 1)\n    else:\n        memo[m, n] = max(recurse(m, n - 1), recurse(m - 1, n))\n    return memo[m, n]\nresult = recurse(len($P0), len($P1))\nvisualize_memoization_table($P0, $P1, memo)\nreturn result",
    "description": "lcs_top_down (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_lcs_bottom_up_776": {
    "name": "stack_lcs_bottom_up_776",
    "pattern_type": "general",
    "code_template": "(m, n) = (len($P0), len($P1))\ndp = np.zeros((m + 1, n + 1), dtype=int)\nfor i in range(1, m + 1):\n    for j in range(1, n + 1):\n        if $P0[i - 1] == $P1[j - 1]:\n            dp[i, j] = dp[i - 1, j - 1] + 1\n        else:\n            dp[i, j] = max(dp[i - 1, j], dp[i, j - 1])\nvisualize_dp_table($P0, $P1, dp)\nlcs_str = []\nwhile m > 0 and n > 0:\n    if $P0[m - 1] == $P1[n - 1]:\n        lcs_str.append($P0[m - 1])\n        m -= 1\n        n -= 1\n    elif dp[m - 1, n] >= dp[m, n - 1]:\n        m -= 1\n    else:\n        n -= 1\nlcs_str.reverse()\nreturn (dp[-1, -1], ''.join(lcs_str))",
    "description": "lcs_bottom_up (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_visualize_dp_table_777": {
    "name": "stack_visualize_dp_table_777",
    "pattern_type": "general",
    "code_template": "plt.imshow($P2, cmap='viridis', interpolation='nearest')\nplt.title('DP Table (Bottom-Up)')\nplt.xlabel('String $P1')\nplt.ylabel('String $P0')\nplt.colorbar(label='LCS Length')\nplt.xticks(ticks=np.arange(len($P1) + 1), labels=[''] + list($P1))\nplt.yticks(ticks=np.arange(len($P0) + 1), labels=[''] + list($P0))\nplt.show()",
    "description": "visualize_dp_table (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_recurse_778": {
    "name": "stack_recurse_778",
    "pattern_type": "general",
    "code_template": "if $P0 == 0 or $P1 == 0:\n    return 0\nif ($P0, $P1) in memo:\n    return memo[$P0, $P1]\nif X[$P0 - 1] == Y[$P1 - 1]:\n    memo[$P0, $P1] = 1 + recurse($P0 - 1, $P1 - 1)\nelse:\n    memo[$P0, $P1] = max(recurse($P0, $P1 - 1), recurse($P0 - 1, $P1))\nreturn memo[$P0, $P1]",
    "description": "recurse (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_enqueue_779": {
    "name": "stack_enqueue_779",
    "pattern_type": "general",
    "code_template": "if $P0.count == $P0.capacity:\n    raise Exception('Buffer is full')\n$P0.buffer[$P0.tail] = $P1\n$P0.tail = ($P0.tail + 1) % $P0.capacity\n$P0.count += 1",
    "description": "enqueue (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dequeue_780": {
    "name": "stack_dequeue_780",
    "pattern_type": "general",
    "code_template": "if $P0.count == 0:\n    raise Exception('Buffer is empty')\nvalue = $P0.buffer[$P0.head]\n$P0.head = ($P0.head + 1) % $P0.capacity\n$P0.count -= 1\nreturn value",
    "description": "dequeue (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_size_781": {
    "name": "stack_size_781",
    "pattern_type": "general",
    "code_template": "return $P0.count",
    "description": "size (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_example_usage_782": {
    "name": "stack_example_usage_782",
    "pattern_type": "general",
    "code_template": "original_text = 'Hello, World!'\nshift_key = 3\nencrypted_text = caesar_cipher(original_text, shift_key, encrypt=True)\nprint('Encrypted:', encrypted_text)\ndecrypted_text = caesar_cipher(encrypted_text, shift_key, encrypt=False)\nprint('Decrypted:', decrypted_text)",
    "description": "example_usage (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_update_matrix_783": {
    "name": "stack_update_matrix_783",
    "pattern_type": "general",
    "code_template": "$P0.update($P1)\nreturn $P0",
    "description": "update_matrix (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_paths_784": {
    "name": "stack_find_paths_784",
    "pattern_type": "algorithm",
    "code_template": "def dfs(node, path, path_sum):\n    if node == $P2:\n        if path_sum % $P3 == 0 and $P4(path):\n            results.append(list(path))\n        return\n    for neighbor in $P0[node]:\n        if neighbor not in visited:\n            visited.add(neighbor)\n            bisect.insort(path, values[neighbor])\n            dfs(neighbor, path, path_sum + values[neighbor])\n            path.remove(values[neighbor])\n            visited.remove(neighbor)\nresults = []\nvisited = set()\nvisited.add($P1)\ndfs($P1, [values[$P1]], values[$P1])\nreturn results",
    "description": "find_paths (5 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_check_order_785": {
    "name": "stack_check_order_785",
    "pattern_type": "general",
    "code_template": "return $P0 == sorted($P0)",
    "description": "check_order (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_786": {
    "name": "stack_dfs_786",
    "pattern_type": "general",
    "code_template": "if $P0 == end:\n    if $P2 % c == 0 and check_order($P1):\n        results.append(list($P1))\n    return\nfor neighbor in graph[$P0]:\n    if neighbor not in visited:\n        visited.add(neighbor)\n        bisect.insort($P1, values[neighbor])\n        dfs(neighbor, $P1, $P2 + values[neighbor])\n        $P1.remove(values[neighbor])\n        visited.remove(neighbor)",
    "description": "dfs (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_minPathSum_787": {
    "name": "stack_minPathSum_787",
    "pattern_type": "general",
    "code_template": "if not $P0 or not $P0[0]:\n    return 0\n(m, n) = (len($P0), len($P0[0]))\ndp = [0] * n\ndp[0] = $P0[0][0]\nfor j in range(1, n):\n    dp[j] = dp[j - 1] + $P0[0][j]\nfor i in range(1, m):\n    dp[0] += $P0[i][0]\n    for j in range(1, n):\n        dp[j] = min(dp[j], dp[j - 1]) + $P0[i][j]\nreturn dp[-1]",
    "description": "minPathSum (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_num_788": {
    "name": "stack_add_num_788",
    "pattern_type": "general",
    "code_template": "if not $P0.lower_half or $P1 <= -$P0.lower_half[0]:\n    heapq.heappush($P0.lower_half, -$P1)\nelse:\n    heapq.heappush($P0.upper_half, $P1)\nif len($P0.lower_half) > len($P0.upper_half) + 1:\n    moved_value = -heapq.heappop($P0.lower_half)\n    heapq.heappush($P0.upper_half, moved_value)\nelif len($P0.upper_half) > len($P0.lower_half):\n    moved_value = heapq.heappop($P0.upper_half)\n    heapq.heappush($P0.lower_half, -moved_value)",
    "description": "add_num (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_median_789": {
    "name": "stack_find_median_789",
    "pattern_type": "algorithm",
    "code_template": "if len($P0.lower_half) > len($P0.upper_half):\n    return -$P0.lower_half[0]\nreturn (-$P0.lower_half[0] + $P0.upper_half[0]) / 2",
    "description": "find_median (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_canMakeEqualBySwap_790": {
    "name": "stack_canMakeEqualBySwap_790",
    "pattern_type": "general",
    "code_template": "if len($P0) != len($P1):\n    return False\nmismatches = []\nfor i in range(len($P0)):\n    if $P0[i] != $P1[i]:\n        mismatches.append(i)\nif len(mismatches) == 0:\n    return True\nelif len(mismatches) == 2:\n    (i, j) = mismatches\n    s1_swapped = list($P0)\n    (s1_swapped[i], s1_swapped[j]) = (s1_swapped[j], s1_swapped[i])\n    return ''.join(s1_swapped) == $P1\nelse:\n    return False",
    "description": "canMakeEqualBySwap (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_calculate_hash_791": {
    "name": "stack_calculate_hash_791",
    "pattern_type": "general",
    "code_template": "data = f'{$P0.index}{$P0.timestamp}{$P0.transactions}{$P0.previous_hash}{$P0.nonce}'\nreturn hashlib.sha256(data.encode()).hexdigest()",
    "description": "calculate_hash (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_create_genesis_block_792": {
    "name": "stack_create_genesis_block_792",
    "pattern_type": "general",
    "code_template": "return Block(0, [], '0')",
    "description": "create_genesis_block (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_latest_block_793": {
    "name": "stack_get_latest_block_793",
    "pattern_type": "general",
    "code_template": "return $P0.chain[-1]",
    "description": "get_latest_block (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_rotateMatrix90Clockwise_794": {
    "name": "stack_rotateMatrix90Clockwise_794",
    "pattern_type": "general",
    "code_template": "n = len($P0)\nfor i in range(n):\n    for j in range(i, n):\n        ($P0[i][j], $P0[j][i]) = ($P0[j][i], $P0[i][j])\nfor i in range(n):\n    $P0[i].reverse()",
    "description": "rotateMatrix90Clockwise (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_relu_795": {
    "name": "stack_relu_795",
    "pattern_type": "general",
    "code_template": "return np.maximum(0, $P0)",
    "description": "relu (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_derivative_relu_796": {
    "name": "stack_derivative_relu_796",
    "pattern_type": "general",
    "code_template": "return np.where($P0 > 0, 1, 0)",
    "description": "derivative_relu (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_solve_n_queens_797": {
    "name": "stack_solve_n_queens_797",
    "pattern_type": "general",
    "code_template": "def is_safe(board, row, col):\n    for i in range(row):\n        if board[i][col] == 'Q':\n            return False\n    (i, j) = (row, col)\n    while i >= 0 and j >= 0:\n        if board[i][j] == 'Q':\n            return False\n        i -= 1\n        j -= 1\n    (i, j) = (row, col)\n    while i >= 0 and j < $P0:\n        if board[i][j] == 'Q':\n            return False\n        i -= 1\n        j += 1\n    return True\ndef solve(board, row):\n    if row == $P0:\n        solution = []\n        for i in range($P0):\n            solution.append(''.join(board[i]))\n        results.append(solution)\n        return\n    for col in range($P0):\n        if is_safe(board, row, col):\n            board[row][col] = 'Q'\n            solve(board, row + 1)\n            board[row][col] = '.'\nresults = []\nboard = [['.' for _ in range($P0)] for _ in range($P0)]\nsolve(board, 0)\nreturn results",
    "description": "solve_n_queens (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_safe_798": {
    "name": "stack_is_safe_798",
    "pattern_type": "general",
    "code_template": "for i in range($P1):\n    if $P0[i][$P2] == 'Q':\n        return False\n(i, j) = ($P1, $P2)\nwhile i >= 0 and j >= 0:\n    if $P0[i][j] == 'Q':\n        return False\n    i -= 1\n    j -= 1\n(i, j) = ($P1, $P2)\nwhile i >= 0 and j < n:\n    if $P0[i][j] == 'Q':\n        return False\n    i -= 1\n    j += 1\nreturn True",
    "description": "is_safe (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_solve_799": {
    "name": "stack_solve_799",
    "pattern_type": "general",
    "code_template": "if $P1 == n:\n    solution = []\n    for i in range(n):\n        solution.append(''.join($P0[i]))\n    results.append(solution)\n    return\nfor col in range(n):\n    if is_safe($P0, $P1, col):\n        $P0[$P1][col] = 'Q'\n        solve($P0, $P1 + 1)\n        $P0[$P1][col] = '.'",
    "description": "solve (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_early_termination_bubble_sort_800": {
    "name": "stack_early_termination_bubble_sort_800",
    "pattern_type": "algorithm",
    "code_template": "n = len($P0)\nfor i in range(n):\n    swapped = False\n    for j in range(0, n - i - 1):\n        if $P0[j] > $P0[j + 1]:\n            ($P0[j], $P0[j + 1]) = ($P0[j + 1], $P0[j])\n            swapped = True\n    if not swapped:\n        break\nreturn $P0",
    "description": "early_termination_bubble_sort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_test_rbtree_801": {
    "name": "stack_test_rbtree_801",
    "pattern_type": "general",
    "code_template": "rbt = RedBlackTree()\nelements = [20, 15, 25, 10, 5, 1, 30]\nfor el in elements:\n    rbt.insert_rbtree(el)",
    "description": "test_rbtree (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_left_rotate_802": {
    "name": "stack_left_rotate_802",
    "pattern_type": "general",
    "code_template": "y = $P1.right\n$P1.right = y.left\nif y.left != $P0.NIL:\n    y.left.parent = $P1\ny.parent = $P1.parent\nif $P1.parent == None:\n    $P0.root = y\nelif $P1 == $P1.parent.left:\n    $P1.parent.left = y\nelse:\n    $P1.parent.right = y\ny.left = $P1\n$P1.parent = y",
    "description": "left_rotate (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_right_rotate_803": {
    "name": "stack_right_rotate_803",
    "pattern_type": "general",
    "code_template": "x = $P1.left\n$P1.left = x.right\nif x.right != $P0.NIL:\n    x.right.parent = $P1\nx.parent = $P1.parent\nif $P1.parent == None:\n    $P0.root = x\nelif $P1 == $P1.parent.right:\n    $P1.parent.right = x\nelse:\n    $P1.parent.left = x\nx.right = $P1\n$P1.parent = x",
    "description": "right_rotate (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_count_inversions_804": {
    "name": "stack_count_inversions_804",
    "pattern_type": "general",
    "code_template": "temp_arr = [0] * len($P0)\nreturn merge_sort_and_count($P0, temp_arr, 0, len($P0) - 1)",
    "description": "count_inversions (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_sorted_arrays_805": {
    "name": "stack_merge_sorted_arrays_805",
    "pattern_type": "algorithm",
    "code_template": "(i, j) = (0, 0)\nmerged = []\nwhile i < len($P0) and j < len($P1):\n    if $P0[i] < $P1[j]:\n        merged.append($P0[i])\n        i += 1\n    else:\n        merged.append($P1[j])\n        j += 1\nwhile i < len($P0):\n    merged.append($P0[i])\n    i += 1\nwhile j < len($P1):\n    merged.append($P1[j])\n    j += 1\nreturn merged",
    "description": "merge_sorted_arrays (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_optimalReplacement_806": {
    "name": "stack_optimalReplacement_806",
    "pattern_type": "general",
    "code_template": "used = set()\nnext_candidate = 1\nfor i in range(len($P0)):\n    if $P0[i] in used:\n        while next_candidate in used or next_candidate > $P1:\n            next_candidate += 1\n        if next_candidate <= $P1:\n            $P0[i] = next_candidate\n            used.add(next_candidate)\n    else:\n        used.add($P0[i])\nreturn $P0",
    "description": "optimalReplacement (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_check_conflicts_807": {
    "name": "stack_check_conflicts_807",
    "pattern_type": "general",
    "code_template": "unique_times = set($P0)\nreturn len(unique_times) < len($P0)",
    "description": "check_conflicts (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_split_and_fill_808": {
    "name": "stack_split_and_fill_808",
    "pattern_type": "general",
    "code_template": "result = []\nfor i in range(0, len($P0), $P1):\n    segment = $P0[i:i + $P1]\n    if len(segment) < $P1:\n        segment += $P2 * ($P1 - len(segment))\n    result.append(segment)\nreturn result",
    "description": "split_and_fill (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_findCaseInsensitivePalindromes_809": {
    "name": "stack_findCaseInsensitivePalindromes_809",
    "pattern_type": "algorithm",
    "code_template": "$P0 = $P0.lower()\nwords = $P0.split()\npalindrome_count = {}\nfor word in words:\n    if word == word[::-1]:\n        if word in palindrome_count:\n            palindrome_count[word] += 1\n        else:\n            palindrome_count[word] = 1\nreturn palindrome_count",
    "description": "findCaseInsensitivePalindromes (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_to_cart_810": {
    "name": "stack_add_to_cart_810",
    "pattern_type": "general",
    "code_template": "$P0.items.append($P1)\nreturn f'Added {$P1.name} to cart.'",
    "description": "add_to_cart (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_remove_from_cart_811": {
    "name": "stack_remove_from_cart_811",
    "pattern_type": "general",
    "code_template": "for product in $P0.items:\n    if product.id == $P1:\n        $P0.items.remove(product)\n        return f'Removed {product.name} from cart.'\nreturn 'Product not found in cart.'",
    "description": "remove_from_cart (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_fibonacci_memo_812": {
    "name": "stack_fibonacci_memo_812",
    "pattern_type": "math",
    "code_template": "if $P1 is None:\n    $P1 = {}\nif $P0 in $P1:\n    return $P1[$P0]\nif $P0 <= 1:\n    return $P0\n$P1[$P0] = fibonacci_memo($P0 - 1, $P1) + fibonacci_memo($P0 - 2, $P1)\nreturn $P1[$P0]",
    "description": "fibonacci_memo (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_predict_future_profits_813": {
    "name": "stack_predict_future_profits_813",
    "pattern_type": "general",
    "code_template": "future_profits = []\nhistory_length = len($P0)\nfor i in range($P1):\n    next_profit = fibonacci_memo(history_length + i) if history_length + i < len($P0) else $P0[-1]\n    future_profits.append(next_profit)\nreturn future_profits",
    "description": "predict_future_profits (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_greedy_coin_change_814": {
    "name": "stack_greedy_coin_change_814",
    "pattern_type": "general",
    "code_template": "$P0.sort(reverse=True)\nresult = {}\nfor coin in $P0:\n    if $P1 >= coin:\n        num_coins = $P1 // coin\n        $P1 -= num_coins * coin\n        result[coin] = num_coins\nif $P1 != 0:\n    return None\nreturn result",
    "description": "greedy_coin_change (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dp_coin_change_815": {
    "name": "stack_dp_coin_change_815",
    "pattern_type": "general",
    "code_template": "dp = [float('inf')] * ($P1 + 1)\ndp[0] = 0\nfor amt in range(1, $P1 + 1):\n    for coin in $P0:\n        if coin <= amt:\n            dp[amt] = min(dp[amt], dp[amt - coin] + 1)\nreturn dp[$P1] if dp[$P1] != float('inf') else None",
    "description": "dp_coin_change (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_test_coin_change_816": {
    "name": "stack_test_coin_change_816",
    "pattern_type": "general",
    "code_template": "greedy_result = greedy_coin_change($P0, $P1)\ndp_result = dp_coin_change($P0, $P1)\nprint('Denominations:', $P0)\nprint('Amount:', $P1)\nprint('Greedy Result:', greedy_result)\nprint('DP Result:', dp_result)\nif greedy_result is None or sum(greedy_result.values()) != dp_result:\n    return 'Greedy failed for this set.'\nelse:\n    return 'Greedy succeeded for this set.'",
    "description": "test_coin_change (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_exponential_search_817": {
    "name": "stack_exponential_search_817",
    "pattern_type": "algorithm",
    "code_template": "if not $P0:\n    return -1\nbound = 1\nwhile bound < len($P0) and $P0[bound] < $P1:\n    bound *= 2\nleft = bound // 2\nright = min(bound, len($P0))\nreturn binary_search($P0, $P1, left, right)",
    "description": "exponential_search (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_binary_search_818": {
    "name": "stack_binary_search_818",
    "pattern_type": "algorithm",
    "code_template": "while $P2 < $P3:\n    mid = $P2 + ($P3 - $P2) // 2\n    if $P0[mid] == $P1:\n        return mid\n    elif $P0[mid] < $P1:\n        $P2 = mid + 1\n    else:\n        $P3 = mid\nreturn -1",
    "description": "binary_search (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_delete_819": {
    "name": "stack_delete_819",
    "pattern_type": "general",
    "code_template": "current = $P0.head\nprevious = None\nwhile current and current.$P1 != $P1:\n    previous = current\n    current = current.next\nif not current:\n    return\nif not previous:\n    $P0.head = current.next\nelse:\n    previous.next = current.next",
    "description": "delete (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_reverse_820": {
    "name": "stack_reverse_820",
    "pattern_type": "general",
    "code_template": "previous = None\ncurrent = $P0.head\nwhile current:\n    next_node = current.next\n    current.next = previous\n    previous = current\n    current = next_node\n$P0.head = previous",
    "description": "reverse (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_closest_pair_to_target_821": {
    "name": "stack_closest_pair_to_target_821",
    "pattern_type": "general",
    "code_template": "$P0.sort()\nleft = 0\nright = len($P0) - 1\nclosest_sum = float('inf')\nclosest_pair = (None, None)\nwhile left < right:\n    current_sum = $P0[left] + $P0[right]\n    if abs($P1 - current_sum) < abs($P1 - closest_sum):\n        closest_sum = current_sum\n        closest_pair = ($P0[left], $P0[right])\n    if current_sum < $P1:\n        left += 1\n    elif current_sum > $P1:\n        right -= 1\n    else:\n        return ($P0[left], $P0[right])\nreturn closest_pair",
    "description": "closest_pair_to_target (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_searchRange_822": {
    "name": "stack_searchRange_822",
    "pattern_type": "algorithm",
    "code_template": "def findStartingIndex($P0, $P1):\n    (left, right) = (0, len($P0) - 1)\n    start_index = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if $P0[mid] == $P1:\n            start_index = mid\n            right = mid - 1\n        elif $P0[mid] < $P1:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return start_index\ndef findEndingIndex($P0, $P1):\n    (left, right) = (0, len($P0) - 1)\n    end_index = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if $P0[mid] == $P1:\n            end_index = mid\n            left = mid + 1\n        elif $P0[mid] < $P1:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return end_index\nstart = findStartingIndex($P0, $P1)\nend = findEndingIndex($P0, $P1)\nreturn [start, end]",
    "description": "searchRange (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_findStartingIndex_823": {
    "name": "stack_findStartingIndex_823",
    "pattern_type": "algorithm",
    "code_template": "(left, right) = (0, len($P0) - 1)\nstart_index = -1\nwhile left <= right:\n    mid = (left + right) // 2\n    if $P0[mid] == $P1:\n        start_index = mid\n        right = mid - 1\n    elif $P0[mid] < $P1:\n        left = mid + 1\n    else:\n        right = mid - 1\nreturn start_index",
    "description": "findStartingIndex (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_findEndingIndex_824": {
    "name": "stack_findEndingIndex_824",
    "pattern_type": "algorithm",
    "code_template": "(left, right) = (0, len($P0) - 1)\nend_index = -1\nwhile left <= right:\n    mid = (left + right) // 2\n    if $P0[mid] == $P1:\n        end_index = mid\n        left = mid + 1\n    elif $P0[mid] < $P1:\n        left = mid + 1\n    else:\n        right = mid - 1\nreturn end_index",
    "description": "findEndingIndex (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_towerOfHanoi_825": {
    "name": "stack_towerOfHanoi_825",
    "pattern_type": "general",
    "code_template": "if $P0 == 1:\n    print(f'Move disk 1 from {$P1} to {$P2}')\n    return\ntowerOfHanoi($P0 - 1, $P1, $P3, $P2)\nprint(f'Move disk {$P0} from {$P1} to {$P2}')\ntowerOfHanoi($P0 - 1, $P3, $P2, $P1)",
    "description": "towerOfHanoi (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_826": {
    "name": "stack_merge_826",
    "pattern_type": "general",
    "code_template": "merged = []\nleft_index = right_index = 0\nwhile left_index < len($P0) and right_index < len($P1):\n    if $P0[left_index] < $P1[right_index]:\n        merged.append($P0[left_index])\n        left_index += 1\n    else:\n        merged.append($P1[right_index])\n        right_index += 1\nmerged.extend($P0[left_index:])\nmerged.extend($P1[right_index:])\nreturn merged",
    "description": "merge (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_kth_largest_827": {
    "name": "stack_find_kth_largest_827",
    "pattern_type": "algorithm",
    "code_template": "if not $P0 or $P1 <= 0 or $P1 > len($P0):\n    return None\nsorted_nums = sorted($P0, reverse=True)\nreturn sorted_nums[$P1 - 1]",
    "description": "find_kth_largest (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_edge_828": {
    "name": "stack_add_edge_828",
    "pattern_type": "general",
    "code_template": "if $P1 not in $P0.adjacency_list:\n    $P0.adjacency_list[$P1] = []\n$P0.adjacency_list[$P1].append(($P2, $P3))",
    "description": "add_edge (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_shortest_path_829": {
    "name": "stack_shortest_path_829",
    "pattern_type": "general",
    "code_template": "distances = {node: float('infinity') for node in $P0.adjacency_list}\ndistances[$P1] = 0\npriority_queue = [(0, $P1)]\nprevious_nodes = {node: None for node in $P0.adjacency_list}\nwhile priority_queue:\n    (current_distance, current_node) = heapq.heappop(priority_queue)\n    if current_distance > distances[current_node]:\n        continue\n    for (neighbor, weight) in $P0.adjacency_list.get(current_node, []):\n        distance = current_distance + weight\n        if distance < distances[neighbor]:\n            distances[neighbor] = distance\n            previous_nodes[neighbor] = current_node\n            heapq.heappush(priority_queue, (distance, neighbor))\npath = []\nwhile $P2:\n    path.append($P2)\n    $P2 = previous_nodes[$P2]\nreturn path[::-1]",
    "description": "shortest_path (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_830": {
    "name": "stack_dfs_830",
    "pattern_type": "general",
    "code_template": "if visited[$P0] == -1:\n    return True\nif visited[$P0] == 1:\n    return False\nvisited[$P0] = -1\nfor neighbor in graph[$P0]:\n    if dfs(neighbor):\n        return True\nvisited[$P0] = 1\nreturn False",
    "description": "dfs (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_predictGrowth_831": {
    "name": "stack_predictGrowth_831",
    "pattern_type": "general",
    "code_template": "from collections import defaultdict\nadj_list = defaultdict(list)\nfor (u, v) in $P0:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\ngrow_threshold = $P2['threshold']\nmemo = {}\ndef dfs(node, parent):\n    if (node, parent) in memo:\n        return memo[node, parent]\n    growth = $P1[node]\n    for neighbor in adj_list[node]:\n        if neighbor != parent:\n            child_growth = dfs(neighbor, node)\n            growth += max(0, child_growth - grow_threshold)\n    memo[node, parent] = growth\n    return growth\nreturn dfs(0, -1)",
    "description": "predictGrowth (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_832": {
    "name": "stack_dfs_832",
    "pattern_type": "general",
    "code_template": "if ($P0, $P1) in memo:\n    return memo[$P0, $P1]\ngrowth = initial_growth[$P0]\nfor neighbor in adj_list[$P0]:\n    if neighbor != $P1:\n        child_growth = dfs(neighbor, $P0)\n        growth += max(0, child_growth - grow_threshold)\nmemo[$P0, $P1] = growth\nreturn growth",
    "description": "dfs (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_push_833": {
    "name": "stack_push_833",
    "pattern_type": "general",
    "code_template": "$P0.main_stack.append($P1)\nif not $P0.min_stack or $P1 <= $P0.min_stack[-1]:\n    $P0.min_stack.append($P1)",
    "description": "push (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_pop_834": {
    "name": "stack_pop_834",
    "pattern_type": "general",
    "code_template": "if not $P0.main_stack:\n    raise Exception('Stack is empty')\ntop_element = $P0.main_stack.pop()\nif top_element == $P0.min_stack[-1]:\n    $P0.min_stack.pop()",
    "description": "pop (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_min_835": {
    "name": "stack_min_835",
    "pattern_type": "general",
    "code_template": "if not $P0.min_stack:\n    raise Exception('Stack is empty')\nreturn $P0.min_stack[-1]",
    "description": "min (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_handle_conflict_836": {
    "name": "stack_handle_conflict_836",
    "pattern_type": "general",
    "code_template": "reputation_change = -1\n$P0.reputation += reputation_change\n$P1.reputation += reputation_change",
    "description": "handle_conflict (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_simulate_conflicts_837": {
    "name": "stack_simulate_conflicts_837",
    "pattern_type": "general",
    "code_template": "for house in $P0:\n    for i in range(len(house)):\n        for j in range(i + 1, len(house)):\n            resident1 = house[i]\n            resident2 = house[j]\n            if resident1.stance != resident2.stance:\n                print(f'Conflict between {resident1.name} and {resident2.name}')\n                handle_conflict(resident1, resident2)",
    "description": "simulate_conflicts (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_print_reputations_838": {
    "name": "stack_print_reputations_838",
    "pattern_type": "general",
    "code_template": "for house in $P0:\n    for resident in house:\n        print(resident)",
    "description": "print_reputations (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_edge_839": {
    "name": "stack_add_edge_839",
    "pattern_type": "general",
    "code_template": "if $P1 not in $P0.graph:\n    $P0.graph[$P1] = []\n$P0.graph[$P1].append(($P2, $P3))",
    "description": "add_edge (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dijkstra_840": {
    "name": "stack_dijkstra_840",
    "pattern_type": "string",
    "code_template": "priority_queue = []\nheapq.heappush(priority_queue, (0, $P1))\ndistances = {node: float('inf') for node in $P0.graph}\ndistances[$P1] = 0\nwhile priority_queue:\n    (current_distance, current_node) = heapq.heappop(priority_queue)\n    print(f'Visiting node {current_node} with current distance {current_distance}')\n    if current_distance > distances[current_node]:\n        continue\n    for (neighbor, weight) in $P0.graph.get(current_node, []):\n        distance = current_distance + weight\n        if distance < distances[neighbor]:\n            print(f'Updating distance for node {neighbor} to {distance}')\n            distances[neighbor] = distance\n            heapq.heappush(priority_queue, (distance, neighbor))\nreturn distances",
    "description": "dijkstra (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_fit_841": {
    "name": "stack_fit_841",
    "pattern_type": "general",
    "code_template": "$P0.scaler.fit($P1)\nreturn $P0",
    "description": "fit (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_transform_842": {
    "name": "stack_transform_842",
    "pattern_type": "general",
    "code_template": "return $P0.scaler.transform($P1)",
    "description": "transform (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_findModuloSequence_843": {
    "name": "stack_findModuloSequence_843",
    "pattern_type": "algorithm",
    "code_template": "MOD = 10 ** 9 + 7\ntotal_sum = 0\nfor i in range(len($P0)):\n    power_mod_m = pow($P0[i], i, $P1)\n    total_sum = (total_sum + power_mod_m) % MOD\nreturn total_sum",
    "description": "findModuloSequence (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_multiply_matrices_844": {
    "name": "stack_multiply_matrices_844",
    "pattern_type": "general",
    "code_template": "(rows_a, cols_a) = (len($P0), len($P0[0]))\n(rows_b, cols_b) = (len($P1), len($P1[0]))\nif cols_a != rows_b:\n    return 'Dimension mismatch. Cannot multiply the matrices.'\nresult = [[0 for _ in range(cols_b)] for _ in range(rows_a)]\nfor i in range(rows_a):\n    for j in range(cols_b):\n        for k in range(cols_a):\n            result[i][j] += $P0[i][k] * $P1[k][j]\nreturn result",
    "description": "multiply_matrices (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_transpose_matrix_845": {
    "name": "stack_transpose_matrix_845",
    "pattern_type": "general",
    "code_template": "(rows, cols) = (len($P0), len($P0[0]))\ntransposed = [[0 for _ in range(rows)] for _ in range(cols)]\nfor i in range(rows):\n    for j in range(cols):\n        transposed[j][i] = $P0[i][j]\nreturn transposed",
    "description": "transpose_matrix (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_allocate_resources_846": {
    "name": "stack_allocate_resources_846",
    "pattern_type": "general",
    "code_template": "n = len($P0)\nmax_fault_tolerance = max($P1)\ndp = [[float('inf')] * (max_fault_tolerance + 1) for _ in range(n + 1)]\ndp[0][0] = 0\nfor i in range(1, n + 1):\n    (fault_tolerance, cost) = $P0[i - 1]\n    for j in range(max_fault_tolerance + 1):\n        dp[i][j] = dp[i - 1][j]\n        if j >= fault_tolerance:\n            dp[i][j] = min(dp[i][j], dp[i - 1][j - fault_tolerance] + cost)\nresult = []\nfor ft_level in $P1:\n    cost = min((dp[i][ft_level] for i in range(1, n + 1)))\n    result.append(cost)\nreturn result",
    "description": "allocate_resources (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_levenshtein_recursive_847": {
    "name": "stack_levenshtein_recursive_847",
    "pattern_type": "general",
    "code_template": "if len($P0) == 0:\n    return len($P1)\nif len($P1) == 0:\n    return len($P0)\nif $P0[0] == $P1[0]:\n    return levenshtein_recursive($P0[1:], $P1[1:])\ninsert = levenshtein_recursive($P0, $P1[1:])\ndelete = levenshtein_recursive($P0[1:], $P1)\nreplace = levenshtein_recursive($P0[1:], $P1[1:])\nreturn 1 + min(insert, delete, replace)",
    "description": "levenshtein_recursive (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_levenshtein_dp_optimized_848": {
    "name": "stack_levenshtein_dp_optimized_848",
    "pattern_type": "general",
    "code_template": "(m, n) = (len($P0), len($P1))\nif m < n:\n    ($P0, $P1) = ($P1, $P0)\n    (m, n) = (n, m)\nprevious_row = list(range(n + 1))\ncurrent_row = [0] * (n + 1)\nfor i in range(1, m + 1):\n    current_row[0] = i\n    for j in range(1, n + 1):\n        if $P0[i - 1] == $P1[j - 1]:\n            current_row[j] = previous_row[j - 1]\n        else:\n            current_row[j] = 1 + min(previous_row[j], current_row[j - 1], previous_row[j - 1])\n    (previous_row, current_row) = (current_row, previous_row)\nreturn previous_row[n]",
    "description": "levenshtein_dp_optimized (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_clone_account_849": {
    "name": "stack_clone_account_849",
    "pattern_type": "general",
    "code_template": "return BankAccount(account_holder=$P0.account_holder, balance=$P0.balance)",
    "description": "clone_account (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_deposit_850": {
    "name": "stack_deposit_850",
    "pattern_type": "general",
    "code_template": "if $P1 < 0:\n    raise ValueError('Deposit $P1 must be positive')\nreturn BankAccount(account_holder=$P0.account_holder, balance=$P0.balance + $P1)",
    "description": "deposit (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_withdraw_851": {
    "name": "stack_withdraw_851",
    "pattern_type": "general",
    "code_template": "if $P1 < 0:\n    raise ValueError('Withdrawal $P1 must be positive')\nif $P0.balance < $P1:\n    raise ValueError('Insufficient funds')\nreturn BankAccount(account_holder=$P0.account_holder, balance=$P0.balance - $P1)",
    "description": "withdraw (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_main_852": {
    "name": "stack_main_852",
    "pattern_type": "general",
    "code_template": "original_account = BankAccount('John Doe', 1000.0)\nprint('Original Account:', original_account)\ncloned_account = clone_account(original_account)\nprint('Cloned Account:', cloned_account)\nupdated_account = deposit(original_account, 200.0)\nprint('Account after Deposit:', updated_account)\nupdated_account = withdraw(original_account, 100.0)\nprint('Account after Withdrawal:', updated_account)",
    "description": "main (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_max_consecutive_operations_853": {
    "name": "stack_max_consecutive_operations_853",
    "pattern_type": "general",
    "code_template": "n = len($P0)\ni = 0\nmax_operations = 0\ncurrent_running_cost_sum = 0\nmax_charge_time = 0\nfor j in range(n):\n    current_running_cost_sum += $P1[j]\n    max_charge_time = max(max_charge_time, $P0[j])\n    while max_charge_time + (j - i + 1) * current_running_cost_sum > $P2:\n        current_running_cost_sum -= $P1[i]\n        i += 1\n        if i <= j:\n            max_charge_time = max($P0[i:j + 1])\n        else:\n            max_charge_time = 0\n    max_operations = max(max_operations, j - i + 1)\nreturn max_operations",
    "description": "max_consecutive_operations (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_distributed_dijkstra_854": {
    "name": "stack_distributed_dijkstra_854",
    "pattern_type": "string",
    "code_template": "priority_queue = [(0, 0)]\nwhile priority_queue:\n    (current_distance, current_node) = sorted(priority_queue).pop(0)\n    if current_distance > $P1[current_node]:\n        continue\n    for (neighbor, weight) in $P0.get(current_node, []):\n        distance = current_distance + weight\n        if distance < $P1[neighbor]:\n            $P1[neighbor] = distance\n            priority_queue.append((distance, neighbor))\n            comm.send((neighbor, distance), dest=rank + 1 % size)\nreturn $P1",
    "description": "distributed_dijkstra (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_increment_855": {
    "name": "stack_increment_855",
    "pattern_type": "general",
    "code_template": "global counter\nfor _ in range(100000):\n    counter += 1",
    "description": "increment (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_increment_856": {
    "name": "stack_increment_856",
    "pattern_type": "general",
    "code_template": "global counter\nfor _ in range(100000):\n    with lock:\n        counter += 1",
    "description": "increment (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_main_857": {
    "name": "stack_main_857",
    "pattern_type": "general",
    "code_template": "manager = TaskManager()\nmanager.add_task('1', 'Complete project', 'Finish the Python project by the end of the month', '2023-10-31')\nmanager.update_task('1', description='Finish the project ASAP', due_date_str='2023-10-25')\nmanager.delete_task('1')",
    "description": "main (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_pad_858": {
    "name": "stack_pad_858",
    "pattern_type": "general",
    "code_template": "pad_len = AES.block_size - len($P0) % AES.block_size\nreturn $P0 + bytes([pad_len]) * pad_len",
    "description": "pad (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_unpad_859": {
    "name": "stack_unpad_859",
    "pattern_type": "general",
    "code_template": "pad_len = $P0[-1]\nreturn $P0[:-pad_len]",
    "description": "unpad (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_encrypt_data_860": {
    "name": "stack_encrypt_data_860",
    "pattern_type": "general",
    "code_template": "cipher = AES.new($P1, AES.MODE_CBC)\niv = cipher.iv\nencrypted_data = cipher.encrypt(pad($P0))\nreturn iv + encrypted_data",
    "description": "encrypt_data (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_decrypt_data_861": {
    "name": "stack_decrypt_data_861",
    "pattern_type": "general",
    "code_template": "iv = $P0[:AES.block_size]\n$P0 = $P0[AES.block_size:]\ncipher = AES.new($P1, AES.MODE_CBC, iv)\nreturn unpad(cipher.decrypt($P0))",
    "description": "decrypt_data (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_checksum_862": {
    "name": "stack_add_checksum_862",
    "pattern_type": "general",
    "code_template": "checksum = zlib.crc32($P0) & 4294967295\nreturn $P0 + checksum.to_bytes(4, 'big')",
    "description": "add_checksum (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_command_line_interface_863": {
    "name": "stack_command_line_interface_863",
    "pattern_type": "general",
    "code_template": "calc = Calculator()\nprint('Simple Command-line Calculator')\nprint('Enter operations in the format: add 4 5')\nwhile True:\n    user_input = input(\"Enter command (or 'exit' to quit): \")\n    if user_input.lower() == 'exit':\n        break\n    (operation, op1, op2) = user_input.split()\n    (op1, op2) = (int(op1), int(op2))\n    if operation == 'add':\n        print(f'Result: {calc.add(op1, op2)}')\n    elif operation == 'subtract':\n        print(f'Result: {calc.subtract(op1, op2)}')\n    elif operation == 'multiply':\n        print(f'Result: {calc.multiply(op1, op2)}')\n    elif operation == 'divide':\n        try:\n            print(f'Result: {calc.divide(op1, op2)}')\n        except ValueError as e:\n            print(e)\n    else:\n        print('Unknown operation')",
    "description": "command_line_interface (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_864": {
    "name": "stack_add_864",
    "pattern_type": "general",
    "code_template": "return $P1 + $P2",
    "description": "add (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_subtract_865": {
    "name": "stack_subtract_865",
    "pattern_type": "general",
    "code_template": "return $P1 - $P2",
    "description": "subtract (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_multiply_866": {
    "name": "stack_multiply_866",
    "pattern_type": "general",
    "code_template": "return $P1 * $P2",
    "description": "multiply (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_factorial_867": {
    "name": "stack_factorial_867",
    "pattern_type": "math",
    "code_template": "if $P0 == 0:\n    return 1\nelse:\n    return $P0 * factorial($P0 - 1)",
    "description": "factorial (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_encode_rle_868": {
    "name": "stack_encode_rle_868",
    "pattern_type": "general",
    "code_template": "encoded = []\ncurrent_run_length = 1\ncurrent_value = $P0[0]\nfor i in range(1, len($P0)):\n    if $P0[i] == current_value:\n        current_run_length += 1\n    else:\n        encoded.append(current_value << 7 | current_run_length)\n        current_value = $P0[i]\n        current_run_length = 1\nencoded.append(current_value << 7 | current_run_length)\nreturn encoded",
    "description": "encode_rle (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_decode_rle_869": {
    "name": "stack_decode_rle_869",
    "pattern_type": "general",
    "code_template": "decoded = []\nfor encoded_value in $P0:\n    value = (encoded_value & 128) >> 7\n    run_length = encoded_value & 127\n    decoded.extend([value] * run_length)\nreturn decoded",
    "description": "decode_rle (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_870": {
    "name": "stack_dfs_870",
    "pattern_type": "general",
    "code_template": "if $P2 is None:\n    $P2 = set()\n$P2.add($P1)\nprint(f'Visiting: {$P1}')\nfor next_node in $P0[$P1] - $P2:\n    dfs($P0, next_node, $P2)\nreturn $P2",
    "description": "dfs (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_bfs_871": {
    "name": "stack_bfs_871",
    "pattern_type": "general",
    "code_template": "visited = set()\nqueue = deque([$P1])\nwhile queue:\n    vertex = queue.popleft()\n    if vertex not in visited:\n        visited.add(vertex)\n        print(f'Visiting: {vertex}')\n        queue.extend($P0[vertex] - visited)\nreturn visited",
    "description": "bfs (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_adaptive_traverse_872": {
    "name": "stack_adaptive_traverse_872",
    "pattern_type": "general",
    "code_template": "num_edges = sum((len(neighbors) for neighbors in $P0.values()))\nnum_vertices = len($P0)\nif num_edges < num_vertices ** 2 / 4:\n    print('Using DFS for sparse $P0.')\n    return dfs($P0, $P1)\nelse:\n    print('Using BFS for dense $P0.')\n    return bfs($P0, $P1)",
    "description": "adaptive_traverse (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_extractIncDecPattern_873": {
    "name": "stack_extractIncDecPattern_873",
    "pattern_type": "general",
    "code_template": "n = len($P0)\nstart_indices = []\nfor i in range(n - 2):\n    if $P0[i] + 1 == $P0[i + 1] and $P0[i + 1] - 1 == $P0[i + 2]:\n        start_indices.append(i)\nreturn start_indices",
    "description": "extractIncDecPattern (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_person_874": {
    "name": "stack_add_person_874",
    "pattern_type": "general",
    "code_template": "if $P1 not in $P0.graph:\n    $P0.graph[$P1] = []",
    "description": "add_person (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_friendship_875": {
    "name": "stack_add_friendship_875",
    "pattern_type": "general",
    "code_template": "if $P1 in $P0.graph and $P2 in $P0.graph:\n    $P0.graph[$P1].append($P2)\n    $P0.graph[$P2].append($P1)",
    "description": "add_friendship (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_bfs_shortest_path_876": {
    "name": "stack_bfs_shortest_path_876",
    "pattern_type": "general",
    "code_template": "if $P1 not in $P0.graph or $P2 not in $P0.graph:\n    return None\nqueue = deque([[$P1]])\nvisited = set()\nwhile queue:\n    path = queue.popleft()\n    person = path[-1]\n    if person in visited:\n        continue\n    if person == $P2:\n        return path\n    visited.add(person)\n    for neighbor in $P0.graph[person]:\n        new_path = list(path)\n        new_path.append(neighbor)\n        queue.append(new_path)\nreturn None",
    "description": "bfs_shortest_path (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_solve_nqueens_877": {
    "name": "stack_solve_nqueens_877",
    "pattern_type": "general",
    "code_template": "def is_safe(queen, board):\n    (row, col) = (len(board), queen)\n    for i in range(row):\n        if board[i] == col or board[i] - i == col - row or board[i] + i == col + row:\n            return False\n    return True\ndef solve(board=[]):\n    if len(board) == $P0:\n        results.append(board)\n        return\n    for col in range($P0):\n        if is_safe(col, board):\n            solve(board + [col])\nresults = []\nsolve()\nreturn results",
    "description": "solve_nqueens (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_safe_878": {
    "name": "stack_is_safe_878",
    "pattern_type": "general",
    "code_template": "(row, col) = (len($P1), $P0)\nfor i in range(row):\n    if $P1[i] == col or $P1[i] - i == col - row or $P1[i] + i == col + row:\n        return False\nreturn True",
    "description": "is_safe (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_solve_879": {
    "name": "stack_solve_879",
    "pattern_type": "general",
    "code_template": "if len($P0) == n:\n    results.append($P0)\n    return\nfor col in range(n):\n    if is_safe(col, $P0):\n        solve($P0 + [col])",
    "description": "solve (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_compress_file_permissions_880": {
    "name": "stack_compress_file_permissions_880",
    "pattern_type": "general",
    "code_template": "permission_bits = {'r': 4, 'w': 2, 'x': 1, '-': 0}\ndef permission_string_to_int(permission: str) -> int:\n    result = 0\n    for (i, char) in enumerate(permission):\n        bit_position = (8 - i) * 3\n        bit_value = permission_bits[char]\n        result |= bit_value << bit_position\n    return result\ncombined_permissions = 0\nfor perm in $P0:\n    combined_permissions |= permission_string_to_int(perm)\nreturn combined_permissions",
    "description": "compress_file_permissions (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_permission_string_to_int_881": {
    "name": "stack_permission_string_to_int_881",
    "pattern_type": "string",
    "code_template": "result = 0\nfor (i, char) in enumerate($P0):\n    bit_position = (8 - i) * 3\n    bit_value = permission_bits[char]\n    result |= bit_value << bit_position\nreturn result",
    "description": "permission_string_to_int (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_convert_graph_882": {
    "name": "stack_convert_graph_882",
    "pattern_type": "general",
    "code_template": "nodes = sorted(set(sum($P0, ())))\nadj_list = {node: [] for node in nodes}\nfor (src, dest) in $P0:\n    adj_list[src].append(dest)\nsize = len(nodes)\nadj_matrix = [[0] * size for _ in range(size)]\nnode_index = {node: i for (i, node) in enumerate(nodes)}\nfor (src, dest) in $P0:\n    (i, j) = (node_index[src], node_index[dest])\n    adj_matrix[i][j] = 1\nreturn (adj_list, adj_matrix)",
    "description": "convert_graph (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_883": {
    "name": "stack_dfs_883",
    "pattern_type": "general",
    "code_template": "if $P0 is None:\n    return False\nif $P0.value == $P1:\n    return True\nreturn dfs($P0.left, $P1) or dfs($P0.right, $P1)",
    "description": "dfs (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_bfs_884": {
    "name": "stack_bfs_884",
    "pattern_type": "general",
    "code_template": "if $P0 is None:\n    return False\nqueue = deque([$P0])\nwhile queue:\n    current = queue.popleft()\n    if current.value == $P1:\n        return True\n    if current.left:\n        queue.append(current.left)\n    if current.right:\n        queue.append(current.right)\nreturn False",
    "description": "bfs (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_cycle_util_885": {
    "name": "stack_is_cycle_util_885",
    "pattern_type": "general",
    "code_template": "$P2[$P1] = True\n$P3[$P1] = True\nfor neighbor in $P0.graph[$P1]:\n    if not $P2[neighbor]:\n        if $P0.is_cycle_util(neighbor, $P2, $P3):\n            return True\n    elif $P3[neighbor]:\n        return True\n$P3[$P1] = False\nreturn False",
    "description": "is_cycle_util (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_cycle_886": {
    "name": "stack_is_cycle_886",
    "pattern_type": "general",
    "code_template": "visited = [False] * $P0.V\nrec_stack = [False] * $P0.V\nfor node in range($P0.V):\n    if not visited[node]:\n        if $P0.is_cycle_util(node, visited, rec_stack):\n            return True\nreturn False",
    "description": "is_cycle (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_largest_square_with_bars_887": {
    "name": "stack_largest_square_with_bars_887",
    "pattern_type": "general",
    "code_template": "N = len($P0)\nif N == 0:\n    return (0, (0, 0))\ndp = [[0] * N for _ in range(N)]\nmax_size = 0\ntop_left_corner = (0, 0)\nfor i in range(N):\n    for j in range(N):\n        if $P0[i][j]:\n            if i == 0 or j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n            if dp[i][j] > max_size:\n                max_size = dp[i][j]\n                top_left_corner = (i - max_size + 1, j - max_size + 1)\nreturn (max_size, top_left_corner)",
    "description": "largest_square_with_bars (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_edge_888": {
    "name": "stack_add_edge_888",
    "pattern_type": "general",
    "code_template": "if $P1 not in $P0.nodes:\n    $P0.nodes[$P1] = []\nif $P2 not in $P0.nodes:\n    $P0.nodes[$P2] = []\n$P0.nodes[$P1].append(($P2, $P3))",
    "description": "add_edge (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_calculate_difference_889": {
    "name": "stack_calculate_difference_889",
    "pattern_type": "general",
    "code_template": "digit_product = 1\ndigit_sum = 0\nfor digit in str($P0):\n    d = int(digit)\n    digit_product = digit_product * d % $P1\n    digit_sum = (digit_sum + d) % $P1\nresult = (digit_product - digit_sum) % $P1\nif result < 0:\n    result += $P1\nreturn result",
    "description": "calculate_difference (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_recommend_songs_890": {
    "name": "stack_recommend_songs_890",
    "pattern_type": "general",
    "code_template": "recommendations = []\nfor song in $P1:\n    if song.matches_user_preferences($P0.preferences):\n        recommendations.append(song)\nreturn recommendations",
    "description": "recommend_songs (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_create_collaborative_playlist_891": {
    "name": "stack_create_collaborative_playlist_891",
    "pattern_type": "list",
    "code_template": "playlist = Playlist(playlist_id='001', title='Shared Vibes', songs=[])\nplaylist.add_collaborator($P0)\nplaylist.add_collaborator($P1)\n$P0.playlists.append(playlist)\n$P1.playlists.append(playlist)",
    "description": "create_collaborative_playlist (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_song_892": {
    "name": "stack_add_song_892",
    "pattern_type": "general",
    "code_template": "$P0.songs.append($P1)",
    "description": "add_song (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_calculate_rewards_893": {
    "name": "stack_calculate_rewards_893",
    "pattern_type": "general",
    "code_template": "min_time = min($P0)\nrewards = [min_time - time for time in $P0]\nsorted_rewards = sorted(rewards, reverse=True)\nreturn sorted_rewards",
    "description": "calculate_rewards (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_valid_configuration_894": {
    "name": "stack_is_valid_configuration_894",
    "pattern_type": "general",
    "code_template": "return all(($P0[i] != $P0[i + 1] for i in range(len($P0) - 1)))",
    "description": "is_valid_configuration (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_brute_force_count_895": {
    "name": "stack_brute_force_count_895",
    "pattern_type": "general",
    "code_template": "start_time = time.time()\nn = len($P0)\nchars = set($P0)\nvalid_count = 0\nfor config in product(chars, repeat=n):\n    if is_valid_configuration(config):\n        valid_count += 1\nend_time = time.time()\nreturn (valid_count, end_time - start_time)",
    "description": "brute_force_count (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_compare_methods_896": {
    "name": "stack_compare_methods_896",
    "pattern_type": "general",
    "code_template": "brute_force_result = brute_force_count($P0)\noptimized_result = optimized_count($P0)\nreturn {'brute_force': {'count': brute_force_result[0], 'time': brute_force_result[1]}, 'optimized': {'count': optimized_result[0], 'time': optimized_result[1]}}",
    "description": "compare_methods (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_search_rotated_array_897": {
    "name": "stack_search_rotated_array_897",
    "pattern_type": "algorithm",
    "code_template": "(left, right) = (0, $P0.length - 1)\nwhile left <= right:\n    mid = (left + right) // 2\n    if $P0[mid] == $P1:\n        return mid\n    if $P0[left] <= $P0[mid]:\n        if $P0[left] <= $P1 < $P0[mid]:\n            right = mid - 1\n        else:\n            left = mid + 1\n    elif $P0[mid] < $P1 <= $P0[right]:\n        left = mid + 1\n    else:\n        right = mid - 1\nreturn -1",
    "description": "search_rotated_array (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_winner_898": {
    "name": "stack_is_winner_898",
    "pattern_type": "general",
    "code_template": "for i in range(3):\n    if all([$P0[i][j] == $P1 for j in range(3)]) or all([$P0[j][i] == $P1 for j in range(3)]):\n        return True\nif $P0[0][0] == $P0[1][1] == $P0[2][2] == $P1 or $P0[0][2] == $P0[1][1] == $P0[2][0] == $P1:\n    return True\nreturn False",
    "description": "is_winner (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_available_actions_899": {
    "name": "stack_available_actions_899",
    "pattern_type": "general",
    "code_template": "return [(i, j) for i in range(3) for j in range(3) if $P0[i][j] == ' ']",
    "description": "available_actions (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_apply_action_900": {
    "name": "stack_apply_action_900",
    "pattern_type": "general",
    "code_template": "new_state = [row[:] for row in $P0]\nnew_state[$P1[0]][$P1[1]] = $P2\nreturn new_state",
    "description": "apply_action (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_quicksort_901": {
    "name": "stack_quicksort_901",
    "pattern_type": "algorithm",
    "code_template": "if $P1 < $P2:\n    pi = partition($P0, $P1, $P2)\n    quicksort($P0, $P1, pi - 1)\n    quicksort($P0, pi + 1, $P2)",
    "description": "quicksort (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_findFirstAndLastPosition_902": {
    "name": "stack_findFirstAndLastPosition_902",
    "pattern_type": "algorithm",
    "code_template": "def findFirst($P0, $P1):\n    (left, right) = (0, len($P0) - 1)\n    first_pos = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if $P0[mid] == $P1:\n            first_pos = mid\n            right = mid - 1\n        elif $P0[mid] < $P1:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return first_pos\ndef findLast($P0, $P1):\n    (left, right) = (0, len($P0) - 1)\n    last_pos = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if $P0[mid] == $P1:\n            last_pos = mid\n            left = mid + 1\n        elif $P0[mid] < $P1:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return last_pos\nfirst_position = findFirst($P0, $P1)\nlast_position = findLast($P0, $P1)\nreturn [first_position, last_position]",
    "description": "findFirstAndLastPosition (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_findFirst_903": {
    "name": "stack_findFirst_903",
    "pattern_type": "algorithm",
    "code_template": "(left, right) = (0, len($P0) - 1)\nfirst_pos = -1\nwhile left <= right:\n    mid = (left + right) // 2\n    if $P0[mid] == $P1:\n        first_pos = mid\n        right = mid - 1\n    elif $P0[mid] < $P1:\n        left = mid + 1\n    else:\n        right = mid - 1\nreturn first_pos",
    "description": "findFirst (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_findLast_904": {
    "name": "stack_findLast_904",
    "pattern_type": "algorithm",
    "code_template": "(left, right) = (0, len($P0) - 1)\nlast_pos = -1\nwhile left <= right:\n    mid = (left + right) // 2\n    if $P0[mid] == $P1:\n        last_pos = mid\n        left = mid + 1\n    elif $P0[mid] < $P1:\n        left = mid + 1\n    else:\n        right = mid - 1\nreturn last_pos",
    "description": "findLast (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_record_sale_905": {
    "name": "stack_record_sale_905",
    "pattern_type": "general",
    "code_template": "if $P1 in $P0.sales_data:\n    $P0.sales_data[$P1] += $P2\nelse:\n    $P0.sales_data[$P1] = $P2",
    "description": "record_sale (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_set_initial_price_906": {
    "name": "stack_set_initial_price_906",
    "pattern_type": "general",
    "code_template": "$P0.prices[$P1] = $P2",
    "description": "set_initial_price (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_adjust_price_907": {
    "name": "stack_adjust_price_907",
    "pattern_type": "general",
    "code_template": "if $P1 not in $P0.sales_data:\n    return\ndemand = $P0.sales_data[$P1]\nif demand > $P2:\n    $P0.prices[$P1] *= 1.1\nelif demand < $P2:\n    $P0.prices[$P1] *= 0.9",
    "description": "adjust_price (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_price_908": {
    "name": "stack_get_price_908",
    "pattern_type": "general",
    "code_template": "return $P0.prices.get($P1, 'Price not set')",
    "description": "get_price (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_next_909": {
    "name": "stack_next_909",
    "pattern_type": "general",
    "code_template": "topmost_node = $P0.stack.pop()\nif topmost_node.right:\n    $P0._leftmost_inorder(topmost_node.right)\nreturn topmost_node.val",
    "description": "next (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_hasNext_910": {
    "name": "stack_hasNext_910",
    "pattern_type": "general",
    "code_template": "return len($P0.stack) > 0",
    "description": "hasNext (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_palindrome_911": {
    "name": "stack_is_palindrome_911",
    "pattern_type": "general",
    "code_template": "return str($P0) == str($P0)[::-1]",
    "description": "is_palindrome (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_sum_even_odd_digits_912": {
    "name": "stack_sum_even_odd_digits_912",
    "pattern_type": "general",
    "code_template": "even_sum = 0\nodd_sum = 0\nfor digit in str($P0):\n    digit = int(digit)\n    if digit % 2 == 0:\n        even_sum += digit\n    else:\n        odd_sum += digit\nreturn (even_sum, odd_sum)",
    "description": "sum_even_odd_digits (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_beautiful_numbers_913": {
    "name": "stack_find_beautiful_numbers_913",
    "pattern_type": "algorithm",
    "code_template": "beautiful_numbers = []\nfor num in range($P0, $P1 + 1):\n    if is_palindrome(num):\n        (even_sum, odd_sum) = sum_even_odd_digits(num)\n        if even_sum == odd_sum:\n            beautiful_numbers.append(num)\nreturn beautiful_numbers",
    "description": "find_beautiful_numbers (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_greedy_graph_coloring_914": {
    "name": "stack_greedy_graph_coloring_914",
    "pattern_type": "general",
    "code_template": "num_courses = len($P0)\nresult = [-1] * num_courses\nresult[0] = 0\navailable = [False] * num_courses\nfor course in range(1, num_courses):\n    for adjacent in range(num_courses):\n        if $P0[course][adjacent] == 1 and result[adjacent] != -1:\n            available[result[adjacent]] = True\n    color = 0\n    while color < num_courses and available[color]:\n        color += 1\n    result[course] = color\n    available = [False] * num_courses\nreturn result",
    "description": "greedy_graph_coloring (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_linear_search_915": {
    "name": "stack_linear_search_915",
    "pattern_type": "algorithm",
    "code_template": "for (i, value) in enumerate($P0):\n    if value == $P1:\n        return i\nreturn -1",
    "description": "linear_search (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_test_search_methods_916": {
    "name": "stack_test_search_methods_916",
    "pattern_type": "algorithm",
    "code_template": "start = time.time()\nindex_bin_search = binary_search_rotated($P0, $P1)\nend = time.time()\nbinary_search_time = end - start\nstart = time.time()\nindex_lin_search = linear_search($P0, $P1)\nend = time.time()\nlinear_search_time = end - start\nprint(f'Binary Search: Found $P1 at index {index_bin_search}, Time: {binary_search_time:.6f}s')\nprint(f'Linear Search: Found $P1 at index {index_lin_search}, Time: {linear_search_time:.6f}s')",
    "description": "test_search_methods (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_tree_sum_paths_917": {
    "name": "stack_tree_sum_paths_917",
    "pattern_type": "general",
    "code_template": "def dfs(node, current_sum, path_sums):\n    if not node:\n        return\n    current_sum += node.value\n    if not node.left and (not node.right):\n        path_sums.append(current_sum)\n        return\n    if node.left:\n        dfs(node.left, current_sum, path_sums)\n    if node.right:\n        dfs(node.right, current_sum, path_sums)\npath_sums = []\ndfs($P0, 0, path_sums)\nreturn path_sums",
    "description": "tree_sum_paths (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_918": {
    "name": "stack_dfs_918",
    "pattern_type": "general",
    "code_template": "if not $P0:\n    return\n$P1 += $P0.value\nif not $P0.left and (not $P0.right):\n    $P2.append($P1)\n    return\nif $P0.left:\n    dfs($P0.left, $P1, $P2)\nif $P0.right:\n    dfs($P0.right, $P1, $P2)",
    "description": "dfs (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_binary_search_919": {
    "name": "stack_binary_search_919",
    "pattern_type": "algorithm",
    "code_template": "def recursive_search(left, right):\n    if left > right:\n        return -1\n    mid = left + (right - left) // 2\n    if $P0[mid] == $P1:\n        return mid\n    elif $P0[mid] > $P1:\n        return recursive_search(left, mid - 1)\n    else:\n        return recursive_search(mid + 1, right)\nreturn recursive_search(0, len($P0) - 1)",
    "description": "binary_search (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_recursive_search_920": {
    "name": "stack_recursive_search_920",
    "pattern_type": "algorithm",
    "code_template": "if $P0 > $P1:\n    return -1\nmid = $P0 + ($P1 - $P0) // 2\nif arr[mid] == target:\n    return mid\nelif arr[mid] > target:\n    return recursive_search($P0, mid - 1)\nelse:\n    return recursive_search(mid + 1, $P1)",
    "description": "recursive_search (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_custom_edge_detection_921": {
    "name": "stack_custom_edge_detection_921",
    "pattern_type": "general",
    "code_template": "horizontal_edges = cv2.filter2D($P0, -1, horizontal_kernel)\nvertical_edges = cv2.filter2D($P0, -1, vertical_kernel)\ncombined_edges = cv2.addWeighted(horizontal_edges, 0.5, vertical_edges, 0.5, 0)\nreturn combined_edges",
    "description": "custom_edge_detection (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_calculate_pixel_accuracy_922": {
    "name": "stack_calculate_pixel_accuracy_922",
    "pattern_type": "general",
    "code_template": "difference = np.abs($P0 - $P1)\naccuracy = 1 - np.mean(difference / 255)\nreturn accuracy",
    "description": "calculate_pixel_accuracy (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_subarray_sum_923": {
    "name": "stack_subarray_sum_923",
    "pattern_type": "list",
    "code_template": "prefix_sum_count = {0: 1}\ncurrent_sum = 0\ncount = 0\nfor num in $P0:\n    current_sum += num\n    needed_sum = current_sum - $P1\n    if needed_sum in prefix_sum_count:\n        count += prefix_sum_count[needed_sum]\n    if current_sum in prefix_sum_count:\n        prefix_sum_count[current_sum] += 1\n    else:\n        prefix_sum_count[current_sum] = 1\nreturn count",
    "description": "subarray_sum (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_schedule_tasks_924": {
    "name": "stack_schedule_tasks_924",
    "pattern_type": "general",
    "code_template": "graph = defaultdict(list)\nindegree = defaultdict(int)\nfor task in $P0:\n    for dep in task.dependencies:\n        graph[dep].append(task.id)\n        indegree[task.id] += 1\npriority_queue = []\nfor task in $P0:\n    if indegree[task.id] == 0:\n        heapq.heappush(priority_queue, (-task.priority, task.deadline, task.id))\nexecution_order = []\nwhile priority_queue:\n    (_, _, task_id) = heapq.heappop(priority_queue)\n    execution_order.append(task_id)\n    for neighbor in graph[task_id]:\n        indegree[neighbor] -= 1\n        if indegree[neighbor] == 0:\n            task = next((t for t in $P0 if t.id == neighbor))\n            heapq.heappush(priority_queue, (-task.priority, task.deadline, task.id))\nreturn execution_order",
    "description": "schedule_tasks (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_handle_client_925": {
    "name": "stack_handle_client_925",
    "pattern_type": "general",
    "code_template": "broadcast(f'\u7528\u6237 {$P1} \u4e0a\u7ebf', $P0)\nclients.append($P0)\ntry:\n    while True:\n        message = $P0.recv(1024).decode('utf-8')\n        if len(message) > MAX_MESSAGE_LENGTH:\n            $P0.send('\u6d88\u606f\u8fc7\u957f\uff08\u8d85\u8fc7200\u5b57\u7b26\uff09'.encode('utf-8'))\n        else:\n            broadcast(f'{$P1}: {message}', $P0)\nexcept ConnectionResetError:\n    clients.remove($P0)\n    broadcast(f'\u7528\u6237 {$P1} \u4e0b\u7ebf', $P0)\n    $P0.close()",
    "description": "handle_client (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_broadcast_926": {
    "name": "stack_broadcast_926",
    "pattern_type": "general",
    "code_template": "for client in clients:\n    if client != $P1:\n        try:\n            client.send($P0.encode('utf-8'))\n        except:\n            client.close()\n            clients.remove(client)",
    "description": "broadcast (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_start_server_927": {
    "name": "stack_start_server_927",
    "pattern_type": "general",
    "code_template": "server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver.bind((SERVER_IP, SERVER_PORT))\nserver.listen(5)\nprint('\u670d\u52a1\u5668\u542f\u52a8\u4e2d...')\nwhile True:\n    (client_socket, client_address) = server.accept()\n    client_thread = threading.Thread(target=handle_client, args=(client_socket, client_address))\n    client_thread.start()",
    "description": "start_server (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_update_traffic_928": {
    "name": "stack_update_traffic_928",
    "pattern_type": "general",
    "code_template": "if $P1 in $P0.nodes and $P2 in $P0.nodes[$P1]:\n    $P0.nodes[$P1][$P2] = $P3",
    "description": "update_traffic (4 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_client_handler_929": {
    "name": "stack_client_handler_929",
    "pattern_type": "general",
    "code_template": "try:\n    while True:\n        message_type = $P0.recv(4).decode('utf-8')\n        if not message_type:\n            break\n        if message_type == 'TEXT':\n            text_length = int($P0.recv(4).decode('utf-8'))\n            text_message = $P0.recv(text_length).decode('utf-8')\n            print(f'Received text: {text_message}')\n            $P0.send('Text received'.encode('utf-8'))\n        elif message_type == 'FILE':\n            file_name_length = int($P0.recv(4).decode('utf-8'))\n            file_name = $P0.recv(file_name_length).decode('utf-8')\n            file_size = int($P0.recv(8).decode('utf-8'))\n            with open(file_name, 'wb') as f:\n                data_received = 0\n                while data_received < file_size:\n                    data = $P0.recv(4096)\n                    f.write(data)\n                    data_received += len(data)\n            print(f'Received file: {file_name}')\n            $P0.send('File received'.encode('utf-8'))\nexcept Exception as e:\n    print(f'Error: {e}')\nfinally:\n    $P0.close()",
    "description": "client_handler (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_start_server_930": {
    "name": "stack_start_server_930",
    "pattern_type": "general",
    "code_template": "server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_socket.bind(($P0, $P1))\nserver_socket.listen(5)\nprint(f'Server listening on {$P0}:{$P1}')\ntry:\n    while True:\n        (client_socket, addr) = server_socket.accept()\n        print(f'Connection established with {addr}')\n        threading.Thread(target=client_handler, args=(client_socket,)).start()\nexcept KeyboardInterrupt:\n    print('Shutting down the server.')\nfinally:\n    server_socket.close()",
    "description": "start_server (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_send_text_931": {
    "name": "stack_send_text_931",
    "pattern_type": "string",
    "code_template": "message_type = 'TEXT'\n$P0.send(message_type.encode('utf-8'))\n$P0.send(f'{len($P1):04d}'.encode('utf-8'))\n$P0.send($P1.encode('utf-8'))\nresponse = $P0.recv(1024).decode('utf-8')\nprint(f'Server Response: {response}')",
    "description": "send_text (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_send_file_932": {
    "name": "stack_send_file_932",
    "pattern_type": "general",
    "code_template": "message_type = 'FILE'\nfile_name = os.path.basename($P1)\nfile_size = os.path.getsize($P1)\n$P0.send(message_type.encode('utf-8'))\n$P0.send(f'{len(file_name):04d}'.encode('utf-8'))\n$P0.send(file_name.encode('utf-8'))\n$P0.send(f'{file_size:08d}'.encode('utf-8'))\nwith open($P1, 'rb') as f:\n    while (file_data := f.read(4096)):\n        $P0.sendall(file_data)\nresponse = $P0.recv(1024).decode('utf-8')\nprint(f'Server Response: {response}')",
    "description": "send_file (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_connect_to_server_933": {
    "name": "stack_connect_to_server_933",
    "pattern_type": "general",
    "code_template": "client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ntry:\n    client_socket.connect(($P0, $P1))\n    print('Connected to the server.')\n    send_text(client_socket, 'Hello, Server!')\n    send_file(client_socket, 'example.txt')\nexcept Exception as e:\n    print(f'Connection error: {e}')\nfinally:\n    client_socket.close()",
    "description": "connect_to_server (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_count_substrings_with_two_vowels_934": {
    "name": "stack_count_substrings_with_two_vowels_934",
    "pattern_type": "string",
    "code_template": "vowels = set('aeiou')\nstart = 0\nvowel_count = 0\nresult = 0\nfor end in range(len($P0)):\n    if $P0[end] in vowels:\n        vowel_count += 1\n    while vowel_count >= 2:\n        result += len($P0) - end\n        if $P0[start] in vowels:\n            vowel_count -= 1\n        start += 1\nreturn result",
    "description": "count_substrings_with_two_vowels (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_set_username_935": {
    "name": "stack_set_username_935",
    "pattern_type": "general",
    "code_template": "if $P0._validate_input($P1, 'username') and $P1 not in $P0.existing_usernames:\n    UserProfile.existing_usernames.remove($P0.username)\n    $P0.username = $P1\n    UserProfile.existing_usernames.add($P1)\nelse:\n    raise ValueError('Invalid or duplicate username')",
    "description": "set_username (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_update_bio_936": {
    "name": "stack_update_bio_936",
    "pattern_type": "general",
    "code_template": "if $P0._validate_input($P1, 'bio'):\n    $P0.bio = $P1",
    "description": "update_bio (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_update_profile_picture_937": {
    "name": "stack_update_profile_picture_937",
    "pattern_type": "general",
    "code_template": "if $P0._validate_input($P1, 'profile picture'):\n    $P0.profile_picture = $P1",
    "description": "update_profile_picture (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_shortest_path_938": {
    "name": "stack_find_shortest_path_938",
    "pattern_type": "algorithm",
    "code_template": "graph = {}\nfor (_, row) in $P0.iterrows():\n    from_city = row['from_city']\n    to_city = row['to_city']\n    travel_time = row['travel_time']\n    if from_city not in graph:\n        graph[from_city] = []\n    graph[from_city].append((to_city, travel_time))\n    if to_city not in graph:\n        graph[to_city] = []\n    graph[to_city].append((from_city, travel_time))\ndef dijkstra(start, end):\n    queue = [(0, start, [])]\n    seen = set()\n    min_distance = {start: 0}\n    while queue:\n        (current_cost, current_node, path) = heapq.heappop(queue)\n        if current_node in seen:\n            continue\n        seen.add(current_node)\n        path = path + [current_node]\n        if current_node == end:\n            return (path, current_cost)\n        for (neighbor, travel_time) in graph.get(current_node, []):\n            if neighbor in seen:\n                continue\n            new_cost = current_cost + travel_time\n            old_cost = min_distance.get(neighbor, float('inf'))\n            if new_cost < old_cost:\n                min_distance[neighbor] = new_cost\n                heapq.heappush(queue, (new_cost, neighbor, path))\n    return (None, float('inf'))\nreturn dijkstra($P1, $P2)",
    "description": "find_shortest_path (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dijkstra_939": {
    "name": "stack_dijkstra_939",
    "pattern_type": "string",
    "code_template": "queue = [(0, $P0, [])]\nseen = set()\nmin_distance = {$P0: 0}\nwhile queue:\n    (current_cost, current_node, path) = heapq.heappop(queue)\n    if current_node in seen:\n        continue\n    seen.add(current_node)\n    path = path + [current_node]\n    if current_node == $P1:\n        return (path, current_cost)\n    for (neighbor, travel_time) in graph.get(current_node, []):\n        if neighbor in seen:\n            continue\n        new_cost = current_cost + travel_time\n        old_cost = min_distance.get(neighbor, float('inf'))\n        if new_cost < old_cost:\n            min_distance[neighbor] = new_cost\n            heapq.heappush(queue, (new_cost, neighbor, path))\nreturn (None, float('inf'))",
    "description": "dijkstra (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_fibonacci_recursive_940": {
    "name": "stack_fibonacci_recursive_940",
    "pattern_type": "math",
    "code_template": "if $P0 <= 1:\n    return $P0\nelse:\n    return fibonacci_recursive($P0 - 1) + fibonacci_recursive($P0 - 2)",
    "description": "fibonacci_recursive (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_generate_fibonacci_sequence_941": {
    "name": "stack_generate_fibonacci_sequence_941",
    "pattern_type": "math",
    "code_template": "sequence = []\nfor i in range($P0):\n    sequence.append(fibonacci_recursive(i))\nreturn sequence",
    "description": "generate_fibonacci_sequence (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_visualize_fibonacci_942": {
    "name": "stack_visualize_fibonacci_942",
    "pattern_type": "math",
    "code_template": "plt.bar(range(len($P0)), $P0, color='skyblue')\nplt.title('Fibonacci Sequence')\nplt.xlabel('Index')\nplt.ylabel('Value')\nplt.show()",
    "description": "visualize_fibonacci (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_countConditionElements_943": {
    "name": "stack_countConditionElements_943",
    "pattern_type": "general",
    "code_template": "count = 0\nfor element in $P0:\n    if $P1 <= element <= $P2:\n        count += 1\nreturn count",
    "description": "countConditionElements (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_max_palindrome_sum_944": {
    "name": "stack_max_palindrome_sum_944",
    "pattern_type": "general",
    "code_template": "if not $P0 or not $P0[0]:\n    return 0\n(n, m) = (len($P0), len($P0[0]))\ndp = [[[-1] * m for _ in range(n)] for _ in range(n)]\ndef dfs(i, j, k, l):\n    if i > k or j > l:\n        return 0\n    if dp[i][j][k] != -1:\n        return dp[i][j][k]\n    if $P0[i][j] != $P0[k][l]:\n        dp[i][j][k] = 0\n        return 0\n    if i == k and j == l:\n        dp[i][j][k] = $P0[i][j]\n        return $P0[i][j]\n    if i == k and j + 1 == l:\n        dp[i][j][k] = $P0[i][j] + $P0[k][l]\n        return dp[i][j][k]\n    if i + 1 == k and j == l:\n        dp[i][j][k] = $P0[i][j] + $P0[k][l]\n        return dp[i][j][k]\n    max_sum = 0\n    if i + 1 < n and k - 1 >= 0:\n        max_sum = max(max_sum, dfs(i + 1, j, k - 1, l))\n    if j + 1 < m and l - 1 >= 0:\n        max_sum = max(max_sum, dfs(i, j + 1, k, l - 1))\n    if i + 1 < n and l - 1 >= 0:\n        max_sum = max(max_sum, dfs(i + 1, j, k, l - 1))\n    if j + 1 < m and k - 1 >= 0:\n        max_sum = max(max_sum, dfs(i, j + 1, k - 1, l))\n    dp[i][j][k] = $P0[i][j] + $P0[k][l] + max_sum\n    return dp[i][j][k]\nmax_palindrome = 0\nfor i in range(n):\n    for j in range(m):\n        for k in range(n):\n            for l in range(m):\n                max_palindrome = max(max_palindrome, dfs(i, j, k, l))\nreturn max_palindrome",
    "description": "max_palindrome_sum (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_rsaGenerateKeys_945": {
    "name": "stack_rsaGenerateKeys_945",
    "pattern_type": "general",
    "code_template": "p = sympy.randprime(100, 300)\nq = sympy.randprime(100, 300)\nn = p * q\nphi_n = (p - 1) * (q - 1)\ne = random.choice([i for i in range(2, phi_n) if sympy.gcd(i, phi_n) == 1])\nd = sympy.mod_inverse(e, phi_n)\nreturn ((e, n), (d, n))",
    "description": "rsaGenerateKeys (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_encrypt_946": {
    "name": "stack_encrypt_946",
    "pattern_type": "general",
    "code_template": "(e, n) = $P0\ncipher = [ord(char) ** e % n for char in $P1]\nreturn cipher",
    "description": "encrypt (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_decrypt_947": {
    "name": "stack_decrypt_947",
    "pattern_type": "general",
    "code_template": "(d, n) = $P0\nplain = [chr(char ** d % n) for char in $P1]\nreturn ''.join(plain)",
    "description": "decrypt (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_swish_948": {
    "name": "stack_swish_948",
    "pattern_type": "general",
    "code_template": "return $P0 * (1 / (1 + np.exp(-$P0)))",
    "description": "swish (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_call_949": {
    "name": "stack_call_949",
    "pattern_type": "general",
    "code_template": "return swish($P1)",
    "description": "call (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_findDeepestNodes_950": {
    "name": "stack_findDeepestNodes_950",
    "pattern_type": "algorithm",
    "code_template": "if not $P0:\n    return []\nmax_depth = 0\ndepth_nodes = {}\ndef dfs(node, depth):\n    nonlocal max_depth\n    if not node:\n        return\n    if depth in depth_nodes:\n        depth_nodes[depth].append(node.value)\n    else:\n        depth_nodes[depth] = [node.value]\n    if depth > max_depth:\n        max_depth = depth\n    dfs(node.left, depth + 1)\n    dfs(node.right, depth + 1)\ndfs($P0, 0)\nreturn depth_nodes[max_depth]",
    "description": "findDeepestNodes (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_951": {
    "name": "stack_dfs_951",
    "pattern_type": "general",
    "code_template": "nonlocal max_depth\nif not $P0:\n    return\nif $P1 in depth_nodes:\n    depth_nodes[$P1].append($P0.value)\nelse:\n    depth_nodes[$P1] = [$P0.value]\nif $P1 > max_depth:\n    max_depth = $P1\ndfs($P0.left, $P1 + 1)\ndfs($P0.right, $P1 + 1)",
    "description": "dfs (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_count_valid_subarrays_952": {
    "name": "stack_count_valid_subarrays_952",
    "pattern_type": "list",
    "code_template": "count = 0\nvalid_length = 0\nfor level in $P0:\n    if level >= 50:\n        valid_length += 1\n        count += valid_length\n    else:\n        valid_length = 0\nreturn count",
    "description": "count_valid_subarrays (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_search_with_prefix_953": {
    "name": "stack_search_with_prefix_953",
    "pattern_type": "algorithm",
    "code_template": "node = $P0.root\nresult = []\nfor char in $P1:\n    if char in node.children:\n        node = node.children[char]\n    else:\n        return []\n$P0._dfs_with_prefix(node, $P1, result)\nreturn result",
    "description": "search_with_prefix (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_reverse_954": {
    "name": "stack_reverse_954",
    "pattern_type": "general",
    "code_template": "prev = None\ncurrent = $P0.head\nwhile current:\n    next_node = current.next\n    current.next = prev\n    prev = current\n    current = next_node\n$P0.head = prev",
    "description": "reverse (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_display_955": {
    "name": "stack_display_955",
    "pattern_type": "general",
    "code_template": "current = $P0.head\nwhile current:\n    print(current.data, end=' -> ')\n    current = current.next\nprint('None')",
    "description": "display (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_critical_roads_956": {
    "name": "stack_find_critical_roads_956",
    "pattern_type": "algorithm",
    "code_template": "def dfs(at, parent, ids, low, visited, graph, bridges, id):\n    visited[at] = True\n    ids[at] = low[at] = id[0]\n    id[0] += 1\n    for to in graph[at]:\n        if to == parent:\n            continue\n        if not visited[to]:\n            dfs(to, at, ids, low, visited, graph, bridges, id)\n            low[at] = min(low[at], low[to])\n            if ids[at] < low[to]:\n                bridges.append((at, to))\n        else:\n            low[at] = min(low[at], ids[to])\nn = len($P0)\nids = [-1] * n\nlow = [-1] * n\nvisited = [False] * n\nbridges = []\nid = [0]\nfor i in range(n):\n    if not visited[i]:\n        dfs(i, -1, ids, low, visited, $P0, bridges, id)\nreturn bridges",
    "description": "find_critical_roads (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_957": {
    "name": "stack_dfs_957",
    "pattern_type": "general",
    "code_template": "$P4[$P0] = True\n$P2[$P0] = $P3[$P0] = $P7[0]\n$P7[0] += 1\nfor to in $P5[$P0]:\n    if to == $P1:\n        continue\n    if not $P4[to]:\n        dfs(to, $P0, $P2, $P3, $P4, $P5, $P6, $P7)\n        $P3[$P0] = min($P3[$P0], $P3[to])\n        if $P2[$P0] < $P3[to]:\n            $P6.append(($P0, to))\n    else:\n        $P3[$P0] = min($P3[$P0], $P2[to])",
    "description": "dfs (8 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_958": {
    "name": "stack_add_958",
    "pattern_type": "general",
    "code_template": "$P0.window.append($P1)\n$P0.freq_map[$P1] += 1\nif $P0.freq_map[$P1] > $P0.max_freq:\n    $P0.max_freq = $P0.freq_map[$P1]\n    $P0.max_freq_elements = {$P1}\nelif $P0.freq_map[$P1] == $P0.max_freq:\n    $P0.max_freq_elements.add($P1)\nif len($P0.window) > $P0.window_size:\n    $P0.remove()",
    "description": "add (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_remove_959": {
    "name": "stack_remove_959",
    "pattern_type": "general",
    "code_template": "if $P0.window:\n    num = $P0.window.popleft()\n    $P0.freq_map[num] -= 1\n    if $P0.freq_map[num] == $P0.max_freq - 1:\n        $P0.max_freq_elements.discard(num)\n        if not $P0.max_freq_elements:\n            $P0.max_freq -= 1\n            $P0.max_freq_elements = {k for (k, v) in $P0.freq_map.items() if v == $P0.max_freq}\n    elif $P0.freq_map[num] == $P0.max_freq:\n        $P0.max_freq_elements.add(num)",
    "description": "remove (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_max_frequency_element_960": {
    "name": "stack_get_max_frequency_element_960",
    "pattern_type": "general",
    "code_template": "if not $P0.max_freq_elements:\n    return (None, 0)\nreturn (list($P0.max_freq_elements), $P0.max_freq)",
    "description": "get_max_frequency_element (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_adjacency_list_to_matrix_961": {
    "name": "stack_adjacency_list_to_matrix_961",
    "pattern_type": "list",
    "code_template": "nodes = set()\nfor (node, neighbors) in $P0.items():\n    nodes.add(node)\n    for neighbor in neighbors:\n        nodes.add(neighbor)\nnode_to_index = {node: idx for (idx, node) in enumerate(sorted(nodes))}\nsize = len(nodes)\nadj_matrix = np.zeros((size, size), dtype=int)\nfor (node, neighbors) in $P0.items():\n    node_idx = node_to_index[node]\n    for neighbor in neighbors:\n        neighbor_idx = node_to_index[neighbor]\n        adj_matrix[node_idx][neighbor_idx] = 1\nreturn adj_matrix.tolist()",
    "description": "adjacency_list_to_matrix (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_matrix_to_adjacency_list_962": {
    "name": "stack_matrix_to_adjacency_list_962",
    "pattern_type": "list",
    "code_template": "index_to_node = {idx: str(idx) for idx in range(len($P0))}\nadj_list = defaultdict(list)\nfor (i, row) in enumerate($P0):\n    node = index_to_node[i]\n    for (j, val) in enumerate(row):\n        if val == 1:\n            neighbor = index_to_node[j]\n            adj_list[node].append(neighbor)\nreturn dict(adj_list)",
    "description": "matrix_to_adjacency_list (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_partition_array_963": {
    "name": "stack_partition_array_963",
    "pattern_type": "list",
    "code_template": "last_occurrence = {}\nfor (i, num) in enumerate($P0):\n    last_occurrence[num] = i\nstart = 0\nend = 0\nresult = []\nfor (i, num) in enumerate($P0):\n    end = max(end, last_occurrence[num])\n    if i == end:\n        result.append((start, end))\n        start = end + 1\nreturn result",
    "description": "partition_array (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_count_characters_964": {
    "name": "stack_count_characters_964",
    "pattern_type": "general",
    "code_template": "char_count = {}\nfor char in $P0:\n    if char in char_count:\n        char_count[char] += 1\n    else:\n        char_count[char] = 1\nreturn char_count",
    "description": "count_characters (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_reverseWords_965": {
    "name": "stack_reverseWords_965",
    "pattern_type": "general",
    "code_template": "words = $P0.split()\nreversed_words = words[::-1]\nreversed_string = ' '.join(reversed_words)\nreturn reversed_string",
    "description": "reverseWords (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_shortest_path_966": {
    "name": "stack_shortest_path_966",
    "pattern_type": "general",
    "code_template": "N = len($P0)\ndirections = [(-1, 0), (1, 0), (0, -1), (0, 1)]\nqueue = deque([($P1, 0)])\nvisited = set()\nvisited.add($P1)\nwhile queue:\n    ((x, y), path_length) = queue.popleft()\n    if (x, y) == $P2:\n        return path_length\n    for (dx, dy) in directions:\n        (nx, ny) = (x + dx, y + dy)\n        if 0 <= nx < N and 0 <= ny < N and ($P0[nx][ny] == 0) and ((nx, ny) not in visited):\n            queue.append(((nx, ny), path_length + 1))\n            visited.add((nx, ny))\nreturn -1",
    "description": "shortest_path (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_sha256_967": {
    "name": "stack_sha256_967",
    "pattern_type": "general",
    "code_template": "K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]\nH = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]\ndef right_rotate(value, amount):\n    return (value >> amount | value << 32 - amount) & 4294967295\ndef padding($P0):\n    message_in_bits = ''.join((f'{ord(c):08b}' for c in $P0))\n    original_length = len(message_in_bits)\n    message_in_bits += '1'\n    while len(message_in_bits) % 512 != 448:\n        message_in_bits += '0'\n    length_bits = bin(original_length)[2:].zfill(64)\n    message_in_bits += length_bits\n    return message_in_bits\ndef chunks($P0, size):\n    return [$P0[i:i + size] for i in range(0, len($P0), size)]\nmessage_bits = padding($P0)\nfor chunk in chunks(message_bits, 512):\n    words = chunks(chunk, 32)\n    w = [int(word, 2) for word in words] + [0] * (64 - 16)\n    for i in range(16, 64):\n        s0 = right_rotate(w[i - 15], 7) ^ right_rotate(w[i - 15], 18) ^ w[i - 15] >> 3\n        s1 = right_rotate(w[i - 2], 17) ^ right_rotate(w[i - 2], 19) ^ w[i - 2] >> 10\n        w[i] = w[i - 16] + s0 + w[i - 7] + s1 & 4294967295\n    (a, b, c, d, e, f, g, h) = H\n    for i in range(64):\n        S1 = right_rotate(e, 6) ^ right_rotate(e, 11) ^ right_rotate(e, 25)\n        ch = e & f ^ ~e & g\n        temp1 = h + S1 + ch + K[i] + w[i] & 4294967295\n        S0 = right_rotate(a, 2) ^ right_rotate(a, 13) ^ right_rotate(a, 22)\n        maj = a & b ^ a & c ^ b & c\n        temp2 = S0 + maj & 4294967295\n        h = g\n        g = f\n        f = e\n        e = d + temp1 & 4294967295\n        d = c\n        c = b\n        b = a\n        a = temp1 + temp2 & 4294967295\n    H = [x + y & 4294967295 for (x, y) in zip(H, [a, b, c, d, e, f, g, h])]\nreturn ''.join((f'{i:08x}' for i in H))",
    "description": "sha256 (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_right_rotate_968": {
    "name": "stack_right_rotate_968",
    "pattern_type": "general",
    "code_template": "return ($P0 >> $P1 | $P0 << 32 - $P1) & 4294967295",
    "description": "right_rotate (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_padding_969": {
    "name": "stack_padding_969",
    "pattern_type": "general",
    "code_template": "message_in_bits = ''.join((f'{ord(c):08b}' for c in $P0))\noriginal_length = len(message_in_bits)\nmessage_in_bits += '1'\nwhile len(message_in_bits) % 512 != 448:\n    message_in_bits += '0'\nlength_bits = bin(original_length)[2:].zfill(64)\nmessage_in_bits += length_bits\nreturn message_in_bits",
    "description": "padding (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_chunks_970": {
    "name": "stack_chunks_970",
    "pattern_type": "general",
    "code_template": "return [$P0[i:i + $P1] for i in range(0, len($P0), $P1)]",
    "description": "chunks (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_generate_cities_971": {
    "name": "stack_generate_cities_971",
    "pattern_type": "general",
    "code_template": "return [(random.uniform(0, 100), random.uniform(0, 100)) for _ in range($P0)]",
    "description": "generate_cities (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_calculate_distance_972": {
    "name": "stack_calculate_distance_972",
    "pattern_type": "general",
    "code_template": "return math.sqrt(($P0[0] - $P1[0]) ** 2 + ($P0[1] - $P1[1]) ** 2)",
    "description": "calculate_distance (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_initialize_population_973": {
    "name": "stack_initialize_population_973",
    "pattern_type": "general",
    "code_template": "population = []\nfor _ in range($P0):\n    individual = random.sample($P1, len($P1))\n    population.append(individual)\nreturn population",
    "description": "initialize_population (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_calculate_fitness_974": {
    "name": "stack_calculate_fitness_974",
    "pattern_type": "general",
    "code_template": "return sum((calculate_distance($P0[i], $P0[(i + 1) % len($P0)]) for i in range(len($P0))))",
    "description": "calculate_fitness (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_select_parents_975": {
    "name": "stack_select_parents_975",
    "pattern_type": "general",
    "code_template": "selected = random.sample(list(zip($P0, $P1)), $P2)\nselected.sort(key=lambda x: x[1])\nreturn (selected[0][0], selected[1][0])",
    "description": "select_parents (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_are_permutations_976": {
    "name": "stack_are_permutations_976",
    "pattern_type": "general",
    "code_template": "if len($P0) != len($P1):\n    return False\ncount_a = {}\ncount_b = {}\nfor num in $P0:\n    if num in count_a:\n        count_a[num] += 1\n    else:\n        count_a[num] = 1\nfor num in $P1:\n    if num in count_b:\n        count_b[num] += 1\n    else:\n        count_b[num] = 1\nreturn count_a == count_b",
    "description": "are_permutations (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_plot_maze_977": {
    "name": "stack_plot_maze_977",
    "pattern_type": "general",
    "code_template": "(fig, ax) = plt.subplots()\nax.set_xlim(-0.5, len($P0) - 0.5)\nax.set_ylim(-0.5, len($P0[0]) - 0.5)\nfor (y, row) in enumerate($P0):\n    for (x, value) in enumerate(row):\n        if value == 1:\n            ax.add_patch(patches.Rectangle((x - 0.5, len($P0) - y - 1.5), 1, 1, color='black'))\n        elif value > 1:\n            ax.add_patch(patches.Rectangle((x - 0.5, len($P0) - y - 1.5), 1, 1, color='lightgrey'))\nif $P1:\n    for (px, py) in $P1:\n        ax.add_patch(patches.Rectangle((px - 0.5, len($P0) - py - 1.5), 1, 1, color='blue', alpha=0.5))\nplt.show()",
    "description": "plot_maze (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_bfs_978": {
    "name": "stack_bfs_978",
    "pattern_type": "general",
    "code_template": "directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\nqueue = deque()\nqueue.append(($P1, [$P1]))\nvisited = set()\nvisited.add($P1)\nwhile queue:\n    ((x, y), path) = queue.popleft()\n    if (x, y) == (2, 2):\n        $P0[2][3] = 1\n        plot_maze($P0)\n    if (x, y) == $P2:\n        return path\n    for (dx, dy) in directions:\n        (nx, ny) = (x + dx, y + dy)\n        if 0 <= nx < len($P0[0]) and 0 <= ny < len($P0) and ((nx, ny) not in visited):\n            if $P0[ny][nx] == 0:\n                visited.add((nx, ny))\n                queue.append(((nx, ny), path + [(nx, ny)]))\n                plot_maze($P0, path + [(nx, ny)])\n                time.sleep(0.5)\nreturn None",
    "description": "bfs (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_count_special_substrings_979": {
    "name": "stack_count_special_substrings_979",
    "pattern_type": "string",
    "code_template": "special_substring_count = {}\nn = len($P0)\ni = 0\nwhile i < n:\n    current_char = $P0[i]\n    count = 0\n    while i < n and $P0[i] == current_char:\n        count += 1\n        i += 1\n    if count >= $P1:\n        num_k_length_substrings = count - $P1 + 1\n        if $P1 in special_substring_count:\n            special_substring_count[$P1] += num_k_length_substrings\n        else:\n            special_substring_count[$P1] = num_k_length_substrings\nreturn special_substring_count.get($P1, 0)",
    "description": "count_special_substrings (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_parse_activity_980": {
    "name": "stack_parse_activity_980",
    "pattern_type": "string",
    "code_template": "parts = $P0.split(',')\nname = parts[0].strip()\nstart_time = datetime.strptime(parts[1].strip(), '%Y-%m-%d %H:%M')\nend_time = datetime.strptime(parts[2].strip(), '%Y-%m-%d %H:%M')\nparticipants = int(parts[3].strip())\nreturn (name, start_time, end_time, participants)",
    "description": "parse_activity (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_calculate_hourly_average_981": {
    "name": "stack_calculate_hourly_average_981",
    "pattern_type": "general",
    "code_template": "hourly_participants = defaultdict(int)\nhourly_counts = defaultdict(int)\nfor activity_str in $P0:\n    (_, start_time, end_time, participants) = parse_activity(activity_str)\n    current_time = start_time\n    while current_time < end_time:\n        hour_start = current_time.replace(minute=0, second=0, microsecond=0)\n        hour_end = hour_start + timedelta(hours=1)\n        effective_start = max(current_time, hour_start)\n        effective_end = min(end_time, hour_end)\n        effective_duration = (effective_end - effective_start).total_seconds() / 3600\n        hourly_participants[hour_start] += participants * effective_duration\n        hourly_counts[hour_start] += effective_duration\n        current_time = hour_end\nhourly_average = {}\nfor (hour, total_participants) in hourly_participants.items():\n    if hourly_counts[hour] > 0:\n        hourly_average[hour] = total_participants / hourly_counts[hour]\n    else:\n        hourly_average[hour] = 0\nreturn hourly_average",
    "description": "calculate_hourly_average (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_determine_relationship_982": {
    "name": "stack_determine_relationship_982",
    "pattern_type": "general",
    "code_template": "unique_pairs = df.groupby([$P0, $P1]).size()\nunique_col1 = df[$P0].nunique()\nunique_col2 = df[$P1].nunique()\nif unique_pairs.size == unique_col1 == unique_col2:\n    return 'one-2-one'\nelif unique_pairs.size == unique_col1:\n    return 'one-2-many'\nelif unique_pairs.size == unique_col2:\n    return 'many-2-one'\nelse:\n    return 'many-2-many'",
    "description": "determine_relationship (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_evaluate_splits_983": {
    "name": "stack_evaluate_splits_983",
    "pattern_type": "general",
    "code_template": "results = {}\nfor (train_ratio, test_ratio) in $P0:\n    (X_train, X_test, y_train, y_test) = train_test_split(X, y, test_size=test_ratio, stratify=y, random_state=42)\n    model = LogisticRegression()\n    model.fit(X_train, y_train)\n    predictions = model.predict(X_test)\n    accuracy = accuracy_score(y_test, predictions)\n    results[f'{train_ratio * 100}/{test_ratio * 100}'] = accuracy\nreturn results",
    "description": "evaluate_splits (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_countEvenSumPairs_984": {
    "name": "stack_countEvenSumPairs_984",
    "pattern_type": "general",
    "code_template": "count = 0\nfor i in range(len($P0)):\n    for j in range(i + 1, len($P0)):\n        if ($P0[i] + $P0[j]) % 2 == 0:\n            count += 1\nreturn count",
    "description": "countEvenSumPairs (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_substring_with_all_words_985": {
    "name": "stack_find_substring_with_all_words_985",
    "pattern_type": "algorithm",
    "code_template": "if not $P0 or not $P1 or (not $P1[0]):\n    return []\nword_length = len($P1[0])\nword_count = len($P1)\ntotal_length = word_length * word_count\nword_frequency = {}\nfor word in $P1:\n    word_frequency[word] = word_frequency.get(word, 0) + 1\nresult_indices = []\nfor i in range(len($P0) - total_length + 1):\n    seen_words = {}\n    for j in range(word_count):\n        word_start = i + j * word_length\n        word = $P0[word_start:word_start + word_length]\n        if word in word_frequency:\n            seen_words[word] = seen_words.get(word, 0) + 1\n            if seen_words[word] > word_frequency[word]:\n                break\n        else:\n            break\n    if seen_words == word_frequency:\n        result_indices.append(i)\nreturn result_indices",
    "description": "find_substring_with_all_words (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_even_odd_switching_array_986": {
    "name": "stack_even_odd_switching_array_986",
    "pattern_type": "list",
    "code_template": "array = []\nfor i in range($P0):\n    if i % 2 == 0:\n        array.append(i)\n    else:\n        array.append(sum(array))\nreturn array",
    "description": "even_odd_switching_array (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_circularShift_987": {
    "name": "stack_circularShift_987",
    "pattern_type": "general",
    "code_template": "n = len($P0)\n$P1 = $P1 % n\nshifted_arr = $P0[-$P1:] + $P0[:-$P1]\nwrapped_arr = [x % 9 for x in shifted_arr]\nreturn wrapped_arr",
    "description": "circularShift (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_calculate_diagonals_sum_988": {
    "name": "stack_calculate_diagonals_sum_988",
    "pattern_type": "general",
    "code_template": "n = len($P0)\nmain_diagonal_sum = 0\nsecondary_diagonal_sum = 0\nfor i in range(n):\n    main_diagonal_sum += $P0[i][i]\n    secondary_diagonal_sum += $P0[i][n - 1 - i]\nreturn [main_diagonal_sum, secondary_diagonal_sum]",
    "description": "calculate_diagonals_sum (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_generate_sentences_989": {
    "name": "stack_generate_sentences_989",
    "pattern_type": "general",
    "code_template": "sentences = []\nfor subject in $P0:\n    for verb in $P1:\n        for obj in $P2:\n            sentence = f'{subject} {verb} {obj}'\n            sentences.append(sentence)\nreturn sentences",
    "description": "generate_sentences (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_question3_990": {
    "name": "stack_question3_990",
    "pattern_type": "general",
    "code_template": "last_a = -1\nfirst_b = -1\nfor (i, char) in enumerate($P0):\n    if char == 'a':\n        last_a = i\n    elif char == 'b' and first_b == -1:\n        first_b = i\nreturn first_b - last_a if last_a != -1 and first_b != -1 else -1",
    "description": "question3 (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_test_fibonacci_991": {
    "name": "stack_test_fibonacci_991",
    "pattern_type": "math",
    "code_template": "assert fibonacci(0) == 0, 'Test case n=0 failed'\nassert fibonacci(1) == 1, 'Test case n=1 failed'\nassert fibonacci(2) == 1, 'Test case n=2 failed'\nassert fibonacci(3) == 2, 'Test case n=3 failed'\nassert fibonacci(10) == 55, 'Test case n=10 failed'\nassert fibonacci(50) == 12586269025, 'Test case n=50 failed'\nprint('All test cases passed!')",
    "description": "test_fibonacci (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_search_992": {
    "name": "stack_search_992",
    "pattern_type": "algorithm",
    "code_template": "def dfs(node, path, result):\n    if node.is_end_of_word:\n        result.append(path)\n    for (char, next_node) in node.children.items():\n        dfs(next_node, path + char, result)\nnode = $P0.root\nfor char in $P1:\n    if char not in node.children:\n        return []\n    node = node.children[char]\nresult = []\ndfs(node, $P1, result)\nreturn result",
    "description": "search (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_993": {
    "name": "stack_dfs_993",
    "pattern_type": "general",
    "code_template": "if $P0.is_end_of_word:\n    $P2.append($P1)\nfor (char, next_node) in $P0.children.items():\n    dfs(next_node, $P1 + char, $P2)",
    "description": "dfs (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_tetrahedral_iterative_994": {
    "name": "stack_tetrahedral_iterative_994",
    "pattern_type": "general",
    "code_template": "tetrahedral_number = 0\nfor i in range(1, $P0 + 1):\n    triangular_number = i * (i + 1) // 2\n    tetrahedral_number += triangular_number\nreturn tetrahedral_number",
    "description": "tetrahedral_iterative (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_mysql_user_login_995": {
    "name": "stack_mysql_user_login_995",
    "pattern_type": "general",
    "code_template": "try:\n    connection = mysql.connector.connect(host='your_host', database='your_database', user='your_user', $P1='your_password')\n    sql_query = 'SELECT * FROM users WHERE $P0 = %s AND $P1 = %s'\n    cursor = connection.cursor()\n    cursor.execute(sql_query, ($P0, $P1))\n    user = cursor.fetchone()\n    if user:\n        print('\u767b\u5f55\u6210\u529f\uff01')\n    else:\n        print('\u7528\u6237\u540d\u6216\u5bc6\u7801\u9519\u8bef\u3002')\nexcept mysql.connector.Error as error:\n    print(f'\u6570\u636e\u5e93\u9519\u8bef\uff1a{error}')\nfinally:\n    if connection.is_connected():\n        cursor.close()\n        connection.close()",
    "description": "mysql_user_login (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_postgres_user_login_996": {
    "name": "stack_postgres_user_login_996",
    "pattern_type": "general",
    "code_template": "try:\n    connection = psycopg2.connect(host='your_host', database='your_database', user='your_user', $P1='your_password')\n    sql_query = 'SELECT * FROM users WHERE $P0 = %s AND $P1 = %s'\n    cursor = connection.cursor()\n    cursor.execute(sql_query, ($P0, $P1))\n    user = cursor.fetchone()\n    if user:\n        print('\u767b\u5f55\u6210\u529f\uff01')\n    else:\n        print('\u7528\u6237\u540d\u6216\u5bc6\u7801\u9519\u8bef\u3002')\nexcept psycopg2.Error as error:\n    print(f'\u6570\u636e\u5e93\u9519\u8bef\uff1a{error}')\nfinally:\n    if connection:\n        cursor.close()\n        connection.close()",
    "description": "postgres_user_login (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_complex_count_997": {
    "name": "stack_complex_count_997",
    "pattern_type": "general",
    "code_template": "count = 0\nwithin_bars = False\nfor char in $P0:\n    if char == '|':\n        within_bars = not within_bars\n    elif not within_bars:\n        if char.isalnum():\n            count += 1\nreturn count",
    "description": "complex_count (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_group_anagrams_998": {
    "name": "stack_group_anagrams_998",
    "pattern_type": "general",
    "code_template": "from collections import defaultdict\nanagrams = defaultdict(list)\nfor string in $P0:\n    key = tuple(sorted(string))\n    anagrams[key].append(string)\nresult = []\nfor group in anagrams.values():\n    sorted_group = sorted(group)\n    result.append(set(sorted_group))\nresult.sort(key=lambda s: next(iter(s)))\nreturn result",
    "description": "group_anagrams (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_overlapping_999": {
    "name": "stack_is_overlapping_999",
    "pattern_type": "general",
    "code_template": "return not ($P0[1] <= $P1[0] or $P1[1] <= $P0[0])",
    "description": "is_overlapping (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_max_non_overlapping_set_1000": {
    "name": "stack_find_max_non_overlapping_set_1000",
    "pattern_type": "algorithm",
    "code_template": "$P0.sort(key=lambda x: x[1])\nmax_set = []\nlast_end = $P1[0]\nfor interval in $P0:\n    if not is_overlapping(interval, $P1) and interval[0] >= last_end:\n        max_set.append(interval)\n        last_end = interval[1]\nreturn max_set",
    "description": "find_max_non_overlapping_set (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_best_non_overlapping_set_1001": {
    "name": "stack_find_best_non_overlapping_set_1001",
    "pattern_type": "algorithm",
    "code_template": "target_interval = $P0[$P1]\nbest_set = []\nbest_row_index = -1\nfor (i, row) in enumerate($P0):\n    if i == $P1:\n        continue\n    current_set = find_max_non_overlapping_set(row, target_interval)\n    if len(current_set) > len(best_set):\n        best_set = current_set\n        best_row_index = i\nreturn (best_row_index, best_set)",
    "description": "find_best_non_overlapping_set (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_unique_1002": {
    "name": "stack_find_unique_1002",
    "pattern_type": "algorithm",
    "code_template": "result = 0\nfor num in $P0:\n    result ^= num\nreturn result",
    "description": "find_unique (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_generate_csrf_token_1003": {
    "name": "stack_generate_csrf_token_1003",
    "pattern_type": "general",
    "code_template": "if 'csrf_token' not in session:\n    session['csrf_token'] = secrets.token_hex(16)",
    "description": "generate_csrf_token (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_validate_csrf_token_1004": {
    "name": "stack_validate_csrf_token_1004",
    "pattern_type": "general",
    "code_template": "return $P0 == session.get('csrf_token')",
    "description": "validate_csrf_token (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_form_1005": {
    "name": "stack_form_1005",
    "pattern_type": "general",
    "code_template": "if request.method == 'POST':\n    if not validate_csrf_token(request.form.get('csrf_token')):\n        return ('CSRF Token\u9a8c\u8bc1\u5931\u8d25', 400)\n    return ('\u8868\u5355\u63d0\u4ea4\u6210\u529f', 200)\nreturn render_template_string('\\n        <form method=\"post\">\\n            <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token }}\">\\n            <input type=\"text\" name=\"example_input\">\\n            <input type=\"submit\" value=\"\u63d0\u4ea4\">\\n        </form>\\n    ', csrf_token=session['csrf_token'])",
    "description": "form (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_display_1006": {
    "name": "stack_display_1006",
    "pattern_type": "general",
    "code_template": "user_input = request.form.get('user_input')\nsafe_input = escape(user_input)\nreturn f'\u7528\u6237\u8f93\u5165: {safe_input}'",
    "description": "display (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_smallest_divisor_greater_than_t_1007": {
    "name": "stack_smallest_divisor_greater_than_t_1007",
    "pattern_type": "general",
    "code_template": "def is_valid(d):\n    total = sum((math.ceil(a / d) for a in $P0))\n    return total <= $P2\n(left, right) = ($P1 + 1, max($P0))\nresult = -1\nwhile left <= right:\n    mid = (left + right) // 2\n    if is_valid(mid):\n        result = mid\n        right = mid - 1\n    else:\n        left = mid + 1\nreturn result",
    "description": "smallest_divisor_greater_than_t (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_valid_1008": {
    "name": "stack_is_valid_1008",
    "pattern_type": "general",
    "code_template": "total = sum((math.ceil(a / $P0) for a in A))\nreturn total <= S",
    "description": "is_valid (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_non_repetitive_purchase_strategy_1009": {
    "name": "stack_non_repetitive_purchase_strategy_1009",
    "pattern_type": "string",
    "code_template": "m = len($P0)\nvisited_shops = set()\ntotal_items_bought = 0\nremaining_budget = $P2 * $P1\nfor _ in range($P1):\n    best_shop = -1\n    max_items = 0\n    best_remaining_budget = 0\n    for shop in range(m):\n        if shop in visited_shops:\n            continue\n        sorted_items = sorted($P0[shop])\n        current_budget = $P2\n        items_bought = 0\n        for cost in sorted_items:\n            if current_budget >= cost:\n                current_budget -= cost\n                items_bought += 1\n            else:\n                break\n        if items_bought > max_items or (items_bought == max_items and current_budget > best_remaining_budget):\n            best_shop = shop\n            max_items = items_bought\n            best_remaining_budget = current_budget\n    if best_shop != -1:\n        visited_shops.add(best_shop)\n        total_items_bought += max_items\n        remaining_budget -= $P2 - best_remaining_budget\nreturn (total_items_bought, remaining_budget)",
    "description": "non_repetitive_purchase_strategy (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_clean_feedback_1010": {
    "name": "stack_clean_feedback_1010",
    "pattern_type": "general",
    "code_template": "$P0 = $P0.lower()\n$P0 = $P0.translate(str.maketrans('', '', string.punctuation))\nwords = word_tokenize($P0)\nwords = [word for word in words if word not in stopwords.words('english')]\nreturn words",
    "description": "clean_feedback (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_compute_lps_1011": {
    "name": "stack_compute_lps_1011",
    "pattern_type": "general",
    "code_template": "$P0 = $P0.lower()\nlength = 0\nlps = [0] * len($P0)\ni = 1\nwhile i < len($P0):\n    if $P0[i] == $P0[length]:\n        length += 1\n        lps[i] = length\n        i += 1\n    elif length != 0:\n        length = lps[length - 1]\n    else:\n        lps[i] = 0\n        i += 1\nreturn lps",
    "description": "compute_lps (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_kmp_search_all_1012": {
    "name": "stack_kmp_search_all_1012",
    "pattern_type": "algorithm",
    "code_template": "$P0 = $P0.lower()\n$P1 = $P1.lower()\nn = len($P0)\nm = len($P1)\nlps = compute_lps($P1)\nindices = []\ni = 0\nj = 0\nwhile i < n:\n    if $P1[j] == $P0[i]:\n        i += 1\n        j += 1\n    if j == m:\n        indices.append(i - j)\n        j = lps[j - 1]\n    elif i < n and $P1[j] != $P0[i]:\n        if j != 0:\n            j = lps[j - 1]\n        else:\n            i += 1\nreturn indices",
    "description": "kmp_search_all (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_extract_vowels_1013": {
    "name": "stack_extract_vowels_1013",
    "pattern_type": "general",
    "code_template": "vowels = 'aeiouAEIOU'\nresult = ''\nfor s in $P0:\n    for char in s:\n        if char in vowels:\n            result += char\nreturn result",
    "description": "extract_vowels (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_anagrams_1014": {
    "name": "stack_find_anagrams_1014",
    "pattern_type": "algorithm",
    "code_template": "result = []\n(len_s, len_p) = (len($P0), len($P1))\nif len_p > len_s:\n    return result\np_count = Counter($P1)\nwindow_count = Counter()\nfor i in range(len_p):\n    window_count[$P0[i]] += 1\nif window_count == p_count:\n    result.append(0)\nfor i in range(len_p, len_s):\n    window_count[$P0[i]] += 1\n    window_count[$P0[i - len_p]] -= 1\n    if window_count[$P0[i - len_p]] == 0:\n        del window_count[$P0[i - len_p]]\n    if window_count == p_count:\n        result.append(i - len_p + 1)\nreturn result",
    "description": "find_anagrams (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_permute_unique_1015": {
    "name": "stack_permute_unique_1015",
    "pattern_type": "general",
    "code_template": "def backtrack(path, used):\n    if len(path) == len($P0):\n        results.append(''.join(path))\n        return\n    for i in range(len($P0)):\n        if used[i]:\n            continue\n        if i > 0 and $P0[i] == $P0[i - 1] and (not used[i - 1]):\n            continue\n        used[i] = True\n        path.append($P0[i])\n        backtrack(path, used)\n        path.pop()\n        used[i] = False\nresults = []\n$P0 = sorted($P0)\nbacktrack([], [False] * len($P0))\nreturn results",
    "description": "permute_unique (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_backtrack_1016": {
    "name": "stack_backtrack_1016",
    "pattern_type": "general",
    "code_template": "if len($P0) == len(s):\n    results.append(''.join($P0))\n    return\nfor i in range(len(s)):\n    if $P1[i]:\n        continue\n    if i > 0 and s[i] == s[i - 1] and (not $P1[i - 1]):\n        continue\n    $P1[i] = True\n    $P0.append(s[i])\n    backtrack($P0, $P1)\n    $P0.pop()\n    $P1[i] = False",
    "description": "backtrack (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_min_cost_to_construct_string_1017": {
    "name": "stack_min_cost_to_construct_string_1017",
    "pattern_type": "string",
    "code_template": "dp = [[0] * 2 for _ in range($P0 + 1)]\ndp[1][0] = $P1\ndp[1][1] = $P2\nfor i in range(2, $P0 + 1):\n    dp[i][0] = dp[i - 1][1] + $P1\n    dp[i][1] = dp[i - 1][0] + $P2\nreturn min(dp[$P0][0], dp[$P0][1])",
    "description": "min_cost_to_construct_string (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_optimal_subarray_traversal_1018": {
    "name": "stack_optimal_subarray_traversal_1018",
    "pattern_type": "list",
    "code_template": "n = len($P0)\nif n == 0:\n    return 0\ndp = $P0[:]\nfor i in range(1, n):\n    for j in range(i):\n        if $P0[j] < $P0[i]:\n            dp[i] = max(dp[i], dp[j] + $P0[i])\nreturn max(dp)",
    "description": "optimal_subarray_traversal (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_first_missing_positive_1019": {
    "name": "stack_find_first_missing_positive_1019",
    "pattern_type": "algorithm",
    "code_template": "doubled_arr = [x * 2 for x in $P0]\ndoubled_arr.sort(reverse=True)\nsmallest_missing_positive = 1\nchecked_values = set(doubled_arr)\nwhile smallest_missing_positive in checked_values:\n    smallest_missing_positive += 1\nreturn smallest_missing_positive",
    "description": "find_first_missing_positive (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_simple_compression_1020": {
    "name": "stack_simple_compression_1020",
    "pattern_type": "general",
    "code_template": "return len(str($P0))",
    "description": "simple_compression (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_title_1021": {
    "name": "stack_get_title_1021",
    "pattern_type": "general",
    "code_template": "return $P0.__title",
    "description": "get_title (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_author_1022": {
    "name": "stack_get_author_1022",
    "pattern_type": "general",
    "code_template": "return $P0.__author",
    "description": "get_author (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_isbn_1023": {
    "name": "stack_get_isbn_1023",
    "pattern_type": "general",
    "code_template": "return $P0.__isbn",
    "description": "get_isbn (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_available_1024": {
    "name": "stack_is_available_1024",
    "pattern_type": "general",
    "code_template": "return $P0.__is_available",
    "description": "is_available (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_find_connected_components_and_shortest_paths_1025": {
    "name": "stack_find_connected_components_and_shortest_paths_1025",
    "pattern_type": "algorithm",
    "code_template": "def dfs(node, visited):\n    visited.add(node)\n    component.append(node)\n    for neighbor in $P0.get(node, {}):\n        if neighbor not in visited:\n            dfs(neighbor, visited)\nvisited = set()\ncomponents = []\nfor node in $P0:\n    if node not in visited:\n        component = []\n        dfs(node, visited)\n        components.append(component)\ndef dijkstra(subgraph, $P1):\n    import heapq\n    distances = {node: float('inf') for node in subgraph}\n    distances[$P1] = 0\n    priority_queue = [(0, $P1)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in subgraph[current_node].items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    return distances\nnum_components = len(components)\nprint(f'\u8fde\u901a\u5206\u91cf\u6570: {num_components}')\nfor component in components:\n    if $P1 in component:\n        subgraph = {node: $P0[node] for node in component}\n        shortest_paths = dijkstra(subgraph, $P1)\n        print(f'\u4ece\u8282\u70b9 {$P1} \u7684\u6700\u77ed\u8def\u5f84: {shortest_paths}')\n        return (num_components, shortest_paths)",
    "description": "find_connected_components_and_shortest_paths (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_1026": {
    "name": "stack_dfs_1026",
    "pattern_type": "general",
    "code_template": "$P1.add($P0)\ncomponent.append($P0)\nfor neighbor in graph.get($P0, {}):\n    if neighbor not in $P1:\n        dfs(neighbor, $P1)",
    "description": "dfs (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dijkstra_1027": {
    "name": "stack_dijkstra_1027",
    "pattern_type": "string",
    "code_template": "import heapq\ndistances = {node: float('inf') for node in $P0}\ndistances[$P1] = 0\npriority_queue = [(0, $P1)]\nwhile priority_queue:\n    (current_distance, current_node) = heapq.heappop(priority_queue)\n    if current_distance > distances[current_node]:\n        continue\n    for (neighbor, weight) in $P0[current_node].items():\n        distance = current_distance + weight\n        if distance < distances[neighbor]:\n            distances[neighbor] = distance\n            heapq.heappush(priority_queue, (distance, neighbor))\nreturn distances",
    "description": "dijkstra (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_swap_1028": {
    "name": "stack_swap_1028",
    "pattern_type": "general",
    "code_template": "($P0.heap[$P1], $P0.heap[$P2]) = ($P0.heap[$P2], $P0.heap[$P1])",
    "description": "swap (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_parent_1029": {
    "name": "stack_parent_1029",
    "pattern_type": "general",
    "code_template": "return ($P1 - 1) // 2 if $P1 > 0 else None",
    "description": "parent (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_left_child_1030": {
    "name": "stack_left_child_1030",
    "pattern_type": "general",
    "code_template": "return 2 * $P1 + 1",
    "description": "left_child (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_quick_sort_1031": {
    "name": "stack_quick_sort_1031",
    "pattern_type": "algorithm",
    "code_template": "if len($P0) <= 1:\n    return $P0\nelse:\n    pivot = $P0[len($P0) // 2]\n    left = [x for x in $P0 if x < pivot]\n    middle = [x for x in $P0 if x == pivot]\n    right = [x for x in $P0 if x > pivot]\n    return quick_sort(left) + middle + quick_sort(right)",
    "description": "quick_sort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_merge_sort_1032": {
    "name": "stack_merge_sort_1032",
    "pattern_type": "algorithm",
    "code_template": "if len($P0) > 1:\n    mid = len($P0) // 2\n    L = $P0[:mid]\n    R = $P0[mid:]\n    merge_sort(L)\n    merge_sort(R)\n    i = j = k = 0\n    while i < len(L) and j < len(R):\n        if L[i] < R[j]:\n            $P0[k] = L[i]\n            i += 1\n        else:\n            $P0[k] = R[j]\n            j += 1\n        k += 1\n    while i < len(L):\n        $P0[k] = L[i]\n        i += 1\n        k += 1\n    while j < len(R):\n        $P0[k] = R[j]\n        j += 1\n        k += 1\nreturn $P0",
    "description": "merge_sort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_bubble_sort_1033": {
    "name": "stack_bubble_sort_1033",
    "pattern_type": "algorithm",
    "code_template": "n = len($P0)\nfor i in range(n - 1):\n    for j in range(n - i - 1):\n        if $P0[j] > $P0[j + 1]:\n            ($P0[j], $P0[j + 1]) = ($P0[j + 1], $P0[j])\nreturn $P0",
    "description": "bubble_sort (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_test_sorting_algorithms_1034": {
    "name": "stack_test_sorting_algorithms_1034",
    "pattern_type": "algorithm",
    "code_template": "for size in $P0:\n    test_data = [random.randint(0, 10000) for _ in range(size)]\n    algorithms = [quick_sort, merge_sort, bubble_sort]\n    for algo in algorithms:\n        data_copy = test_data.copy()\n        start_time = time.time()\n        algo(data_copy)\n        elapsed_time = time.time() - start_time\n        print(f'{algo.__name__} sorted {size} elements in {elapsed_time:.5f} seconds')\n    print()",
    "description": "test_sorting_algorithms (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_add_to_tail_1035": {
    "name": "stack_add_to_tail_1035",
    "pattern_type": "general",
    "code_template": "new_node = Node($P1)\nif not $P0.tail:\n    $P0.head = $P0.tail = new_node\nelse:\n    new_node.prev = $P0.tail\n    $P0.tail.next = new_node\n    $P0.tail = new_node",
    "description": "add_to_tail (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_remove_from_head_1036": {
    "name": "stack_remove_from_head_1036",
    "pattern_type": "general",
    "code_template": "if not $P0.head:\n    return None\nvalue = $P0.head.value\nif $P0.head == $P0.tail:\n    $P0.head = $P0.tail = None\nelse:\n    $P0.head = $P0.head.next\n    $P0.head.prev = None\nreturn value",
    "description": "remove_from_head (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_detect_cycle_and_find_feedback_nodes_1037": {
    "name": "stack_detect_cycle_and_find_feedback_nodes_1037",
    "pattern_type": "algorithm",
    "code_template": "num_vertices = len($P0)\nvisited = [False] * num_vertices\nrec_stack = [False] * num_vertices\ncycle_path = []\ndef dfs(node):\n    nonlocal cycle_path\n    visited[node] = True\n    rec_stack[node] = True\n    for neighbor in $P0[node]:\n        if not visited[neighbor]:\n            if dfs(neighbor):\n                cycle_path.append(node)\n                return True\n        elif rec_stack[neighbor]:\n            cycle_path.append(neighbor)\n            cycle_path.append(node)\n            return True\n    rec_stack[node] = False\n    return False\nfor vertex in range(num_vertices):\n    if not visited[vertex]:\n        if dfs(vertex):\n            return cycle_path[::-1]\nreturn []",
    "description": "detect_cycle_and_find_feedback_nodes (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_1038": {
    "name": "stack_dfs_1038",
    "pattern_type": "general",
    "code_template": "nonlocal cycle_path\nvisited[$P0] = True\nrec_stack[$P0] = True\nfor neighbor in graph[$P0]:\n    if not visited[neighbor]:\n        if dfs(neighbor):\n            cycle_path.append($P0)\n            return True\n    elif rec_stack[neighbor]:\n        cycle_path.append(neighbor)\n        cycle_path.append($P0)\n        return True\nrec_stack[$P0] = False\nreturn False",
    "description": "dfs (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_max_subarray_sum_1039": {
    "name": "stack_max_subarray_sum_1039",
    "pattern_type": "list",
    "code_template": "max_current = $P0[0]\nmax_global = $P0[0]\nfor i in range(1, len($P0)):\n    max_current = max($P0[i], max_current + $P0[i])\n    if max_current > max_global:\n        max_global = max_current\nreturn max_global",
    "description": "max_subarray_sum (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_acquire_1040": {
    "name": "stack_acquire_1040",
    "pattern_type": "general",
    "code_template": "return $P0._available_objects.pop() if $P0._available_objects else None",
    "description": "acquire (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_release_1041": {
    "name": "stack_release_1041",
    "pattern_type": "general",
    "code_template": "$P0._available_objects.append($P1)",
    "description": "release (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_insert_1042": {
    "name": "stack_insert_1042",
    "pattern_type": "general",
    "code_template": "$P0.heap.append($P1)\n$P0._bubble_up(len($P0.heap) - 1)",
    "description": "insert (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_extract_min_1043": {
    "name": "stack_extract_min_1043",
    "pattern_type": "general",
    "code_template": "if len($P0.heap) <= 1:\n    return None\n$P0._swap(1, len($P0.heap) - 1)\nmin_val = $P0.heap.pop()\nif len($P0.heap) > 1:\n    $P0._bubble_down(1)\nreturn min_val",
    "description": "extract_min (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_main_1044": {
    "name": "stack_main_1044",
    "pattern_type": "general",
    "code_template": "tree = AVLTree()\nroot = None\nkeys = [10, 20, 30, 40, 50, 25]\nfor key in keys:\n    root = tree.insert(root, key)\nroot = tree.delete(root, 40)",
    "description": "main (0 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_get_balance_1045": {
    "name": "stack_get_balance_1045",
    "pattern_type": "general",
    "code_template": "if not $P1:\n    return 0\nreturn $P0.get_height($P1.left) - $P0.get_height($P1.right)",
    "description": "get_balance (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_longest_unique_substring_1046": {
    "name": "stack_longest_unique_substring_1046",
    "pattern_type": "string",
    "code_template": "charset_set = set($P1)\nn = len($P0)\nleft = 0\nmax_length = 0\nmax_substring = ''\nchar_count = {}\nfor right in range(n):\n    char = $P0[right]\n    if char in charset_set:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    while any((count > 1 for count in char_count.values())):\n        left_char = $P0[left]\n        if left_char in char_count:\n            char_count[left_char] -= 1\n            if char_count[left_char] == 0:\n                del char_count[left_char]\n        left += 1\n    if all((count == 1 for count in char_count.values())):\n        current_length = right - left + 1\n        if current_length > max_length:\n            max_length = current_length\n            max_substring = $P0[left:right + 1]\nreturn max_substring",
    "description": "longest_unique_substring (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_decomposeAndRearrange_1047": {
    "name": "stack_decomposeAndRearrange_1047",
    "pattern_type": "general",
    "code_template": "digits = list(str($P0))\npermutations = set(itertools.permutations(digits))\npossible_numbers = set()\nfor perm in permutations:\n    num_str = ''.join(perm)\n    num = int(num_str)\n    if len(num_str) == len(str(num)):\n        possible_numbers.add(num)\nreturn sorted(possible_numbers)",
    "description": "decomposeAndRearrange (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_permute_string_1048": {
    "name": "stack_permute_string_1048",
    "pattern_type": "string",
    "code_template": "import itertools\nimport functools\nfrom collections import Counter\ndef backtrack(path, counter):\n    if len(path) == len($P0):\n        permutations.append(''.join(path))\n        return\n    for char in counter:\n        if counter[char] > 0:\n            path.append(char)\n            counter[char] -= 1\n            backtrack(path, counter)\n            path.pop()\n            counter[char] += 1\npermutations = []\ncounter = Counter($P0)\nbacktrack([], counter)\nreturn permutations",
    "description": "permute_string (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_backtrack_1049": {
    "name": "stack_backtrack_1049",
    "pattern_type": "general",
    "code_template": "if len($P0) == len(s):\n    permutations.append(''.join($P0))\n    return\nfor char in $P1:\n    if $P1[char] > 0:\n        $P0.append(char)\n        $P1[char] -= 1\n        backtrack($P0, $P1)\n        $P0.pop()\n        $P1[char] += 1",
    "description": "backtrack (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_isFeasibleMove_1050": {
    "name": "stack_isFeasibleMove_1050",
    "pattern_type": "general",
    "code_template": "if not $P0 or not $P0[0]:\n    return False\nrows = len($P0)\ncols = len($P0[0])\nif $P1 < 0 or $P1 >= rows or $P2 < 0 or ($P2 >= cols):\n    return False\nif $P0[0][0] != 1 or $P0[$P1][$P2] != 1:\n    return False\ndef dfs(x, y, visited):\n    if x == $P1 and y == $P2:\n        return True\n    visited.add((x, y))\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    for (dx, dy) in directions:\n        (nx, ny) = (x + dx, y + dy)\n        if 0 <= nx < rows and 0 <= ny < cols and ((nx, ny) not in visited) and ($P0[nx][ny] == 1):\n            if dfs(nx, ny, visited):\n                return True\n    return False\nvisited = set()\nreturn dfs(0, 0, visited)",
    "description": "isFeasibleMove (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_dfs_1051": {
    "name": "stack_dfs_1051",
    "pattern_type": "general",
    "code_template": "if $P0 == target_i and $P1 == target_j:\n    return True\n$P2.add(($P0, $P1))\ndirections = [(0, 1), (1, 0), (0, -1), (-1, 0)]\nfor (dx, dy) in directions:\n    (nx, ny) = ($P0 + dx, $P1 + dy)\n    if 0 <= nx < rows and 0 <= ny < cols and ((nx, ny) not in $P2) and (grid[nx][ny] == 1):\n        if dfs(nx, ny, $P2):\n            return True\nreturn False",
    "description": "dfs (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_inorder_traversal_1052": {
    "name": "stack_inorder_traversal_1052",
    "pattern_type": "general",
    "code_template": "result = []\n$P0._inorder_traversal($P0.root, result)\nreturn result",
    "description": "inorder_traversal (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_analyze_matches_1053": {
    "name": "stack_analyze_matches_1053",
    "pattern_type": "general",
    "code_template": "if isinstance($P0, int):\n    $P0 = bin($P0)[2:]\ntotal_wins = $P0.count('1')\nmax_additional_wins = 0\nfor i in range(len($P0)):\n    if $P0[i] == '0':\n        additional_wins = 1\n        max_additional_wins = max(max_additional_wins, additional_wins)\nreturn (total_wins, max_additional_wins)",
    "description": "analyze_matches (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_solve_n_queens_1054": {
    "name": "stack_solve_n_queens_1054",
    "pattern_type": "general",
    "code_template": "def is_valid(board, row, column):\n    for i in range(row):\n        if board[i] == column:\n            return False\n        if abs(board[i] - column) == abs(i - row):\n            return False\n    return True\ndef backtrack(row=0):\n    if row == $P0:\n        result.append(board[:])\n        return\n    for column in range($P0):\n        if is_valid(board, row, column):\n            board[row] = column\n            backtrack(row + 1)\n            board[row] = -1\nboard = [-1] * $P0\nresult = []\nbacktrack()\nreturn result",
    "description": "solve_n_queens (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_is_valid_1055": {
    "name": "stack_is_valid_1055",
    "pattern_type": "general",
    "code_template": "for i in range($P1):\n    if $P0[i] == $P2:\n        return False\n    if abs($P0[i] - $P2) == abs(i - $P1):\n        return False\nreturn True",
    "description": "is_valid (3 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_backtrack_1056": {
    "name": "stack_backtrack_1056",
    "pattern_type": "general",
    "code_template": "if $P0 == n:\n    result.append(board[:])\n    return\nfor column in range(n):\n    if is_valid(board, $P0, column):\n        board[$P0] = column\n        backtrack($P0 + 1)\n        board[$P0] = -1",
    "description": "backtrack (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_naive_string_matching_1057": {
    "name": "stack_naive_string_matching_1057",
    "pattern_type": "string",
    "code_template": "for i in range(len($P0) - len($P1) + 1):\n    match = True\n    for j in range(len($P1)):\n        if $P0[i + j] != $P1[j]:\n            match = False\n            break\n    if match:\n        return i\nreturn -1",
    "description": "naive_string_matching (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_compute_lps_1058": {
    "name": "stack_compute_lps_1058",
    "pattern_type": "general",
    "code_template": "length = 0\nlps = [0] * len($P0)\ni = 1\nwhile i < len($P0):\n    if $P0[i] == $P0[length]:\n        length += 1\n        lps[i] = length\n        i += 1\n    elif length != 0:\n        length = lps[length - 1]\n    else:\n        lps[i] = 0\n        i += 1\nreturn lps",
    "description": "compute_lps (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_kmp_string_matching_1059": {
    "name": "stack_kmp_string_matching_1059",
    "pattern_type": "string",
    "code_template": "lps = compute_lps($P1)\ni = 0\nj = 0\nwhile i < len($P0):\n    if $P0[i] == $P1[j]:\n        i += 1\n        j += 1\n    if j == len($P1):\n        return i - j\n    elif i < len($P0) and $P0[i] != $P1[j]:\n        if j != 0:\n            j = lps[j - 1]\n        else:\n            i += 1\nreturn -1",
    "description": "kmp_string_matching (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_performance_comparison_1060": {
    "name": "stack_performance_comparison_1060",
    "pattern_type": "general",
    "code_template": "start_time = time.time()\nnaive_string_matching($P0, $P1)\nnaive_time = time.time() - start_time\nstart_time = time.time()\nkmp_string_matching($P0, $P1)\nkmp_time = time.time() - start_time\nprint(f'Naive Time: {naive_time:.10f} seconds')\nprint(f'KMP Time: {kmp_time:.10f} seconds')",
    "description": "performance_comparison (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_huffman_compress_1061": {
    "name": "stack_huffman_compress_1061",
    "pattern_type": "general",
    "code_template": "return (b'compressed_data', 1.0)",
    "description": "huffman_compress (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "stack_huffman_decompress_1062": {
    "name": "stack_huffman_decompress_1062",
    "pattern_type": "general",
    "code_template": "return b'original_data'",
    "description": "huffman_decompress (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "evolved_factorial": {
    "name": "evolved_factorial",
    "pattern_type": "evolved",
    "code_template": "MOD = 10**9 + 7\n\ndef factorial($P0):\n    fact = [1] * ($P0 + 1)\n    for i in range(2, $P0 + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    return fact[$P0]",
    "description": "Evolved factorial (1 params)",
    "confidence": 1.0,
    "times_verified": 0
  },
  "evolved_binary_search": {
    "name": "evolved_binary_search",
    "pattern_type": "evolved",
    "code_template": "(left, right) = (0, len($P0) - 1)\nwhile left <= right:\n    mid = left + (right - left) // 2\n    if $P0[mid] == $P1:\n        return mid\n    elif $P0[mid] < $P1:\n        left = mid + 1\n    else:\n        right = mid - 1\nreturn -1",
    "description": "Evolved binary_search (2 params)",
    "confidence": 1.0,
    "times_verified": 0
  }
}